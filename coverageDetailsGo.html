
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/harmony-one/harmony/core/blockchain.go (25.9%)</option>
				
				<option value="file1">github.com/harmony-one/harmony/core/evm.go (65.1%)</option>
				
				<option value="file2">github.com/harmony-one/harmony/core/staking_verifier.go (98.5%)</option>
				
				<option value="file3">github.com/harmony-one/harmony/core/state_processor.go (47.8%)</option>
				
				<option value="file4">github.com/harmony-one/harmony/core/state_transition.go (69.4%)</option>
				
				<option value="file5">github.com/harmony-one/harmony/core/vm/contracts_write.go (82.0%)</option>
				
				<option value="file6">github.com/harmony-one/harmony/core/vm/evm.go (37.0%)</option>
				
				<option value="file7">github.com/harmony-one/harmony/internal/params/config.go (60.4%)</option>
				
				<option value="file8">github.com/harmony-one/harmony/staking/precompile.go (94.6%)</option>
				
				<option value="file9">github.com/harmony-one/harmony/staking/types/validator.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

// Package core implements the Ethereum consensus protocol.
package core

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "math/big"
        "os"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/mclock"
        "github.com/ethereum/go-ethereum/common/prque"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/ethdb"
        "github.com/ethereum/go-ethereum/event"
        "github.com/ethereum/go-ethereum/metrics"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/consensus/reward"
        "github.com/harmony-one/harmony/consensus/votepower"
        "github.com/harmony-one/harmony/core/rawdb"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/numeric"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/shard/committee"
        "github.com/harmony-one/harmony/staking/apr"
        "github.com/harmony-one/harmony/staking/effective"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        lru "github.com/hashicorp/golang-lru"
        "github.com/pkg/errors"
)

var (
        // blockInsertTimer
        blockInsertTimer = metrics.NewRegisteredTimer("chain/inserts", nil)
        // ErrNoGenesis is the error when there is no genesis.
        ErrNoGenesis = errors.New("Genesis not found in chain")
        // errExceedMaxPendingSlashes ..
        errExceedMaxPendingSlashes = errors.New("exceeed max pending slashes")
        errNilEpoch                = errors.New("nil epoch for voting power computation")
)

const (
        bodyCacheLimit                     = 2048
        blockCacheLimit                    = 2048
        receiptsCacheLimit                 = 32
        maxFutureBlocks                    = 256
        maxTimeFutureBlocks                = 30
        badBlockLimit                      = 10
        triesInMemory                      = 128
        shardCacheLimit                    = 10
        commitsCacheLimit                  = 10
        epochCacheLimit                    = 10
        randomnessCacheLimit               = 10
        validatorCacheLimit                = 1024
        validatorStatsCacheLimit           = 1024
        validatorListCacheLimit            = 10
        validatorListByDelegatorCacheLimit = 1024
        pendingCrossLinksCacheLimit        = 2
        blockAccumulatorCacheLimit         = 256
        maxPendingSlashes                  = 512
        // BlockChainVersion ensures that an incompatible database forces a resync from scratch.
        BlockChainVersion = 3
        pendingCLCacheKey = "pendingCLs"
)

// CacheConfig contains the configuration values for the trie caching/pruning
// that's resident in a blockchain.
type CacheConfig struct {
        Disabled      bool          // Whether to disable trie write caching (archive node)
        TrieNodeLimit int           // Memory limit (MB) at which to flush the current in-memory trie to disk
        TrieTimeLimit time.Duration // Time limit after which to flush the current in-memory trie to disk
}

// BlockChain represents the canonical chain given a database with a genesis
// block. The Blockchain manages chain imports, reverts, chain reorganisations.
//
// Importing blocks in to the block chain happens according to the set of rules
// defined by the two stage validator. Processing of blocks is done using the
// Processor which processes the included transaction. The validation of the state
// is done in the second part of the validator. Failing results in aborting of
// the import.
//
// The BlockChain also helps in returning blocks from **any** chain included
// in the database as well as blocks that represents the canonical chain. It's
// important to note that GetBlock can return any block and does not need to be
// included in the canonical one where as GetBlockByNumber always represents the
// canonical chain.
type BlockChain struct {
        chainConfig *params.ChainConfig // Chain &amp; network configuration
        cacheConfig *CacheConfig        // Cache configuration for pruning

        db     ethdb.Database // Low level persistent database to store final content in
        triegc *prque.Prque   // Priority queue mapping block numbers to tries to gc
        gcproc time.Duration  // Accumulates canonical block processing for trie dumping

        hc            *HeaderChain
        rmLogsFeed    event.Feed
        chainFeed     event.Feed
        chainSideFeed event.Feed
        chainHeadFeed event.Feed
        logsFeed      event.Feed
        scope         event.SubscriptionScope
        genesisBlock  *types.Block

        mu                          sync.RWMutex // global mutex for locking chain operations
        chainmu                     sync.RWMutex // blockchain insertion lock
        procmu                      sync.RWMutex // block processor lock
        pendingCrossLinksMutex      sync.RWMutex // pending crosslinks lock
        pendingSlashingCandidatesMU sync.RWMutex // pending slashing candidates

        currentBlock     atomic.Value // Current head of the block chain
        currentFastBlock atomic.Value // Current head of the fast-sync chain (may be above the block chain!)

        stateCache                    state.Database // State database to reuse between imports (contains state cache)
        bodyCache                     *lru.Cache     // Cache for the most recent block bodies
        bodyRLPCache                  *lru.Cache     // Cache for the most recent block bodies in RLP encoded format
        receiptsCache                 *lru.Cache     // Cache for the most recent receipts per block
        blockCache                    *lru.Cache     // Cache for the most recent entire blocks
        futureBlocks                  *lru.Cache     // future blocks are blocks added for later processing
        shardStateCache               *lru.Cache
        lastCommitsCache              *lru.Cache
        epochCache                    *lru.Cache    // Cache epoch number â†’ first block number
        randomnessCache               *lru.Cache    // Cache for vrf/vdf
        validatorSnapshotCache        *lru.Cache    // Cache for validator snapshot
        validatorStatsCache           *lru.Cache    // Cache for validator stats
        validatorListCache            *lru.Cache    // Cache of validator list
        validatorListByDelegatorCache *lru.Cache    // Cache of validator list by delegator
        pendingCrossLinksCache        *lru.Cache    // Cache of last pending crosslinks
        blockAccumulatorCache         *lru.Cache    // Cache of block accumulators
        quit                          chan struct{} // blockchain quit channel
        running                       int32         // running must be called atomically
        // procInterrupt must be atomically called
        procInterrupt int32          // interrupt signaler for block processing
        wg            sync.WaitGroup // chain processing wait group for shutting down

        engine                 consensus_engine.Engine
        processor              Processor // block processor interface
        validator              Validator // block and state validator interface
        vmConfig               vm.Config
        badBlocks              *lru.Cache              // Bad block cache
        shouldPreserve         func(*types.Block) bool // Function used to determine whether should preserve the given block.
        pendingSlashes         slash.Records
        maxGarbCollectedBlkNum int64
}

// NewBlockChain returns a fully initialised block chain using information
// available in the database. It initialises the default Ethereum validator and
// Processor.
func NewBlockChain(
        db ethdb.Database, cacheConfig *CacheConfig, chainConfig *params.ChainConfig,
        engine consensus_engine.Engine, vmConfig vm.Config,
        shouldPreserve func(block *types.Block) bool,
) (*BlockChain, error) <span class="cov8" title="1">{
        if cacheConfig == nil </span><span class="cov8" title="1">{
                cacheConfig = &amp;CacheConfig{
                        TrieNodeLimit: 256 * 1024 * 1024,
                        TrieTimeLimit: 2 * time.Minute,
                }
        }</span>
        <span class="cov8" title="1">bodyCache, _ := lru.New(bodyCacheLimit)
        bodyRLPCache, _ := lru.New(bodyCacheLimit)
        receiptsCache, _ := lru.New(receiptsCacheLimit)
        blockCache, _ := lru.New(blockCacheLimit)
        futureBlocks, _ := lru.New(maxFutureBlocks)
        badBlocks, _ := lru.New(badBlockLimit)
        shardCache, _ := lru.New(shardCacheLimit)
        commitsCache, _ := lru.New(commitsCacheLimit)
        epochCache, _ := lru.New(epochCacheLimit)
        randomnessCache, _ := lru.New(randomnessCacheLimit)
        validatorCache, _ := lru.New(validatorCacheLimit)
        validatorStatsCache, _ := lru.New(validatorStatsCacheLimit)
        validatorListCache, _ := lru.New(validatorListCacheLimit)
        validatorListByDelegatorCache, _ := lru.New(validatorListByDelegatorCacheLimit)
        pendingCrossLinksCache, _ := lru.New(pendingCrossLinksCacheLimit)
        blockAccumulatorCache, _ := lru.New(blockAccumulatorCacheLimit)

        bc := &amp;BlockChain{
                chainConfig:                   chainConfig,
                cacheConfig:                   cacheConfig,
                db:                            db,
                triegc:                        prque.New(nil),
                stateCache:                    state.NewDatabase(db),
                quit:                          make(chan struct{}),
                shouldPreserve:                shouldPreserve,
                bodyCache:                     bodyCache,
                bodyRLPCache:                  bodyRLPCache,
                receiptsCache:                 receiptsCache,
                blockCache:                    blockCache,
                futureBlocks:                  futureBlocks,
                shardStateCache:               shardCache,
                lastCommitsCache:              commitsCache,
                epochCache:                    epochCache,
                randomnessCache:               randomnessCache,
                validatorSnapshotCache:        validatorCache,
                validatorStatsCache:           validatorStatsCache,
                validatorListCache:            validatorListCache,
                validatorListByDelegatorCache: validatorListByDelegatorCache,
                pendingCrossLinksCache:        pendingCrossLinksCache,
                blockAccumulatorCache:         blockAccumulatorCache,
                engine:                        engine,
                vmConfig:                      vmConfig,
                badBlocks:                     badBlocks,
                pendingSlashes:                slash.Records{},
                maxGarbCollectedBlkNum:        -1,
        }
        bc.SetValidator(NewBlockValidator(chainConfig, bc, engine))
        bc.SetProcessor(NewStateProcessor(chainConfig, bc, engine))

        var err error
        bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">bc.genesisBlock = bc.GetBlockByNumber(0)
        if bc.genesisBlock == nil </span><span class="cov0" title="0">{
                return nil, ErrNoGenesis
        }</span>
        <span class="cov8" title="1">var nilBlock *types.Block
        bc.currentBlock.Store(nilBlock)
        bc.currentFastBlock.Store(nilBlock)
        if err := bc.loadLastState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Take ownership of this particular state
        <span class="cov8" title="1">go bc.update()
        return bc, nil</span>
}

// ValidateNewBlock validates new block.
func (bc *BlockChain) ValidateNewBlock(block *types.Block) error <span class="cov8" title="1">{
        state, err := state.New(bc.CurrentBlock().Root(), bc.stateCache)
        if err != nil {
                return err
</span>        }

</span>        // NOTE Order of mutating state here matters.
        // Process block using the parent state as reference point.
        // Do not read cache from processor.
        <span class="cov8" title="1">receipts, cxReceipts, _, _, usedGas, _, _, err := bc.processor.Process(
                block, state, bc.vmConfig, false,
        )
        if err != nil </span><span class="cov0" title="0">{
                bc.reportBlock(block, receipts, err)
                return err
        }</span>

        // Verify all the hash roots (state, txns, receipts, cross-shard)
        <span class="cov8" title="1">if err := bc.Validator().ValidateState(
                block, state, receipts, cxReceipts, usedGas,
        ); err != nil </span><span class="cov0" title="0">{
                bc.reportBlock(block, receipts, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsEpochBlock returns whether this block is the first block of an epoch.
// by checking if the previous block is the last block of the previous epoch
func IsEpochBlock(block *types.Block) bool <span class="cov8" title="1">{
        if block.NumberU64() == 0 </span><span class="cov8" title="1">{
                // genesis block is the first epoch block
                return true
        }</span>
        <span class="cov8" title="1">return shard.Schedule.IsLastBlock(block.NumberU64() - 1)</span>
}

func (bc *BlockChain) getProcInterrupt() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;bc.procInterrupt) == 1
}</span>

// loadLastState loads the last known chain state from the database. This method
// assumes that the chain manager mutex is held.
func (bc *BlockChain) loadLastState() error <span class="cov8" title="1">{
        // Restore the last known head block
        head := rawdb.ReadHeadBlockHash(bc.db)
        if head == (common.Hash{}) </span><span class="cov0" title="0">{
                // Corrupt or empty database, init from scratch
                utils.Logger().Warn().Msg("Empty database, resetting chain")
                return bc.Reset()
        }</span>
        // Make sure the entire head block is available
        <span class="cov8" title="1">currentBlock := bc.GetBlockByHash(head)
        if currentBlock == nil </span><span class="cov0" title="0">{
                // Corrupt or empty database, init from scratch
                utils.Logger().Warn().Str("hash", head.Hex()).Msg("Head block missing, resetting chain")
                return bc.Reset()
        }</span>
        // Make sure the state associated with the block is available
        <span class="cov8" title="1">if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil </span><span class="cov0" title="0">{
                // Dangling block without a state associated, init from scratch
                utils.Logger().Warn().
                        Str("number", currentBlock.Number().String()).
                        Str("hash", currentBlock.Hash().Hex()).
                        Msg("Head state missing, repairing chain")
                if err := bc.repair(&amp;currentBlock); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // Everything seems to be fine, set as the head block
        <span class="cov8" title="1">bc.currentBlock.Store(currentBlock)

        // We don't need the following as we want the current header and block to be consistent
        // Restore the last known head header
        //currentHeader := currentBlock.Header()
        //if head := rawdb.ReadHeadHeaderHash(bc.db); head != (common.Hash{}) {
        //        if header := bc.GetHeaderByHash(head); header != nil {
        //                currentHeader = header
        //        }
        //}
        currentHeader := currentBlock.Header()
        if err := bc.hc.SetCurrentHeader(currentHeader); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "headerChain SetCurrentHeader")
        }</span>

        // Restore the last known head fast block
        <span class="cov8" title="1">bc.currentFastBlock.Store(currentBlock)
        if head := rawdb.ReadHeadFastBlockHash(bc.db); head != (common.Hash{}) </span><span class="cov0" title="0">{
                if block := bc.GetBlockByHash(head); block != nil </span><span class="cov0" title="0">{
                        bc.currentFastBlock.Store(block)
                }</span>
        }

        // Issue a status log for the user
        <span class="cov8" title="1">currentFastBlock := bc.CurrentFastBlock()

        headerTd := bc.GetTd(currentHeader.Hash(), currentHeader.Number().Uint64())
        blockTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
        fastTd := bc.GetTd(currentFastBlock.Hash(), currentFastBlock.NumberU64())

        utils.Logger().Info().
                Str("number", currentHeader.Number().String()).
                Str("hash", currentHeader.Hash().Hex()).
                Str("td", headerTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentHeader.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local header")
        utils.Logger().Info().
                Str("number", currentBlock.Number().String()).
                Str("hash", currentBlock.Hash().Hex()).
                Str("td", blockTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentBlock.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local full block")
        utils.Logger().Info().
                Str("number", currentFastBlock.Number().String()).
                Str("hash", currentFastBlock.Hash().Hex()).
                Str("td", fastTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentFastBlock.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local fast block")

        return nil</span>
}

// SetHead rewinds the local chain to a new head. In the case of headers, everything
// above the new head will be deleted and the new one set. In the case of blocks
// though, the head may be further rewound if block bodies are missing (non-archive
// nodes after a fast sync).
func (bc *BlockChain) SetHead(head uint64) error <span class="cov0" title="0">{
        utils.Logger().Warn().Uint64("target", head).Msg("Rewinding blockchain")

        bc.mu.Lock()
        defer bc.mu.Unlock()

        // Rewind the header chain, deleting all block bodies until then
        delFn := func(db rawdb.DatabaseDeleter, hash common.Hash, num uint64) error </span><span class="cov0" title="0">{
                return rawdb.DeleteBody(db, hash, num)
        }</span>
        <span class="cov0" title="0">if err := bc.hc.SetHead(head, delFn); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "headerChain SetHeader")
        }</span>
        <span class="cov0" title="0">currentHeader := bc.hc.CurrentHeader()

        // Clear out any stale content from the caches
        bc.bodyCache.Purge()
        bc.bodyRLPCache.Purge()
        bc.receiptsCache.Purge()
        bc.blockCache.Purge()
        bc.futureBlocks.Purge()
        bc.shardStateCache.Purge()

        // Rewind the block chain, ensuring we don't end up with a stateless head block
        if currentBlock := bc.CurrentBlock(); currentBlock != nil &amp;&amp; currentHeader.Number().Uint64() &lt; currentBlock.NumberU64() </span><span class="cov0" title="0">{
                bc.currentBlock.Store(bc.GetBlock(currentHeader.Hash(), currentHeader.Number().Uint64()))
        }</span>
        <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock != nil </span><span class="cov0" title="0">{
                if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil </span><span class="cov0" title="0">{
                        // Rewound state missing, rolled back to before pivot, reset to genesis
                        bc.currentBlock.Store(bc.genesisBlock)
                }</span>
        }
        // Rewind the fast block in a simpleton way to the target head
        <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock != nil &amp;&amp; currentHeader.Number().Uint64() &lt; currentFastBlock.NumberU64() </span><span class="cov0" title="0">{
                bc.currentFastBlock.Store(bc.GetBlock(currentHeader.Hash(), currentHeader.Number().Uint64()))
        }</span>
        // If either blocks reached nil, reset to the genesis state
        <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock == nil </span><span class="cov0" title="0">{
                bc.currentBlock.Store(bc.genesisBlock)
        }</span>
        <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock == nil </span><span class="cov0" title="0">{
                bc.currentFastBlock.Store(bc.genesisBlock)
        }</span>
        <span class="cov0" title="0">currentBlock := bc.CurrentBlock()
        currentFastBlock := bc.CurrentFastBlock()

        if err := rawdb.WriteHeadBlockHash(bc.db, currentBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WriteHeadFastBlockHash(bc.db, currentFastBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return bc.loadLastState()</span>
}

// ShardID returns the shard Id of the blockchain.
// TODO: use a better solution before resharding shuffle nodes to different shards
func (bc *BlockChain) ShardID() uint32 <span class="cov8" title="1">{
        return bc.CurrentBlock().ShardID()
}</span>

// GasLimit returns the gas limit of the current HEAD block.
func (bc *BlockChain) GasLimit() uint64 <span class="cov0" title="0">{
        return bc.CurrentBlock().GasLimit()
}</span>

// CurrentBlock retrieves the current head block of the canonical chain. The
// block is retrieved from the blockchain's internal cache.
func (bc *BlockChain) CurrentBlock() *types.Block <span class="cov8" title="1">{
        return bc.currentBlock.Load().(*types.Block)
}</span>

// CurrentFastBlock retrieves the current fast-sync head block of the canonical
// chain. The block is retrieved from the blockchain's internal cache.
func (bc *BlockChain) CurrentFastBlock() *types.Block <span class="cov8" title="1">{
        return bc.currentFastBlock.Load().(*types.Block)
}</span>

// SetProcessor sets the processor required for making state modifications.
func (bc *BlockChain) SetProcessor(processor Processor) <span class="cov8" title="1">{
        bc.procmu.Lock()
        defer bc.procmu.Unlock()
        bc.processor = processor
}</span>

// SetValidator sets the validator which is used to validate incoming blocks.
func (bc *BlockChain) SetValidator(validator Validator) <span class="cov8" title="1">{
        bc.procmu.Lock()
        defer bc.procmu.Unlock()
        bc.validator = validator
}</span>

// Validator returns the current validator.
func (bc *BlockChain) Validator() Validator <span class="cov8" title="1">{
        bc.procmu.RLock()
        defer bc.procmu.RUnlock()
        return bc.validator
}</span>

// Processor returns the current processor.
func (bc *BlockChain) Processor() Processor <span class="cov0" title="0">{
        bc.procmu.RLock()
        defer bc.procmu.RUnlock()
        return bc.processor
}</span>

// State returns a new mutable state based on the current HEAD block.
func (bc *BlockChain) State() (*state.DB, error) <span class="cov0" title="0">{
        return bc.StateAt(bc.CurrentBlock().Root())
}</span>

// StateAt returns a new mutable state based on a particular point in time.
func (bc *BlockChain) StateAt(root common.Hash) (*state.DB, error) <span class="cov8" title="1">{
        return state.New(root, bc.stateCache)
}</span>

// Reset purges the entire blockchain, restoring it to its genesis state.
func (bc *BlockChain) Reset() error <span class="cov0" title="0">{
        return bc.ResetWithGenesisBlock(bc.genesisBlock)
}</span>

// ResetWithGenesisBlock purges the entire blockchain, restoring it to the
// specified genesis state.
func (bc *BlockChain) ResetWithGenesisBlock(genesis *types.Block) error <span class="cov0" title="0">{
        // Dump the entire block chain and purge the caches
        if err := bc.SetHead(0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.mu.Lock()
        defer bc.mu.Unlock()

        // Prepare the genesis block and reinitialise the chain
        if err := rawdb.WriteBlock(bc.db, genesis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bc.genesisBlock = genesis
        if err := bc.insert(bc.genesisBlock); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.hc.SetGenesis(bc.genesisBlock.Header())
        if err := bc.hc.SetCurrentHeader(bc.genesisBlock.Header()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.currentBlock.Store(bc.genesisBlock)
        bc.currentFastBlock.Store(bc.genesisBlock)

        return nil</span>
}

// repair tries to repair the current blockchain by rolling back the current block
// until one with associated state is found. This is needed to fix incomplete db
// writes caused either by crashes/power outages, or simply non-committed tries.
//
// This method only rolls back the current block. The current header and current
// fast block are left intact.
func (bc *BlockChain) repair(head **types.Block) error <span class="cov0" title="0">{
        valsToRemove := map[common.Address]struct{}{}
        for </span><span class="cov0" title="0">{
                // Abort if we've rewound to a head block that does have associated state
                if _, err := state.New((*head).Root(), bc.stateCache); err == nil </span><span class="cov0" title="0">{
                        utils.Logger().Info().
                                Str("number", (*head).Number().String()).
                                Str("hash", (*head).Hash().Hex()).
                                Msg("Rewound blockchain to past state")
                        return bc.removeInValidatorList(valsToRemove)
                }</span>
                // Repair last commit sigs
                <span class="cov0" title="0">lastSig := (*head).Header().LastCommitSignature()
                sigAndBitMap := append(lastSig[:], (*head).Header().LastCommitBitmap()...)
                bc.WriteCommitSig((*head).NumberU64()-1, sigAndBitMap)

                // Otherwise rewind one block and recheck state availability there
                for _, stkTxn := range (*head).StakingTransactions() </span><span class="cov0" title="0">{
                        if stkTxn.StakingType() == staking.DirectiveCreateValidator </span><span class="cov0" title="0">{
                                if addr, err := stkTxn.SenderAddress(); err == nil </span><span class="cov0" title="0">{
                                        valsToRemove[addr] = struct{}{}
                                }</span> else<span class="cov0" title="0"> {
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">block := bc.GetBlock((*head).ParentHash(), (*head).NumberU64()-1)
                if block == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing block %d [%x]", (*head).NumberU64()-1, (*head).ParentHash())
                }</span>
                <span class="cov0" title="0">*head = block</span>
        }
}

// This func is used to remove the validator addresses from the validator list.
func (bc *BlockChain) removeInValidatorList(toRemove map[common.Address]struct{}) error <span class="cov0" title="0">{
        if len(toRemove) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">utils.Logger().Info().
                Interface("validators", toRemove).
                Msg("Removing validators from validator list")

        existingVals, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">newVals := []common.Address{}
        for _, addr := range existingVals </span><span class="cov0" title="0">{
                if _, ok := toRemove[addr]; !ok </span><span class="cov0" title="0">{
                        newVals = append(newVals, addr)
                }</span>
        }
        <span class="cov0" title="0">return bc.WriteValidatorList(bc.db, newVals)</span>
}

// Export writes the active chain to the given writer.
func (bc *BlockChain) Export(w io.Writer) error <span class="cov0" title="0">{
        return bc.ExportN(w, uint64(0), bc.CurrentBlock().NumberU64())
}</span>

// ExportN writes a subset of the active chain to the given writer.
func (bc *BlockChain) ExportN(w io.Writer, first uint64, last uint64) error <span class="cov0" title="0">{
        bc.mu.RLock()
        defer bc.mu.RUnlock()

        if first &gt; last </span><span class="cov0" title="0">{
                return fmt.Errorf("export failed: first (%d) is greater than last (%d)", first, last)
        }</span>
        <span class="cov0" title="0">utils.Logger().Info().Uint64("count", last-first+1).Msg("Exporting batch of blocks")

        start, reported := time.Now(), time.Now()
        for nr := first; nr &lt;= last; nr++ </span><span class="cov0" title="0">{
                block := bc.GetBlockByNumber(nr)
                if block == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("export failed on #%d: not found", nr)
                }</span>
                <span class="cov0" title="0">if err := block.EncodeRLP(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if time.Since(reported) &gt;= statsReportLimit </span><span class="cov0" title="0">{
                        utils.Logger().Info().
                                Uint64("exported", block.NumberU64()-first).
                                Str("elapsed", common.PrettyDuration(time.Since(start)).String()).
                                Msg("Exporting blocks")
                        reported = time.Now()
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// writeHeadBlock writes a new head block
func (bc *BlockChain) writeHeadBlock(block *types.Block) error <span class="cov8" title="1">{
        // If the block is on a side chain or an unknown one, force other heads onto it too
        updateHeads := rawdb.ReadCanonicalHash(bc.db, block.NumberU64()) != block.Hash()

        // Add the block to the canonical chain number scheme and mark as the head
        batch := bc.ChainDb().NewBatch()
        if err := rawdb.WriteCanonicalHash(batch, block.Hash(), block.NumberU64()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WriteHeadBlockHash(batch, block.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bc.currentBlock.Store(block)

        // If the block is better than our head or is on a different chain, force update heads
        if updateHeads </span><span class="cov8" title="1">{
                if err := bc.hc.SetCurrentHeader(block.Header()); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "HeaderChain SetCurrentHeader")
                }</span>
                <span class="cov8" title="1">if err := rawdb.WriteHeadFastBlockHash(bc.db, block.Hash()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">bc.currentFastBlock.Store(block)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// insert injects a new head block into the current block chain. This method
// assumes that the block is indeed a true head. It will also reset the head
// header and the head fast sync block to this very same block if they are older
// or if they are on a different side chain.
//
// Note, this function assumes that the `mu` mutex is held!
func (bc *BlockChain) insert(block *types.Block) error <span class="cov0" title="0">{
        return bc.writeHeadBlock(block)
}</span>

// Genesis retrieves the chain's genesis block.
func (bc *BlockChain) Genesis() *types.Block <span class="cov0" title="0">{
        return bc.genesisBlock
}</span>

// GetBody retrieves a block body (transactions and uncles) from the database by
// hash, caching it if found.
func (bc *BlockChain) GetBody(hash common.Hash) *types.Body <span class="cov0" title="0">{
        // Short circuit if the body's already in the cache, retrieve otherwise
        if cached, ok := bc.bodyCache.Get(hash); ok </span><span class="cov0" title="0">{
                body := cached.(*types.Body)
                return body
        }</span>
        <span class="cov0" title="0">number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">body := rawdb.ReadBody(bc.db, hash, *number)
        if body == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Cache the found body for next time and return
        <span class="cov0" title="0">bc.bodyCache.Add(hash, body)
        return body</span>
}

// GetBodyRLP retrieves a block body in RLP encoding from the database by hash,
// caching it if found.
func (bc *BlockChain) GetBodyRLP(hash common.Hash) rlp.RawValue <span class="cov0" title="0">{
        // Short circuit if the body's already in the cache, retrieve otherwise
        if cached, ok := bc.bodyRLPCache.Get(hash); ok </span><span class="cov0" title="0">{
                return cached.(rlp.RawValue)
        }</span>
        <span class="cov0" title="0">number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">body := rawdb.ReadBodyRLP(bc.db, hash, *number)
        if len(body) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Cache the found body for next time and return
        <span class="cov0" title="0">bc.bodyRLPCache.Add(hash, body)
        return body</span>
}

// HasBlock checks if a block is fully present in the database or not.
func (bc *BlockChain) HasBlock(hash common.Hash, number uint64) bool <span class="cov0" title="0">{
        if bc.blockCache.Contains(hash) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return rawdb.HasBody(bc.db, hash, number)</span>
}

// HasState checks if state trie is fully present in the database or not.
func (bc *BlockChain) HasState(hash common.Hash) bool <span class="cov8" title="1">{
        _, err := bc.stateCache.OpenTrie(hash)
        return err == nil
}</span>

// HasBlockAndState checks if a block and associated state trie is fully present
// in the database or not, caching it if present.
func (bc *BlockChain) HasBlockAndState(hash common.Hash, number uint64) bool <span class="cov8" title="1">{
        // Check first that the block itself is known
        block := bc.GetBlock(hash, number)
        if block == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return bc.HasState(block.Root())</span>
}

// GetBlock retrieves a block from the database by hash and number,
// caching it if found.
func (bc *BlockChain) GetBlock(hash common.Hash, number uint64) *types.Block <span class="cov8" title="1">{
        // Short circuit if the block's already in the cache, retrieve otherwise
        if block, ok := bc.blockCache.Get(hash); ok </span><span class="cov8" title="1">{
                return block.(*types.Block)
        }</span>
        <span class="cov8" title="1">block := rawdb.ReadBlock(bc.db, hash, number)
        if block == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Cache the found block for next time and return
        <span class="cov8" title="1">bc.blockCache.Add(block.Hash(), block)
        return block</span>
}

// GetBlockByHash retrieves a block from the database by hash, caching it if found.
func (bc *BlockChain) GetBlockByHash(hash common.Hash) *types.Block <span class="cov8" title="1">{
        number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return bc.GetBlock(hash, *number)</span>
}

// GetBlockByNumber retrieves a block from the database by number, caching it
// (associated with its hash) if found.
func (bc *BlockChain) GetBlockByNumber(number uint64) *types.Block <span class="cov8" title="1">{
        hash := rawdb.ReadCanonicalHash(bc.db, number)
        if hash == (common.Hash{}) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return bc.GetBlock(hash, number)</span>
}

// GetReceiptsByHash retrieves the receipts for all transactions in a given block.
func (bc *BlockChain) GetReceiptsByHash(hash common.Hash) types.Receipts <span class="cov0" title="0">{
        if receipts, ok := bc.receiptsCache.Get(hash); ok </span><span class="cov0" title="0">{
                return receipts.(types.Receipts)
        }</span>

        <span class="cov0" title="0">number := rawdb.ReadHeaderNumber(bc.db, hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">receipts := rawdb.ReadReceipts(bc.db, hash, *number)
        bc.receiptsCache.Add(hash, receipts)
        return receipts</span>
}

// GetBlocksFromHash returns the block corresponding to hash and up to n-1 ancestors.
// [deprecated by eth/62]
func (bc *BlockChain) GetBlocksFromHash(hash common.Hash, n int) (blocks []*types.Block) <span class="cov0" title="0">{
        number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                block := bc.GetBlock(hash, *number)
                if block == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">blocks = append(blocks, block)
                hash = block.ParentHash()
                *number--</span>
        }
        <span class="cov0" title="0">return</span>
}

// GetUnclesInChain retrieves all the uncles from a given block backwards until
// a specific distance is reached.
func (bc *BlockChain) GetUnclesInChain(b *types.Block, length int) []*block.Header <span class="cov0" title="0">{
        uncles := []*block.Header{}
        for i := 0; b != nil &amp;&amp; i &lt; length; i++ </span><span class="cov0" title="0">{
                uncles = append(uncles, b.Uncles()...)
                b = bc.GetBlock(b.ParentHash(), b.NumberU64()-1)
        }</span>
        <span class="cov0" title="0">return uncles</span>
}

// TrieNode retrieves a blob of data associated with a trie node (or code hash)
// either from ephemeral in-memory cache, or from persistent storage.
func (bc *BlockChain) TrieNode(hash common.Hash) ([]byte, error) <span class="cov0" title="0">{
        return bc.stateCache.TrieDB().Node(hash)
}</span>

// Stop stops the blockchain service. If any imports are currently in progress
// it will abort them using the procInterrupt.
func (bc *BlockChain) Stop() <span class="cov0" title="0">{
        if !atomic.CompareAndSwapInt32(&amp;bc.running, 0, 1) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := bc.SavePendingCrossLinks(); err != nil </span><span class="cov0" title="0">{
                utils.Logger().Error().Err(err).Msg("Failed to save pending cross links")
        }</span>

        // Unsubscribe all subscriptions registered from blockchain
        <span class="cov0" title="0">bc.scope.Close()
        close(bc.quit)
        atomic.StoreInt32(&amp;bc.procInterrupt, 1)

        bc.wg.Wait()

        // Ensure the state of a recent block is also stored to disk before exiting.
        // We're writing three different states to catch different restart scenarios:
        //  - HEAD:     So we don't need to reprocess any blocks in the general case
        //  - HEAD-1:   So we don't do large reorgs if our HEAD becomes an uncle
        //  - HEAD-127: So we have a hard limit on the number of blocks reexecuted
        if !bc.cacheConfig.Disabled </span><span class="cov0" title="0">{
                triedb := bc.stateCache.TrieDB()

                for _, offset := range []uint64{0, 1, triesInMemory - 1} </span><span class="cov0" title="0">{
                        if number := bc.CurrentBlock().NumberU64(); number &gt; offset </span><span class="cov0" title="0">{
                                recent := bc.GetHeaderByNumber(number - offset)
                                if recent != nil </span><span class="cov0" title="0">{
                                        utils.Logger().Info().
                                                Str("block", recent.Number().String()).
                                                Str("hash", recent.Hash().Hex()).
                                                Str("root", recent.Root().Hex()).
                                                Msg("Writing cached state to disk")
                                        if err := triedb.Commit(recent.Root(), true); err != nil </span><span class="cov0" title="0">{
                                                utils.Logger().Error().Err(err).Msg("Failed to commit recent state trie")
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">for !bc.triegc.Empty() </span><span class="cov0" title="0">{
                        triedb.Dereference(bc.triegc.PopItem().(common.Hash))
                }</span>
                <span class="cov0" title="0">if size, _ := triedb.Size(); size != 0 </span><span class="cov0" title="0">{
                        utils.Logger().Error().Msg("Dangling trie nodes after full cleanup")
                }</span>
        }
        <span class="cov0" title="0">utils.Logger().Info().Msg("Blockchain manager stopped")</span>
}

func (bc *BlockChain) procFutureBlocks() <span class="cov8" title="1">{
        blocks := make([]*types.Block, 0, bc.futureBlocks.Len())
        for _, hash := range bc.futureBlocks.Keys() </span><span class="cov0" title="0">{
                if block, exist := bc.futureBlocks.Peek(hash); exist </span><span class="cov0" title="0">{
                        blocks = append(blocks, block.(*types.Block))
                }</span>
        }
        <span class="cov8" title="1">if len(blocks) &gt; 0 </span><span class="cov0" title="0">{
                types.BlockBy(types.Number).Sort(blocks)

                // Insert one by one as chain insertion needs contiguous ancestry between blocks
                for i := range blocks </span><span class="cov0" title="0">{
                        bc.InsertChain(blocks[i:i+1], true /* verifyHeaders */)
                }</span>
        }
}

// WriteStatus status of write
type WriteStatus byte

// Constants for WriteStatus
const (
        NonStatTy WriteStatus = iota
        CanonStatTy
        SideStatTy
)

// Rollback is designed to remove a chain of links from the database that aren't
// certain enough to be valid.
func (bc *BlockChain) Rollback(chain []common.Hash) error <span class="cov0" title="0">{
        bc.mu.Lock()
        defer bc.mu.Unlock()

        valsToRemove := map[common.Address]struct{}{}
        for i := len(chain) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                hash := chain[i]

                currentHeader := bc.hc.CurrentHeader()
                if currentHeader != nil &amp;&amp; currentHeader.Hash() == hash </span><span class="cov0" title="0">{
                        parentHeader := bc.GetHeader(currentHeader.ParentHash(), currentHeader.Number().Uint64()-1)
                        if parentHeader != nil </span><span class="cov0" title="0">{
                                if err := bc.hc.SetCurrentHeader(parentHeader); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "HeaderChain SetCurrentHeader")
                                }</span>
                        }
                }
                <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock != nil &amp;&amp; currentFastBlock.Hash() == hash </span><span class="cov0" title="0">{
                        newFastBlock := bc.GetBlock(currentFastBlock.ParentHash(), currentFastBlock.NumberU64()-1)
                        if newFastBlock != nil </span><span class="cov0" title="0">{
                                bc.currentFastBlock.Store(newFastBlock)
                                rawdb.WriteHeadFastBlockHash(bc.db, newFastBlock.Hash())
                        }</span>
                }
                <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock != nil &amp;&amp; currentBlock.Hash() == hash </span><span class="cov0" title="0">{
                        newBlock := bc.GetBlock(currentBlock.ParentHash(), currentBlock.NumberU64()-1)
                        if newBlock != nil </span><span class="cov0" title="0">{
                                bc.currentBlock.Store(newBlock)
                                if err := rawdb.WriteHeadBlockHash(bc.db, newBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">for _, stkTxn := range currentBlock.StakingTransactions() </span><span class="cov0" title="0">{
                                        if stkTxn.StakingType() == staking.DirectiveCreateValidator </span><span class="cov0" title="0">{
                                                if addr, err := stkTxn.SenderAddress(); err == nil </span><span class="cov0" title="0">{
                                                        valsToRemove[addr] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">return bc.removeInValidatorList(valsToRemove)</span>
}

// SetReceiptsData computes all the non-consensus fields of the receipts
func SetReceiptsData(config *params.ChainConfig, block *types.Block, receipts types.Receipts) error <span class="cov0" title="0">{
        signer := types.MakeSigner(config, block.Epoch())
        ethSigner := types.NewEIP155Signer(config.EthCompatibleChainID)

        transactions, stakingTransactions, logIndex := block.Transactions(), block.StakingTransactions(), uint(0)
        if len(transactions)+len(stakingTransactions) != len(receipts) </span><span class="cov0" title="0">{
                return errors.New("transaction+stakingTransactions and receipt count mismatch")
        }</span>

        // The used gas can be calculated based on previous receipts
        <span class="cov0" title="0">if len(receipts) &gt; 0 &amp;&amp; len(transactions) &gt; 0 </span><span class="cov0" title="0">{
                receipts[0].GasUsed = receipts[0].CumulativeGasUsed
        }</span>
        <span class="cov0" title="0">for j := 1; j &lt; len(transactions); j++ </span><span class="cov0" title="0">{
                // The transaction hash can be retrieved from the transaction itself
                receipts[j].TxHash = transactions[j].Hash()
                receipts[j].GasUsed = receipts[j].CumulativeGasUsed - receipts[j-1].CumulativeGasUsed
                // The contract address can be derived from the transaction itself
                if transactions[j].To() == nil </span><span class="cov0" title="0">{
                        // Deriving the signer is expensive, only do if it's actually needed
                        var from common.Address
                        if transactions[j].IsEthCompatible() </span><span class="cov0" title="0">{
                                from, _ = types.Sender(ethSigner, transactions[j])
                        }</span> else<span class="cov0" title="0"> {
                                from, _ = types.Sender(signer, transactions[j])
                        }</span>
                        <span class="cov0" title="0">receipts[j].ContractAddress = crypto.CreateAddress(from, transactions[j].Nonce())</span>
                }
                // The derived log fields can simply be set from the block and transaction
                <span class="cov0" title="0">for k := 0; k &lt; len(receipts[j].Logs); k++ </span><span class="cov0" title="0">{
                        receipts[j].Logs[k].BlockNumber = block.NumberU64()
                        receipts[j].Logs[k].BlockHash = block.Hash()
                        receipts[j].Logs[k].TxHash = receipts[j].TxHash
                        receipts[j].Logs[k].TxIndex = uint(j)
                        receipts[j].Logs[k].Index = logIndex
                        logIndex++
                }</span>
        }

        // The used gas can be calculated based on previous receipts
        <span class="cov0" title="0">if len(receipts) &gt; len(transactions) &amp;&amp; len(stakingTransactions) &gt; 0 </span><span class="cov0" title="0">{
                receipts[len(transactions)].GasUsed = receipts[len(transactions)].CumulativeGasUsed
        }</span>
        // in a block, txns are processed before staking txns
        <span class="cov0" title="0">for j := len(transactions) + 1; j &lt; len(transactions)+len(stakingTransactions); j++ </span><span class="cov0" title="0">{
                // The transaction hash can be retrieved from the staking transaction itself
                receipts[j].TxHash = stakingTransactions[j].Hash()
                receipts[j].GasUsed = receipts[j].CumulativeGasUsed - receipts[j-1].CumulativeGasUsed
                // The derived log fields can simply be set from the block and transaction
                for k := 0; k &lt; len(receipts[j].Logs); k++ </span><span class="cov0" title="0">{
                        receipts[j].Logs[k].BlockNumber = block.NumberU64()
                        receipts[j].Logs[k].BlockHash = block.Hash()
                        receipts[j].Logs[k].TxHash = receipts[j].TxHash
                        receipts[j].Logs[k].TxIndex = uint(j) + uint(len(transactions))
                        receipts[j].Logs[k].Index = logIndex
                        logIndex++
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// InsertReceiptChain attempts to complete an already existing header chain with
// transaction and receipt data.
func (bc *BlockChain) InsertReceiptChain(blockChain types.Blocks, receiptChain []types.Receipts) (int, error) <span class="cov0" title="0">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        // Do a sanity check that the provided chain is actually ordered and linked
        for i := 1; i &lt; len(blockChain); i++ </span><span class="cov0" title="0">{
                if blockChain[i].NumberU64() != blockChain[i-1].NumberU64()+1 || blockChain[i].ParentHash() != blockChain[i-1].Hash() </span><span class="cov0" title="0">{
                        utils.Logger().Error().
                                Str("number", blockChain[i].Number().String()).
                                Str("hash", blockChain[i].Hash().Hex()).
                                Str("parent", blockChain[i].ParentHash().Hex()).
                                Str("prevnumber", blockChain[i-1].Number().String()).
                                Str("prevhash", blockChain[i-1].Hash().Hex()).
                                Msg("Non contiguous receipt insert")
                        return 0, fmt.Errorf("non contiguous insert: item %d is #%d [%xâ€¦], item %d is #%d [%xâ€¦] (parent [%xâ€¦])", i-1, blockChain[i-1].NumberU64(),
                                blockChain[i-1].Hash().Bytes()[:4], i, blockChain[i].NumberU64(), blockChain[i].Hash().Bytes()[:4], blockChain[i].ParentHash().Bytes()[:4])
                }</span>
        }

        <span class="cov0" title="0">var (
                stats = struct{ processed, ignored int32 }{}
                start = time.Now()
                bytes = 0
                batch = bc.db.NewBatch()
        )
        for i, block := range blockChain </span><span class="cov0" title="0">{
                receipts := receiptChain[i]
                // Short circuit insertion if shutting down or processing failed
                if atomic.LoadInt32(&amp;bc.procInterrupt) == 1 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                // Short circuit if the owner header is unknown
                <span class="cov0" title="0">if !bc.HasHeader(block.Hash(), block.NumberU64()) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("containing header #%d [%xâ€¦] unknown", block.Number(), block.Hash().Bytes()[:4])
                }</span>
                // Skip if the entire data is already known
                <span class="cov0" title="0">if bc.HasBlock(block.Hash(), block.NumberU64()) </span><span class="cov0" title="0">{
                        stats.ignored++
                        continue</span>
                }
                // Compute all the non-consensus fields of the receipts
                <span class="cov0" title="0">if err := SetReceiptsData(bc.chainConfig, block, receipts); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to set receipts data: %v", err)
                }</span>
                // Write all the data out into the database
                <span class="cov0" title="0">if err := rawdb.WriteBody(batch, block.Hash(), block.NumberU64(), block.Body()); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteReceipts(batch, block.Hash(), block.NumberU64(), receipts); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteBlockTxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteBlockStxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">stats.processed++

                if batch.ValueSize() &gt;= ethdb.IdealBatchSize </span><span class="cov0" title="0">{
                        if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">bytes += batch.ValueSize()
                        batch.Reset()</span>
                }
        }
        <span class="cov0" title="0">if batch.ValueSize() &gt; 0 </span><span class="cov0" title="0">{
                bytes += batch.ValueSize()
                if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        // Update the head fast sync block if better
        <span class="cov0" title="0">bc.mu.Lock()
        head := blockChain[len(blockChain)-1]
        if td := bc.GetTd(head.Hash(), head.NumberU64()); td != nil </span><span class="cov0" title="0">{ // Rewind may have occurred, skip in that case
                currentFastBlock := bc.CurrentFastBlock()
                if bc.GetTd(currentFastBlock.Hash(), currentFastBlock.NumberU64()).Cmp(td) &lt; 0 </span><span class="cov0" title="0">{
                        rawdb.WriteHeadFastBlockHash(bc.db, head.Hash())
                        bc.currentFastBlock.Store(head)
                }</span>
        }
        <span class="cov0" title="0">bc.mu.Unlock()

        utils.Logger().Info().
                Int32("count", stats.processed).
                Str("elapsed", common.PrettyDuration(time.Since(start)).String()).
                Str("age", common.PrettyAge(time.Unix(head.Time().Int64(), 0)).String()).
                Str("head", head.Number().String()).
                Str("hash", head.Hash().Hex()).
                Str("size", common.StorageSize(bytes).String()).
                Int32("ignored", stats.ignored).
                Msg("Imported new block receipts")

        return 0, nil</span>
}

var lastWrite uint64

// WriteBlockWithoutState writes only the block and its metadata to the database,
// but does not write any state. This is used to construct competing side forks
// up to the point where they exceed the canonical total difficulty.
func (bc *BlockChain) WriteBlockWithoutState(block *types.Block, td *big.Int) (err error) <span class="cov0" title="0">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        if err := bc.hc.WriteTd(block.Hash(), block.NumberU64(), td); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WriteBlock(bc.db, block); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WriteBlockWithState writes the block and all associated state to the database.
func (bc *BlockChain) WriteBlockWithState(
        block *types.Block, receipts []*types.Receipt,
        cxReceipts []*types.CXReceipt,
        stakeMsgs []staking.StakeMsg,
        paid reward.Reader,
        state *state.DB,
) (status WriteStatus, err error) {
        bc.wg.Add(1)
        defer bc.wg.Done()

        // Make sure no inconsistent state is leaked during insertion
        bc.mu.Lock()
        defer bc.mu.Unlock()

        currentBlock := bc.CurrentBlock()
</span>        if currentBlock == nil || block.ParentHash() != currentBlock.Hash() {
                </span>return NonStatTy, errors.New("Hash of parent block doesn't match the current block hash")
        }

        <span class="cov8" title="1">// Commit state object changes to in-memory trie
        root, err := s</span><span class="cov0" title="0">tate.Commit(bc.chainConfig.IsS3(block.Epoch()))
        if err != nil {
                </span>return NonStatTy, err
        }

        <span class="cov8" title="1">// Flush trie state into disk if it's archival node or the block is epoch block
        triedb := bc.stateCache.TrieDB()
</span>        if bc.cacheConfig.Disabled || block.IsLastBlockInE</span><span class="cov0" title="0">poch() {
                if err := triedb.Commit(root</span><span class="cov0" title="0">, false); err != nil {
                        if isUnrecoverableErr(err) {
                                fmt.Printf("Unrecoverable error when committing triedb: %v\nExitting\n", err)
                                </span>os.Exit(1)
                        <span class="cov0" title="0">}
</span>                        return NonStatTy, err
                }
        } else {
                // Full but not archive node, do proper garbage collection
                triedb.Reference(root, common.Hash{}) // metadata reference to keep trie alive
                bc.triegc.Push(root, -int64(block.NumberU64()))

</span>                if current := block.NumberU64(); current &gt; triesInMemory {
                        // If we exceeded our memory allowance, flush matured singleton nodes to disk
                        var (
                                nodes, imgs = triedb.Size()
                                limit       = common.StorageSize(bc.cacheConfig.TrieNodeLimit) * 1024 * 1024
                        )
</span>                        if nodes &gt; limit || imgs &gt; 4*1024*1024 {
                                </span>triedb.Cap(limit - ethdb.IdealBatchSize)
                        }
                        <span class="cov0" title="0">// Find the next state trie we need to commit
                        header := bc.GetH</span><span class="cov0" title="0">eaderByNumber(current - triesInMemory)
                        if header != nil {
                                chosen := header.Number().Uint64()

                                // If we exceeded out time allowance, flush </span><span class="cov0" title="0">an entire trie to disk
                                if bc.gcproc &gt; bc.cacheConfig.TrieTimeLimit {
                                        // If we're exceeding limits but haven't reached a large enough memory gap,
                                        // warn the user that the system is becoming unstable.
</span>                                        if chosen &lt; lastWrite+triesInMemory &amp;&amp; bc.gcproc &gt;= 2*bc.cacheConfig.TrieTimeLimit {
                                                utils.Logger().Info().
                                                        Dur("time", bc.gcproc).
                                                        Dur("allowance", bc.cacheConfig.TrieTimeLimit).
                                                        Float64("optimum", float64(chosen-lastWrite)/triesInMemory).
                                                </span>        Msg("State in memory for too long, committing")
                                        }
                                        <span class="cov0" title="0">// Flush an entire trie and restart the counters
                                        triedb.Commit(header.Root(), true)
                                        lastWrite = c</span>hosen
                                        bc.gcproc = 0
                                }
                                <span class="cov0" title="0">// Garbage collect anyt</span><span class="cov0" title="0">hing below our required write retention
                                for !bc.triegc.Empty() {
                                        root, number := bc.triegc.Po</span><span class="cov0" title="0">p()
                                        if uint64(-number) &gt; chosen {
                                                bc.tr</span>iegc.Push(root, number)
                                                break
                                        <span class="cov0" title="0">}
</span>                                        if -number &gt; bc.maxGarbCollectedBlkNum {
                                                </span>bc.maxGarbCollectedBlkNum = -number
                                        <span class="cov0" title="0">}
</span>                                        triedb.Dereference(root.(common.Hash))
                                }
                        }
                }
        }

        batch := bc.db.NewBatch()
        // Write the raw block
</span>        if err := rawdb.WriteBlock(batch, block); err != nil {
                </span>return NonStatTy, err
        }

        <span class="cov8" title="1">// Write offchain data
        if status, err := bc.CommitOffChainData(
                batch, block, receipts,
                cxReceipts, s</span><span class="cov0" title="0">takeMsgs,
                paid, state,
        )</span>; err != nil {
                return status, err
        }

</span>        // Write the positional metadata for transaction/receipt lookups and preimages
        i</span>f err := rawdb.WriteBlockTxLookUpEntries(batch, block); err != nil {
        <span class="cov8" title="1">        return NonStatTy, err
</span>        }
        i</span>f err := rawdb.WriteBlockStxLookUpEntries(batch, block); err != nil {
        <span class="cov8" title="1">        return NonStatTy, err
</span>        }
        i</span>f err := rawdb.WriteCxLookupEntries(batch, block); err != nil {
        <span class="cov8" title="1">        return NonStatTy, err
</span>        }
        i</span>f err := rawdb.WritePreimages(batch, block.NumberU64(), state.Preimages()); err != nil {
                return NonStatTy, err
        <span class="cov8" title="1">}
</span>
</span>        if err := batch.Write(); err != nil {
                if isUnrecoverableErr(err) {
                        </span>fmt.Printf("Unrecoverable error when writing leveldb: %v\nExitting\n", err)
                <span class="cov0" title="0">        os.Exit(1)
</span>                }
                return NonStatTy, err
        }

</span>        // Update current block
        i</span>f err := bc.writeHeadBlock(block); err != nil {
                return NonStatTy, errors.Wrap(err, "writeHeadBlock")
        <span class="cov8" title="1">}

</span>        bc.futureBlocks.Remove(block.Hash())
        return CanonStatTy, nil
}

// GetMaxGarbageCollectedBlockNumber ..
f</span>unc (bc *BlockChain) GetMaxGarbageCollectedBlockNumber() int64 {
        return bc.maxGarbCollectedBlkNum
}

// InsertChain attempts to insert the given batch of blocks in to the canonical
// chain or, otherwise, create a fork. If an error is returned it will return
// the index number of the failing block as well an error describing what went
// wrong.
//
// After insertion is done, all accumulated events will be fired.
func (bc *BlockChain) InsertChain(chain types.Blocks, verifyHeaders bool) (int, error) {
        n, events, logs, err := bc.insertChain(chain, verifyHeaders)
        </span>bc.PostChainEvents(events, logs)
        return n, err
}

// insertChain will execute the actual chain insertion and event aggregation. The
// only reason this method exists as a separate one is to make locking cleaner
// with deferred statements.
func (bc *BlockChain</span><span class="cov0" title="0">) insertChain(chain types.Blocks, verifyHeaders bool) (int, []interface{}, []*types.Log, error) {
        // Sanity check that we have something meaningful to import
        i</span>f len(chain) == 0 {
                return 0, nil, nil, nil
        <span class="cov8" title="1">}
</span>        // Do a sanity check that the provided chain is actually ordered and linked
</span>        for i := 1; i &lt; len(chain); i++ {
                if chain[i].NumberU64() != chain[i-1].NumberU64()+1 || chain[i].ParentHash() != chain[i-1].Hash() {
                        // Chain broke ancestry, log a message (programming error) and skip insertion
                        utils.Logger().Error().
                                Str("number", chain[i].Number().String()).
                                Str("hash", chain[i].Hash().Hex()).
                                Str("parent", chain[i].ParentHash().Hex()).
                                Str("prevnumber", chain[i-1].Number().String()).
                                Str("prevhash", chain[i-1].Hash().Hex()).
                                Msg("insertChain: non contiguous block insert")

                        </span>return 0, nil, nil, fmt.Errorf("non contiguous insert: item %d is #%d [%xâ€¦], item %d is #%d [%xâ€¦] (parent [%xâ€¦])", i-1, chain[i-1].NumberU64(),
                                chain[i-1].Hash().Bytes()[:4], i, chain[i].NumberU64(), chain[i].Hash().Bytes()[:4], chain[i].ParentHash().Bytes()[:4])
                }
        <span class="cov8" title="1">}
        // Pre-checks passed, start the full block imports
        bc.wg.Add(1)
        defer bc.wg.Done()

        bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        // A queued approach to delivering events. This is generally
        // faster than direct delivery and requires much less mutex
        // acquiring.
        var (
                stats         = insertStats{startTime: mclock.Now()}
                events        = make([]interface{}, 0, len(chain))
                lastCanon     *types.Block
                coalescedLogs []*types.Log
        )

        var verifyHeadersResults &lt;-chan error

</span>        // If the block header chain has not been verified, conduct header verification here.
        if verifyHeaders {
                headers := make([]*block.Header, len(chain))
                seals := make([]bool, len(ch</span><span class="cov8" title="1">ain))

                for i, block := range chain {
                        </span>headers[i] = block.Header()
                        seals[i] = true
                <span class="cov8" title="1">}
                // Note that VerifyHeaders verifies headers in the chain in parallel
                abort, results := </span>bc.Engine().VerifyHeaders(bc, headers, seals)
                verifyHeadersResults = results
                defer close(abort)
        }

        // Start a parallel signature recovery (signer will fluke on fork transition, minimal perf loss)
        //senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[0].Number()), chain)

</span>        // Iterate over the blocks and insert when the verifier permits
        for i, block := range chain {
</span>                // If the chain is terminating, stop processing blocks
                if ato</span>mic.LoadInt32(&amp;bc.procInterrupt) == 1 {
                        utils.Logger().Debug().Msg("Premature abort during blocks processing")
                        break
                <span class="cov8" title="1">}
                // Wait for the block's verification to complete
                bstart := time.Now()

</span>                var err error
                i</span>f verifyHeaders {
                <span class="cov8" title="1">        err = &lt;-verif</span><span class="cov8" title="1">yHeadersResults
                }
                i</span>f err == nil {
                <span class="cov8" title="1">        err = </span>bc.Validator().ValidateBody(block)
                }
                switch {
                case err == ErrKnownBlock:
                        // Block and state both already known. However if the </span><span class="cov0" title="0">current block is below
                        // this number we did a rollback and we should reimport it nonetheless.
                        if bc.Cur</span>rentBlock().NumberU64() &gt;= block.NumberU64() {
                                stats.ignored++
                                continue
                        }

                case err == consensus_engine.ErrFutureBlock:
                        // Allow up to MaxFuture second in the future blocks. If this limit is exceeded
                        // the chain is discarded and</span><span class="cov0" title="0"> processed at a later time if given.
                        max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)
                        i</span>f block.Time().Cmp(max) &gt; 0 {
                        <span class="cov0" title="0">        return i, events, coalescedLogs, fmt.Errorf("future block: %v &gt; %v", block.Time(), max)
                        }
                        bc.futur</span>eBlocks.Add(block.Hash(), block)
                        stats.queued++
                        continue

                case err == consensus_engine.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()):
                        bc.futur</span>eBlocks.Add(block.Hash(), block)
                        stats.queued++
                        continue

                case err == consensus_engine.ErrPrunedAncestor:
                        // TODO: add fork choice mechanism
                        // Block competing with the canonical chain, store in the db, but don't process
                        // until the competitor TD goes above the canonical TD
                        //currentBlock := bc.CurrentBlock()
                        //localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
                        //externTd := new(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()-1), block.Difficulty())
                        //if localTd.Cmp(externTd) &gt; 0 {
                        //        if err = bc.WriteBlockWithoutState(block, externTd); err != nil {
                        //                return i, events, coalescedLogs, err
                        //        }
                        //        continue
                        //}
                        // Competitor chain beat canonical, gather all blocks from the common ancestor
                        var winner []*types.Block

</span>                        parent := bc.GetBlock(block.ParentHash(), block.NumberU64()-1)
                        for parent != nil &amp;&amp; !bc.HasState(parent.Root()) {
                                </span>winner = append(winner, parent)
                        <span class="cov0" title="0">        parent = bc.GetBlock(parent.Parent</span><span class="cov0" title="0">Hash(), parent.NumberU64()-1)
                        }
                        f</span>or j := 0; j &lt; len(winner)/2; j++ {
                                winner[j], winner[len(winner)-1-j] = winner[len(winner)-1-j], winner[j]
                        <span class="cov0" title="0">}
</span>                        // Prune in case non-empty winner chain
                        if len(winner) &gt; 0 {
                                // Import all the pruned blocks to make the state available
                                bc.chainmu.Unlock()
                                _, evs, logs, err := bc.insertChain(winner, true /* verifyHeaders */)
                                bc.chainmu.Lock()
                                events, coales</span><span class="cov0" title="0">cedLogs = evs, logs

                                i</span>f err != nil {
                                        return i, events, coalescedLogs, err
                                }
                        }

                case err != nil:
</span>                        bc.reportBlock(block, nil, err)
                        return i, events, coalescedLogs, err
                }

                <span class="cov8" title="1">// Create a new statedb using the parent block and report an
                // error i</span><span class="cov8" title="1">f it fails.
                var parent *types.Block
                i</span>f i =<span class="cov0" title="0">= 0 {
                        parent = bc.GetBlock(block.ParentHash(), block.NumberU64()-1)
                }</span> else {
                <span class="cov8" title="1">        parent = chain[i-1]
                }
</span>                state, err := state.New(parent.Root(), bc.stateCache)
                i</span>f err != nil {
                        return i, events, coalescedLogs, err
                }

                // Process block using the parent state as reference point.
                receipts, cxReceipts, stakeMsgs, logs, usedGas, payout, newState, err := bc.processor.Process(
                        block, state,</span><span class="cov0" title="0"> bc.vmConfig, true,
                )
                state = newState // update state in case the new state is cached.
                i</span>f err != nil {
                        bc.reportBlock(block, receipts, err)
                        return i, events, coalescedLogs, err
                <span class="cov8" title="1">}

                // Validate th</span><span class="cov0" title="0">e state using the default validator
                if err := bc.Validator().ValidateState(
                        block, state, receipts, cxReceipts, usedGas,
                )</span>; err != nil {
                <span class="cov8" title="1">        bc.reportBlock(block, receipts, err)
                        return i, events, coalescedLogs, err
                }
                proctime := time.Since(bstart)

                // Write the block to the chain and get the status.
                status, err :=</span><span class="cov0" title="0"> bc.WriteBlockWithState(
                        block, receipts, cxReceipts, stakeMsgs, payout, state,
                )</span>
                <span class="cov8" title="1">if err != nil {
                        return i, events, coalescedLogs, err
                }
                logger := utils.Logger().With().
                        Str("number", block.Number().String()).
                        Str("hash", block.Hash().Hex()).
                        Int("uncles", len(block.Uncles())).
                        Int("txs", len(block.Transactions())).
                        Int("stakingTxs", len(block.StakingTransactions())).
                        Uint64("gas", block.GasUsed()).
                        Str("elapsed"</span>, common.PrettyDuration(time.Since(bstart)).String()).
                        Logger()

                switch status {
                case CanonStatTy:
                        logger.Info().Msg("Inserted new block")
                        coalescedLogs = append(coalescedLogs, logs...)
                        blockInsertTimer.UpdateSince(bstart)
                        events = append(events, ChainEvent{block, block.Hash(), logs})
                        lastCanon = block
</span>
                        // Only count canonical blocks for GC processing time
                <span class="cov8" title="1">        bc.gcproc += proctime
                }

                stats.processed++
</span>                stats.usedGas += usedGas
                cache, _ := bc.stateCache.TrieDB().Size()
        <span class="cov8" title="1">        stats.report(chain, i, cache)
</span>        }
        /</span>/ Append a single chain head event if we've progressed the chain
        if lastCanon != nil &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() {
        <span class="cov8" title="1">        events = append(events, ChainHeadEv</span>ent{lastCanon})
        }

        return 0, events, coalescedLogs, nil
}

// insertStats tracks and reports on block insertion.
type insertStats struct {
        queued, processed, ignored int
        usedGas                    uint64
        lastIndex                  int
        startTime                  mclock.AbsTime
}

// statsReportLimit is the time limit during import and export after which we
// always print out progress. This avoids the user wondering what's going on.
const statsReportLimit = 8 * time.Second

// report prints statistics if some number of blocks have been processed
// or more than a few seconds have passed since the last message.
func (st *insertStats) report(chain []*types.Block, index int, cache common.StorageSize) {
        // Fetch the timings for the batch
        var (
                now     = mclock.Now()
                elapsed = time.Duration(now) - time.Duration(st.startTi</span><span class="cov8" title="1">me)
        )
        // If we're at the last block of the batch or report period reached, log
        if index == len(chain)-1 || elapsed &gt;= statsReportLimit {
                var (
                        end = chain[index]
                        txs = countTransactions(chain[st.lastIndex : index+1])
                )

                context := utils.Logger().With().
                        Int("blocks", st.processed).
                        Int("txs", txs).
                        Float64("mgas", float64(st.usedGas)/1000000).
                        Str("elapsed", common.PrettyDuration(elapsed).String()).
                        Float64("mgasps", float64(st.usedGas)*1000/float64(elapsed)).
                        Str("number", end.Number().String()).
                        Str("hash", end.Hash().Hex()).
</span>                        Str("cache", cache.String())

</span>                if timestamp := time.Unix(end.Time().Int64(), 0); time.Since(timestamp) &gt; time.Minute {
                <span class="cov8" title="1">        context = contex</span><span class="cov0" title="0">t.Str("age", common.PrettyAge(timestamp).String())
                }

</span>                <span class="cov8" title="1">if st.queued &gt; 0 {</span><span class="cov0" title="0">
                        context = context.Int("queued", st.queued)
                }</span>
                if st.ignored &gt; 0 {
                <span class="cov8" title="1">        context = context.Int("ignored", st.ignored)
                }

                logger := context.Logger()
</span>                logger.Info().Msg("Imported new chain segment")

                *st = insertStats{startTime: now, lastIndex: index + 1}
        }
}
</span>
fu</span>nc countTransactions(chain []*types.Block) (c int) {
        <span class="cov8" title="1">for _, b</span> := range chain {
                c += len(b.Transactions())
        }
        return c
}

// PostChainEvents iterates over the events generated by a chain insertion and
// posts them into the event feed.
// TODO: Should </span><span class="cov0" title="0">not expose PostChainEvents. The chain events should be posted in WriteBlock.
func (bc *BlockChain) PostChainEvents(events []interface{}, logs []*types.Log) {
        /</span>/ post event logs for further processing
        <span class="cov8" title="1">if logs != nil {
</span>                bc.logsFeed.Send(logs)
</span>        }
        for _, event := range e</span>vents {
                switch ev := event.(type) {
                case ChainEvent:
                        bc.chainFeed.Send(ev)
</span>
                case ChainHeadEvent:<span class="cov0" title="0">
                        bc.chainHeadFeed.Send(ev)</span>

                case ChainSideEvent:
                        bc.chainSideFeed.Send(ev)
                }
        }
}

func </span><span class="cov8" title="1">(bc *BlockChain) update() {
        futureTi</span>mer := time.NewTicker(5 * time.Second)
        defer futureTimer.Stop<span class="cov8" title="1">()
        for {
</span>                select {
                case &lt;-</span>futureTimer.C:
                        bc.procFutureBlocks()
                case &lt;-bc.quit:
                        return
                }
        }
}

// BadBlock ..
type BadBlock struct {
        Block  *types.Block
        Reason error
}

// MarshalJSON ..
func (b BadBlock) MarshalJSON() ([]byte, error) {
        return json.Marshal(struct {
                Block  *block.Header `json:"header"`
                Reason string        `json:"error-cause"`
        }{
        </span>        b.Block.Header(),
                b.Reason.Error(),
        })
}

// BadBlocks returns a list of the last 'bad blocks' that
// the client has seen on the network
</span>func (bc *BlockChain) BadBlocks() []BadBlock {
</span>        blocks := make([]BadBlock, bc.badBlocks.Len())
        fo</span>r _, hash := range bc.badBlocks.Keys() {
                if blk, exist := bc.badBlocks.Peek(hash); exist {
        <span class="cov0" title="0">                blocks = ap</span>pend(blocks, blk.(BadBlock))
                }
        }
        return blocks
}

/</span>/ addBadBlock adds a bad block to the bad-block LRU cache
func (bc *BlockChain) addBadBlock(block *types.Block, reason error) {
        bc.badBlocks.Add(block.Hash(), BadBlock{block, reason})
}

//<span class="cov0" title="0"> reportBlock logs a bad block error.
func (bc *BlockChain) reportBlock(
        block *types.Block, receipts types.Receipts, err error,
) {
</span>        bc.addBadBlock(block, err)
        v</span>ar receiptString string
        <span class="cov0" title="0">for _, receipt := range receipts {
                receiptString += fmt.Sprintf("\t%v\n", receipt)
        }
        utils.Logger().Error().Msgf(`
########## BAD BLOCK #########
Chain config: %v

Number: %v
Epoch: %v
NumTxn: %v
NumStkTxn: %v
Hash: 0x%x
%v

Error: %v
##############################
`, bc.chainConfig,
                block.Number(),
                block.Epoch(),
                len(block.Transactions()),
                len(block.StakingTransactions()),
                block.Hash(),
                receiptString,
</span>                err,
        )
        f</span>or i, tx := range block.StakingTransactions() {
                utils.Logger().Error().
                        Msgf("StakingTxn %d: %s, %v", i, tx.StakingType().String(), tx.StakingMessage())
        }
}

// InsertHeaderChain attempts to insert the given header chain in to the local
// chain, possibly creating a reorg. If an error is returned, it will return the
// index number of the failing header as well an error describing what went wrong.
//
// The verify parameter can be used to fine tune whether nonce verification
// should be done or not. The reason behind the optional check is because some
// of the header retrieval mechanisms already need to verify nonces, as well as
// because nonces can be verified sparsely, not needing to check each.</span><span class="cov0" title="0">
func (bc *BlockChain) InsertHeaderChain(chain []*block.Header, checkFreq int) (int, error) {
        s</span>tart := time.Now()
        if i, err := bc.hc.ValidateHeaderChain(chain, checkFreq); err != nil {
                return i, err
        <span class="cov0" title="0">}

        // Make sure only one thread manipulates the chain at once
        bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        bc.wg.Add(1)
</span>        defer bc.wg.Done()

        whFunc := func(header *block.Header) error {
                bc.mu.Lock()
                defer bc.mu.Unlock()

</span>                _, err := bc.hc.WriteHeader(header)
        <span class="cov0" title="0">        return err
</span>        }

        return bc.hc.InsertHeaderChain(chain, whFunc, start)
}

// CurrentHeader retrieves the current head header of the canonical chain. The
/</span>/ header is retrieved from the HeaderChain's internal cache.
func (bc *BlockChain) CurrentHeader() *block.Header {
        return bc.hc.CurrentHeader()
}

// GetTd retrieves a block's total difficulty in the canonical chain from the
/</span>/ database by hash and number, caching it if found.
func (bc *BlockChain) GetTd(hash common.Hash, number uint64) *big.Int {
        return bc.hc.GetTd(hash, number)
}

// GetTdByHash retrieves a block's total difficulty in the canonical chain from the
/</span>/ database by hash, caching it if found.
func (bc *BlockChain) GetTdByHash(hash common.Hash) *big.Int {
        return bc.hc.GetTdByHash(hash)
}

// GetHeader retrieves a block header from the database by hash and number,
/</span>/ caching it if found.
func (bc *BlockChain) GetHeader(hash common.Hash, number uint64) *block.Header {
        return bc.hc.GetHeader(hash, number)
}

// GetHeaderByHash retrieves a block header from the database by hash, caching it if
/</span>/ found.
func (bc *BlockChain) GetHeaderByHash(hash common.Hash) *block.Header {
        return bc.hc.GetHeaderByHash(hash)
}

// HasHeader checks if a block header is present in the database or not, caching
/</span>/ it if present.
func (bc *BlockChain) HasHeader(hash common.Hash, number uint64) bool {
        return bc.hc.HasHeader(hash, number)
}

// GetBlockHashesFromHash retrieves a number of block hashes starting at a given
/</span>/ hash, fetching towards the genesis block.
func (bc *BlockChain) GetBlockHashesFromHash(hash common.Hash, max uint64) []common.Hash {
        return bc.hc.GetBlockHashesFromHash(hash, max)
}

// GetAncestor retrieves the Nth ancestor of a given block. It assumes that either the given block or
// a close ancestor of it is canonical. maxNonCanonical points to a downwards counter limiting the
// number of blocks to be individually checked before we reach the canonical chain.
//
// Note: ancestor == 0 returns the same block, 1 returns its parent and so on.
func (bc *BlockChain) GetAncestor(hash common.Hash, number, ancestor uint64, maxNonCanonical *uint64) (common.Hash, uint64) {
        bc.chainmu.Lock()
        </span>defer bc.chainmu.Unlock()

        return bc.hc.GetAncestor(hash, number, ancestor, maxNonCanonical)
}

// GetHeaderByNumber retrieves a block header from the database by number,
/</span>/ caching it (associated with its hash) if found.
func (bc *BlockChain) GetHeaderByNumber(number uint64) *block.Header {
        return bc.hc.GetHeaderByNumber(number)
}
</span>
// Config retrieves the blockchain's chain configuration.
func (bc *BlockChain) Config() *params.ChainConfig { re<span class="cov8" title="1">turn bc.chainConfig </span>}

// Engine retrieves the blockchain's consensus engine.
func (bc *BlockChain) Engine() consensus_engine.Engine { return bc.engine }

/</span>/ SubscribeRemovedLogsEvent registers a subscription of RemovedLogsEvent.
func (bc *BlockChain) SubscribeRemovedLogsEvent(ch chan&lt;- RemovedLogsEvent) event.Subscription {
        return bc.scope.Track(bc.rmLogsFeed.Subscribe(ch))
}

/</span>/ SubscribeChainEvent registers a subscription of ChainEvent.
func (bc *BlockChain) SubscribeChainEvent(ch chan&lt;- ChainEvent) event.Subscription {
        return bc.scope.Track(bc.chainFeed.Subscribe(ch))
}

/</span>/ SubscribeChainHeadEvent registers a subscription of ChainHeadEvent.
func (bc *BlockChain) SubscribeChainHeadEvent(ch chan&lt;- ChainHeadEvent) event.Subscription {
        return bc.scope.Track(bc.chainHeadFeed.Subscribe(ch))
}

/</span>/ SubscribeChainSideEvent registers a subscription of ChainSideEvent.
func (bc *BlockChain) SubscribeChainSideEvent(ch chan&lt;- ChainSideEvent) event.Subscription {
        return bc.scope.Track(bc.chainSideFeed.Subscribe(ch))
}

/</span>/ SubscribeLogsEvent registers a subscription of []*types.Log.
func (bc *BlockChain) SubscribeLogsEvent(ch chan&lt;- []*types.Log) event.Subscription {
        return bc.scope.Track(bc.logsFeed.Subscribe(ch))
}

// ReadShardState retrieves sharding state given the ep</span><span class="cov8" title="1">och number.
func (bc *BlockChain) ReadShardState(epoch *big.Int) (*shard.State, error) {
        cacheKey := string(epoch.Bytes())
        i</span>f cached, ok := bc.shardStateCache.Get(cacheKey); ok {
        <span class="cov8" title="1">        shardState := cached.(*shard.State)
                return shardS</span><span class="cov0" title="0">tate, nil
        }
        shardState, err := rawdb.ReadShardState(bc.db, epoch)</span><span class="cov0" title="0">
        if err != nil {
                i</span>f strings.Contains(err.Error(), rawdb.MsgNoShardStateFromDB) &amp;&amp;
                <span class="cov0" title="0">        shard.Schedule</span>.IsSkippedEpoch(bc.ShardID(), epoch) {
                        return nil, fmt.Errorf("epoch skipped on chain: %w", err)
        <span class="cov8" title="1">        }
                return nil, err
</span>        }
        bc.shardStateCache.Add(cacheKey, shardState)
        return shardState, nil
}

// WriteShardStateBytes <span class="cov8" title="1">saves the given sharding state under the given epoch number.
func (bc *BlockChain) WriteShardStateBytes(db rawdb.DatabaseWriter,
        epoch *big.Int</span><span class="cov0" title="0">, shardState []byte,
) (*shard.State, error) {
        d</span>ecodeShardState, err := shard.DecodeWrapper(shardState)
        <span class="cov8" title="1">if err != nil {
                return nil, e</span><span class="cov0" title="0">rr
        }
        e</span>rr = rawdb.WriteShardStateBytes(db, epoch, shardState)
        <span class="cov8" title="1">if err != nil {
                return nil, err
        }
</span>        cacheKey := string(epoch.Bytes())
        bc.shardStateCache.Add(cacheKey, decodeShardState)
        return decodeShardState, nil
}

</span>// ReadCommitSig retrieves the commit signature on a block.
func (bc *BlockChain) ReadCommitSig(blockNum uint64) ([]byte, error) {
        i</span>f cached, ok := bc.lastCommitsCache.Get(blockNum); ok {
        <span class="cov0" title="0">        lastCommits := cached.([]byte)
                return lastCo</span><span class="cov0" title="0">mmits, nil
        }
        l</span>astCommits, err := rawdb.ReadBlockCommitSig(bc.db, blockNum)
        <span class="cov0" title="0">if err != nil {
</span>                return nil, err
        }
        return lastCommits, nil
}

// WriteCommitS</span><span class="cov0" title="0">ig saves the commits signatures signed on a block.
func (bc *BlockChain) WriteCommitSig(blockNum uint64, lastCommits []byte) error {
        e</span>rr := rawdb.WriteBlockCommitSig(bc.db, blockNum, lastCommits)
        <span class="cov0" title="0">if err != nil {
                return er</span>r
        }
        bc.lastCommitsCache.Add(blockNum, lastCommits)
        return nil
}

// GetVdfByNumber </span><span class="cov0" title="0">retrieves the rand seed given the block number, return 0 if not exist
func (bc *BlockChain) GetVdfByNumber(number uint64) []byte {
        h</span>eader := bc.GetHeaderByNumber(number)
        if header == nil {
        <span class="cov0" title="0">        return []byte{}
</span>        }

        return header.Vdf()
}

// GetVrfByNumber </span><span class="cov0" title="0">retrieves the randomness preimage given the block number, return 0 if not exist
func (bc *BlockChain) GetVrfByNumber(number uint64) []byte {
        h</span>eader := bc.GetHeaderByNumber(number)
        <span class="cov0" title="0">if header == nil {
</span>                return []byte{}
        }
        return header.Vrf()
}
</span>
// ChainDb returns the database
func (bc *BlockChain) ChainDb() ethdb.Database { return bc.db }

// GetEpochBlockNumber returns the first block number of the given epoch.
func (bc *BlockChain) GetEpochBlockNumber(epoch *big.In</span><span class="cov0" title="0">t) (*big.Int, error) {
        // Try cache first
        c</span>acheKey := string(epoch.Bytes())
        <span class="cov0" title="0">if cachedValue, ok := bc.epochCache.Get(cacheKey); ok {
                return (&amp;big.</span><span class="cov0" title="0">Int{}).SetBytes([]byte(cachedValue.(string))), nil
        }
        blockNum, err := rawdb.ReadEpochBlockNumber(bc.db, epoch)
        if err != nil {
                </span>return nil, errors.Wrapf(
        <span class="cov0" title="0">                err, "cannot read epoch block number from database",
                )
        }
</span>        cachedValue := []byte(blockNum.Bytes())
        bc.epochCache.Add(cacheKey, cachedValue)
        return blockNum, nil
}

// Store<span class="cov0" title="0">EpochBlockNumber stores the given epoch-first block number.
func (bc *BlockChain) StoreEpochBlockNumber(
        epoch *big.Int, blockNum *big.Int,
) error {
        cacheKey := string(epoch.Bytes())
</span>        cachedValue := []byte(blockNum.Bytes())
        bc.epochCache.Add(cacheKey, cachedValue)
        if err := rawdb.WriteEpochBlockNumber(bc.db, epoch, blockNum); err != nil {
                </span>return errors.Wrapf(
        <span class="cov0" title="0">                err, "ca</span>nnot write epoch block number to database",
                )
        }
        return nil
}

// ReadEpochVrfBlockNums retrieves block numbers with valid VRF for the speci</span><span class="cov0" title="0">fied epoch
func (bc *BlockChain) ReadEpochVrfBlockNums(epoch *big.Int) ([]uint64, error) {
        vrfNumbers := []uint64{}
</span>        if cached, ok := bc.randomnessCache.Get("vrf-" + string(epoch.Bytes())); ok {
                e</span>ncodedVrfNumbers := cached.([]byte)
                <span class="cov0" title="0">if err := rlp.DecodeBy</span>tes(encodedVrfNumbers, &amp;vrfNumbers); err != nil {
                        return nil, err
                }
        <span class="cov0" title="0">        return vrfNumbers, nil
        }
</span>
        e</span>ncodedVrfNumbers, err := rawdb.ReadEpochVrfBlockNums(bc.db, epoch)
        if err != nil {
        <span class="cov0" title="0">        return nil, err
</span>        }

</span>        <span class="cov0" title="0">if err := rlp.DecodeBy</span>tes(encodedVrfNumbers, &amp;vrfNumbers); err != nil {
                return nil, err
        }
        return vrfNumbers, nil
}

// WriteEpochVr</span><span class="cov0" title="0">fBlockNums saves block numbers with valid VRF for the specified epoch
func (bc *BlockChain) WriteEpochVrfBlockNums(epoch *big.Int, vrfNumbers []uint64) error {
        e</span>ncodedVrfNumbers, err := rlp.EncodeToBytes(vrfNumbers)
        if err != nil {
        <span class="cov0" title="0">        return err
        }
</span>
        e</span>rr = rawdb.WriteEpochVrfBlockNums(bc.db, epoch, encodedVrfNumbers)
        <span class="cov0" title="0">if err != nil {
                return er</span>r
        }
        bc.randomnessCache.Add("vrf-"+string(epoch.Bytes()), encodedVrfNumbers)
        return nil
}

</span>// ReadEpochVdfBlockNum retrieves block number with valid VDF for the specified epoch
func (bc *BlockChain) ReadEpochVdfBlockNum(epoch *big.Int) (*big.Int, error) {
        i</span>f cached, ok := bc.randomnessCache.Get("vdf-" + string(epoch.Bytes())); ok {
                encodedVdfNumber := cached.([]byte)
        <span class="cov0" title="0">        return new(big.Int).SetBytes(encodedVdfNumber), nil
        }
</span>
        e</span>ncodedVdfNumber, err := rawdb.ReadEpochVdfBlockNum(bc.db, epoch)
        <span class="cov0" title="0">if err != nil {
</span>                return nil, err
        }
        return new(big.Int).SetBytes(encodedVdfNumber), nil
}

// WriteEpochVd</span><span class="cov0" title="0">fBlockNum saves block number with valid VDF for the specified epoch
func (bc *BlockChain) WriteEpochVdfBlockNum(epoch *big.Int, blockNum *big.Int) error {
        e</span>rr := rawdb.WriteEpochVdfBlockNum(bc.db, epoch, blockNum.Bytes())
        if err != nil {
        <span class="cov0" title="0">        return err
        }
</span>
        bc.randomnessCache.Add("vdf-"+string(epoch.Bytes()), blockNum.Bytes())
        return nil
}

// WriteCrossLinks saves the ha</span><span class="cov0" title="0">shes of crosslinks by shardID and blockNum combination key
func (bc *BlockChain) WriteCrossLinks(batch rawdb.DatabaseWriter, cls []types.CrossLink) error {
        var err error
        f</span>or i := 0; i &lt; len(cls); i++ {
        <span class="cov0" title="0">        cl := cls</span>[i]
                err = rawdb.WriteCrossLinkShardBlock(batch, cl.ShardID(), cl.BlockNum(), cl.Serialize())
        }
        return err
}

// DeleteCrossLinks removes the</span><span class="cov0" title="0"> hashes of crosslinks by shardID and blockNum combination key
func (bc *BlockChain) DeleteCrossLinks(cls []types.CrossLink) error {
        var err error
        f</span>or i := 0; i &lt; len(cls); i++ {
        <span class="cov0" title="0">        cl := cls</span>[i]
                err = rawdb.DeleteCrossLinkShardBlock(bc.db, cl.ShardID(), cl.BlockNum())
        }
        return err
}

// ReadCrossLin</span><span class="cov0" title="0">k retrieves crosslink given shardID and blockNum.
func (bc *BlockChain) ReadCrossLink(shardID uint32, blockNum uint64) (*types.CrossLink, error) {
        b</span>ytes, err := rawdb.ReadCrossLinkShardBlock(bc.db, shardID, blockNum)
        <span class="cov0" title="0">if err != nil {
                return nil, err
        }
</span>        crossLink, err := types.DeserializeCrossLink(bytes)

        return crossLink, err
}

// LastContinuousCrossLink saves the last crosslink of a shard
// This function will update the latest crosslink in the sense that
// any previous block's crosslink is received up to this point
// there is no missing hole betwe</span><span class="cov0" title="0">en genesis to this crosslink of given shardID
func (bc *BlockChain) LastContinuousCrossLink(batch rawdb.DatabaseWriter, shardID uint32) error {
        o</span>ldLink, err := bc.ReadShardLastCrossLink(shardID)
        <span class="cov0" title="0">if oldLink == nil || err != nil {
                return err
        }
</span>        newLink := oldLink
        // Starting from last checkpoint, keeping reading im</span><span class="cov0" title="0">mediate next crosslink until there is a gap
        for i := oldLink.BlockNum() + 1; ; i++ {
                t</span>mp, e<span class="cov0" title="0">rr := bc.ReadCrossLink(shardID, i)
                if err</span> == nil &amp;&amp; tmp != nil &amp;&amp; tmp.BlockNum() == i {
                        newLink = tmp
                } else {
                        break
        <span class="cov0" title="0">        }
</span>        }

        i</span>f newLink.BlockNum() &gt; oldLink.BlockNum() {
        <span class="cov0" title="0">        utils.Log</span>ger().Debug().Msgf("LastContinuousCrossLink: latest checkpoint blockNum %d", newLink.BlockNum())
                return rawdb.WriteShardLastCrossLink(batch, shardID, newLink.Serialize())
        }
        return nil
}

// ReadShardLas</span><span class="cov0" title="0">tCrossLink retrieves the last crosslink of a shard.
func (bc *BlockChain) ReadShardLastCrossLink(shardID uint32) (*types.CrossLink, error) {
        b</span>ytes, err := rawdb.ReadShardLastCrossLink(bc.db, shardID)
        <span class="cov0" title="0">if err != nil {
</span>                return nil, err
        }
        return types.DeserializeCrossLink(bytes)
}

</span>func (bc *BlockChain) writeSlashes(processed slash.Records) error {
        bytes, err := rlp.EncodeToBytes(processed)
        if err != nil {
                </span>const msg = "failed to encode slashing candidates"
        <span class="cov0" title="0">        utils.Logger().Error().Msg(msg)
</span>                return err
        }</span>
        <span class="cov0" title="0">if err := </span>rawdb.WritePendingSlashingCandidates(bc.db, bytes); err != nil {
                return err
        }
        return nil
}

// Delet<span class="cov0" title="0">eFromPendingSlashingCandidates ..
func (bc *BlockChain) DeleteFromPendingSlashingCandidates(
        processed slash.Records,
) error {
        bc.pendingSlashingCandidatesMU.Lock()
        defer bc.pendingSlashingCandidatesMU.Unlock()
        </span>current := bc.ReadPendingSlashingCandidates()
        bc.pendingSlashes = processed.SetDifference(current)
        return bc.writeSlashes(bc.pendingSlashes)
}

</span>// ReadPendingSlashingCandidates retrieves pending slashing candidates
fu</span>nc (bc *BlockChain) ReadPendingSlashingCandidates() slash.Records {
        <span class="cov0" title="0">if !bc.Config().IsStaking(bc.CurrentHeader().Epoch()) {
</span>                return slash.Records{}
        }
        return append(bc.pendingSlashes[0:0], bc.pendingSlashes...)
}

// ReadPendingCrossLinks retrieves pending crosslinks
func (bc *BlockChain) ReadPendingCrossLinks() ([]types.CrossLink, error</span><span class="cov0" title="0">) {
        cls := []types.CrossLink{}
        bytes := []byte{}
        i</span>f cac<span class="cov0" title="0">hed, ok := bc.pendingCrossLinksCache.Get(pendingCLCacheKey); ok {
                cls = cached.([]types.CrossLink)
                return cls, nil
</span>        } else {
                b</span>y, err := rawdb.ReadPendingCrossLinks(bc.db)
                <span class="cov0" title="0">if err != </span>nil || len(by) == 0 {
                        return nil, err
        <span class="cov0" title="0">        }
</span>                bytes = by
        }
        i</span>f err := rlp.DecodeBytes(bytes, &amp;cls); err != nil {
                utils.Logger().Error().Err(err).Msg("Invalid pending crosslink RLP decoding")
        <span class="cov0" title="0">        return nil, err
        }
</span>
        bc.pendingCrossLinksCache.Add(pendingCLCacheKey, cls)
        return cls, nil
}

// CachePendingCrossLinks caches the pending crosslinks in memory
func (bc *BlockChain) CachePend</span><span class="cov0" title="0">ingCrossLinks(crossLinks []types.CrossLink) error {
        // deduplicate crosslinks if any
</span>        m := map[uint32]map[uint64]types.CrossLink{}
        fo</span>r _, cl := range crossLinks {
                <span class="cov0" title="0">if _, ok := m[cl.ShardID()]; !ok {
</span>                        m[cl.ShardID()] = map[uint64]types.CrossLink{}
                }
        <span class="cov0" title="0">        m[cl.ShardID()][cl.BlockNum()] = cl
        }
</span>
</span>        cls := []types.CrossLink{}
        fo</span>r _, m1 := range m {
                for _, cl := range m1 {
        <span class="cov0" title="0">                cls = append(cls, cl)
                }
        }
        utils.Logg</span>er().Debug().Msgf("[CachePendingCrossLinks] Before Dedup has %d cls, after Dedup has %d cls", len(crossLinks), len(cls))

        bc.pendingCrossLinksCache.Add(pendingCLCacheKey, cls)
        return nil
}

</span>// SavePendingCrossLinks saves the pending crosslinks in db
func (bc *BlockChain) SavePendingCrossLinks() error {
        if cached, ok :</span><span class="cov0" title="0">= bc.pendingCrossLinksCache.Get(pendingCLCacheKey); ok {
                cls := cached.([]types.CrossLink)
                b</span>ytes, err := rlp.EncodeToBytes(cls)
                <span class="cov0" title="0">if err != nil {
</span>                        return err
                }</span>
                if err := rawdb.WritePendingCrossLinks(bc.db, bytes); err != nil {
        <span class="cov0" title="0">                return e</span>rr
                }
        }
        return nil
}

// AddPe<span class="cov0" title="0">ndingSlashingCandidates appends pending slashing candidates
func (bc *BlockChain) AddPendingSlashingCandidates(
        candidates slash.Records,
) error {
        bc.pendingSlashingCandidatesMU.Lock()
        defer bc.pendingSlashingCandidatesMU.Unlock()
        current := bc.</span><span class="cov0" title="0">ReadPendingSlashingCandidates()

        s</span>tate, err := bc.State()
        if err != nil {
        <span class="cov0" title="0">        return err
        }
</span>
</span>        valid := slash.Records{}
        fo</span>r i := range candidates {
                if err := slash.Verify(bc, state, &amp;candidates[i]); err == nil {
                        valid = append(valid, candidates[i])
        <span class="cov0" title="0">        }
        }

        pendingSlashes := append(
                bc.pendingSlashes, current.SetDifference(valid)...,
</span>        )

        if l, c := len(pendingSlashes), len(current); l &gt; maxPendingSlashes {
                </span>return errors.Wrapf(
        <span class="cov0" title="0">                errExceedMaxPendingSlashes, "current %d with-additional %d", c, l,
                )
</span>        }
        bc.pendingSlashes = pendingSlashes
        return bc.writeSlashes(bc.pendingSlashes)
}

// AddPendingCrossLinks appends pending crosslinks
func (bc *BlockChain) AddPendingCrossLinks(pendingCLs []types.CrossLink) (int, error) {
        bc.pendingCrossLinksMutex.Lock()
        defer bc.pendingCrossLinksMutex</span><span class="cov0" title="0">.Unlock()

        cls, err := bc.ReadPendingCrossLinks()
        i</span>f err != nil || len(cls) == 0 {
        <span class="cov0" title="0">        err := bc.CachePendingCrossLinks(pendingCLs)
                return len(pendingCLs), err
        }
</span>        cls = append(cls, pendingCLs...)
        err = bc.CachePendingCrossLinks(cls)
        return len(cls), err
}

// DeleteFromPendingCrossLinks delete pending crosslinks that already committed (i.e. passed in the params)
func (bc *BlockChain) DeleteFromPendingCrossLinks(crossLinks []types.CrossLink) (int, error) {
        bc.pendingCrossLinksMutex.Lock()
        defer bc.pendingCrossLinksMutex</span><span class="cov0" title="0">.Unlock()

        c</span>ls, err := bc.ReadPendingCrossLinks()
        if err != nil || len(cls) == 0 {
        <span class="cov0" title="0">        return 0, err
        }
</span>
</span>        m := map[uint32]map[uint64]struct{}{}
        fo</span>r _, cl := range crossLinks {
                <span class="cov0" title="0">if _, ok := m[cl.ShardID()]; !ok {
</span>                        m[cl.ShardID()] = map[uint64]struct{}{}
                }
        <span class="cov0" title="0">        m[cl.ShardID()][cl.BlockNum()] = struct{}{}
        }

</span>        pendingCLs := []types.CrossLink{}</span><span class="cov0" title="0">

</span>        for _, cl :</span>= range cls {
                if _, ok := m[cl.ShardID()]; ok {
                        if _, ok1 := m[cl.ShardID()][cl.BlockNum()]; ok1 {
                <span class="cov0" title="0">                continue
</span>                        }
        <span class="cov0" title="0">        }
                pendingCLs = append(pendin</span>gCLs, cl)
        }
        err = bc.CachePendingCrossLinks(pendingCLs)
        return len(pendingCLs), err
}

</span>// IsSameLeaderAsPreviousBlock retrieves a block from the database by number, caching it
fu</span>nc (bc *BlockChain) IsSameLeaderAsPreviousBlock(block *types.Block) bool {
        if IsEpochBlock(block) {
        <span class="cov0" title="0">        return false
        }
</span>
        p</span>reviousHeader := bc.GetHeaderByNumber(block.NumberU64() - 1)
        <span class="cov0" title="0">if previousHeader == nil {
</span>                return false
        }
        return block.Coinbase() == previousHeader.Coinbase()
}

/</span>/ GetVMConfig returns the block chain VM config.
func (bc *BlockChain) GetVMConfig() *vm.Config {
        return &amp;bc.vmConfig
}

// ReadCXReceipts retrieves the </span><span class="cov0" title="0">cross shard transaction receipts of a given shard
func (bc *BlockChain) ReadCXReceipts(shardID uint32, blockNum uint64, blockHash common.Hash) (types.CXReceipts, error) {
        c</span>xs, err := rawdb.ReadCXReceipts(bc.db, shardID, blockNum, blockHash)
        <span class="cov0" title="0">if err != nil |</span>| len(cxs) == 0 {
                return nil, err
        }
        return cxs, nil
}

// CXMerkleProof calculates the cross shard transaction merkle proof of a given destination shard
func (bc *BlockChain) CXMerkleProof(toShardID uint32, block *types.Block) (*types.CXMerkleProof, error) {
        proof := &amp;types.CXMerkleProof{BlockNum: block.Number(), BlockHash: block.Hash(), ShardID: block.ShardID(), CXReceiptHash: block.Header().OutgoingReceiptHash(), CXShardHashes: []common.Hash{}, ShardIDs: []uint32{}}

        epoch := block.Header().Epoch()
        shardingConfig := shard.Schedu</span><span class="cov0" title="0">le.InstanceForEpoch(epoch)
        shardNum := int(shardingConfig.NumShards())

</span>        for i := 0</span>; i &lt; shardNum; i++ {
                receip<span class="cov0" title="0">ts, err := bc.ReadCXReceipts(uint32(i), block.NumberU64(), block.Hash())
                if err != nil || len(receipts) == 0 {
                        continue
                } else {
                        </span>hash := types.DeriveSha(receipts)
                        proof.CXShardHashes = append(proof.CXShardHashes, hash)
        <span class="cov0" title="0">                proof.ShardIDs = append(pr</span><span class="cov0" title="0">oof.ShardIDs, uint32(i))
                }
        }</span>
        <span class="cov0" title="0">if len(proof.Shar</span>dIDs) == 0 {
                return nil, nil
        }
        return proof, nil
}

// WriteCXReceiptsProofSpe</span><span class="cov0" title="0">nt mark the CXReceiptsProof list with given unspent status
// true: unspent, false: spent
</span>func (bc *BlockChain) WriteCXReceiptsProofSpent(db rawdb.DatabaseWriter, cxps []*types.CXReceiptsProof) error {
        fo</span>r _, cxp := range cxps {
                if err := rawdb.WriteCXReceiptsProofSpent(db, cxp); err != nil {
        <span class="cov8" title="1">                return e</span>rr
                }
        }
        return nil
}

// IsSpent checks whether a CXReceiptsProof is unspent
func (bc *BlockChain) IsSpent(cxp *types.CXReceiptsProof) bool {
        shardID := cxp.MerkleProof.ShardID
        </span>blockNum := cxp.MerkleProof.BlockNum.Uint64()
        by, _ := rawdb.ReadCXReceiptsProofSpent(bc.db, shardID, blockNum)
        return by == rawdb.SpentByte
}

// ReadTxLookupEntry returns where the given transaction resides in the chain,
// as a (block hash, block number, index in transaction list) triple.
/</span>/ returns 0, 0 if not found
func (bc *BlockChain) ReadTxLookupEntry(txID common.Hash) (common.Hash, uint64, uint64) {
        return rawdb.ReadTxLookupEntry(bc.db, txID)
}

// ReadValidatorInformationAtRoot reads staking
// information of given validatorWrap<span class="cov0" title="0">per at a specific state root
func (bc *BlockChain) ReadValidatorInformationAtRoot(
        addr common.Address, root comm</span><span class="cov0" title="0">on.Hash,
) (*staking.ValidatorWrapper, error) {
        s</span>tate, err := bc.StateAt(root)
        <span class="cov0" title="0">if err != nil || state == nil {
</span>                return nil, errors.Wrapf(err, "at root: %s", root.Hex())
        }
        return bc.ReadValidatorInformationAtState(addr, state)
}

// ReadValidatorInformationAtState reads staking
// information of given validatorWrap<span class="cov0" title="0">per at a specific state root
func (bc *BlockCh</span><span class="cov0" title="0">ain) ReadValidatorInformationAtState(
        addr common.Address, state *state.DB,
) </span>(*staking.ValidatorWrapper, error) {
        <span class="cov0" title="0">if state == nil {
                return nil, e</span><span class="cov0" title="0">rrors.New("empty state")
        }
        w</span>rapper, err := state.ValidatorWrapper(addr)
        <span class="cov0" title="0">if err != nil {
</span>                return nil, err
        }
        return wrapper, nil
}

// ReadValidatorInformation reads sta<span class="cov0" title="0">king information of given validator address
func (bc *BlockChain) ReadValidatorInformation(
        </span>addr common.Address,
) (*staking.ValidatorWrapper, error) {
        return bc.ReadValidatorInformationAtRoot(addr, bc.CurrentBlock().Root())
}

// ReadValidatorSnapshotAtEpoch reads the snapshot
// staking validator information of given validator address
func (bc *BlockChain) ReadValidatorSna<span class="cov0" title="0">pshotAtEpoch(
        epoch *big.Int,
        </span>addr common.Address,
) (*staking.ValidatorSnapshot, error) {
        return rawdb.ReadValidatorSnapshot(bc.db, addr, epoch)
}

// ReadValidatorSnapshot reads the sna<span class="cov8" title="1">pshot staking information of given validator address
func (bc *BlockChain) ReadValidatorSnapshot(
        addr common.Address,
) (*staking.ValidatorSnapshot, error) {
</span>        epoch := bc.CurrentBlock().Epoch()
        k</span>ey := addr.Hex() + epoch.String()
        <span class="cov0" title="0">if cached, ok := bc.validatorSnapshotCache.Get(key); ok {
                return cached</span><span class="cov0" title="0">.(*staking.ValidatorSnapshot), nil
        }
        v</span>s, err := rawdb.ReadValidatorSnapshot(bc.db, addr, epoch)
        <span class="cov0" title="0">if err != nil {
                return nil, e</span>rr
        }
        bc.validatorSnapshotCache.Add(key, vs)
        return vs, nil
}

// Write<span class="cov8" title="1">ValidatorSnapshot writes the snapshot of provided validator
func (bc *BlockChain) WriteValidatorSnapshot(
        batch rawdb.DatabaseWriter, snapshot *staking.ValidatorSnapshot,
</span>) error {
        /</span>/ Batch write the current data as snapshot
        if err := rawdb.WriteValidatorSnapshot(batch, snapshot.Validator, snapshot.Epoch); err != nil {
                return err
        <span class="cov8" title="1">}

        // Update </span>cache
        key := snapshot.Validator.Address.Hex() + snapshot.Epoch.String()
        bc.validatorSnapshotCache.Add(key, snapshot)
        return nil
}

// ReadValidatorStats reads the sta<span class="cov0" title="0">ts of a validator
func (bc *BlockChain) ReadValidatorStats(
        </span>addr common.Address,
) (*staking.ValidatorStats, error) {
        return rawdb.ReadValidatorStats(bc.db, addr)
}

// UpdateValidatorVotingPower writes the voting power for the committees
func (bc *BlockChain) UpdateValidatorVotingPower(
        batch rawdb.DatabaseWriter,
        block *types.Block,
        newEpochSuperCommittee, currentEp</span><span class="cov0" title="0">ochSuperCommittee *shard.State,
        state *state.DB,
) </span>(map[common.Address]*staking.ValidatorStats, error) {
        if newEpochSuperCommittee == nil {
        <span class="cov0" title="0">        return nil, shard.ErrSuperCommitteeNil
        }

        validatorStats := map[common.Address]*staking.ValidatorStats{}

        existing, replacing :=
                currentEpochSuperCommittee.StakedValidators(),
                newEpochSuperCommittee.StakedValidators()

        // TODO could also keep track of the BLS keys whi</span><span class="cov0" title="0">ch
        // lost a slot because just losing slots doesn't mean that the
</span>        // validator was booted, just that some of their keys lost slots
        for currentValidator := range existing.LookupSet {
                if _, keptSlot := replacing.LookupSet[currentValidator]; !keptSlot {
                        // NOTE Think carefully about when time comes to delete offchain things
                        // TODO Someone: collect and then delete every 30 epochs
                        // rawdb.DeleteValidatorSnapshot(
                        //         bc.db, currentValidator, currentEpochSuperCommittee.Epoch,
                        // )
</span>                        // rawdb.DeleteValidatorStats(bc.db, currentValidator)
                        s</span>tats, err := rawdb.ReadValidatorStats(bc.db, currentValidator)
                        if err != nil {
                        <span class="cov0" title="0">        stats = staking.NewEmptyStats()
</span>                        }
                        // This means i</span><span class="cov0" title="0">t's already in staking epoch
                        if currentEpochSuperCommittee.Epoch != nil {
                                w</span>rapper, err := state.ValidatorWrapper(currentValidator)
                                if err != nil {
                                <span class="cov0" title="0">        return nil, err
</span>                                }

</span></span>                                if slash.IsBanned(wrapper) {
                                        </span>stats<span class="cov0" title="0">.BootedStatus = effective.BannedForDoubleSigning
                                } else if wrapper.Status == effective.Inactive {
                                        </span>stats.BootedStatus = effective.TurnedInactiveOrInsufficientUptime
                                } else {
                                        stats.BootedStatus = effective.LostEPoSAuction
                                <span class="cov0" title="0">}

                                // compute APR</span><span class="cov0" title="0"> for the exiting validators
                                if err := bc.ComputeAndUpdateAPR(
                                        </span>block, currentEpochSuperCommittee.Epoch, wrapper, stats,
                                ); err != nil {
                        <span class="cov0" title="0">                return nil, err
</span>                                }
                        }
                        validatorStats[currentValidator] = stats
        <span class="cov0" title="0">        }
        }
</span>
        rosters := make([]*votepower.Roster, len</span><span class="cov0" title="0">(newEpochSuperCommittee.Shards))
        for i := range newEpochSuperCommittee.Shards {
                subCommittee := &amp;newEpochSuperCommittee.Shards[i]
                if newEpochSuperCommittee.Epoch == nil {
                        return nil, errors.Wrapf(
                                errNilEpoch,
                                "block epoch %v current-committee-epoch %v",
                        </span>        block.Epoch(),
                <span class="cov0" title="0">                currentEpochSuperCommittee.Epoch,
                        )
</span>                }
                r</span>oster, err := votepower.Compute(subCommittee, newEpochSuperCommittee.Epoch)
                <span class="cov0" title="0">if err != nil {
</span>                        return nil, err
                }
        <span class="cov0" title="0">        rosters[i] = roster
        }
</span>
        networkWide := </span><span class="cov0" title="0">votepower.AggregateRosters(rosters)
        for key, value := range networkWide {
                s</span>tats, err := rawdb.ReadValidatorStats(bc.db, key)
                <span class="cov0" title="0">if err != nil {
                        stats = staking.NewE</span><span class="cov0" title="0">mptyStats()
                }
                t</span>otal := numeric.ZeroDec()
                <span class="cov0" title="0">for i := range value {
                        total = total.Add(value[i].EffectiveStake)
                }
</span>                stats.TotalEffectiveStake = total
                earningWrapping := make([]staking.VoteWithCurrentEpochEarning, len(value))
                for i := range value {
                        earningWrapping[i] = staking.VoteWithCurrentEpochEarning{
                        </span>        Vote:   value[i],
                <span class="cov0" title="0">                Earned: big.NewInt(0),
                        }
                }
                stats.MetricsPerShard = earningWrapping

                // fetch raw-s</span><span class="cov0" title="0">take from snapshot and update per-key metrics
                if snapshot, err := bc.ReadValidatorSnapshotAtEpoch(
                        newEpochSuperCommittee.Epoch, key,
                ); err == nil {
</span>                        wrapper := snapshot.Validator
                        spread := numeric.ZeroDec()
                        i</span>f len(wrapper.SlotPubKeys) &gt; 0 {
                        <span class="cov0" title="0">        spread = numeric.NewDecFromBigInt(wr</span><span class="cov0" title="0">apper.TotalDelegation()).
                                        QuoInt64(int64(len(wrapper.SlotPubKeys)))
                        }</span>
                        for i := range stats.MetricsPerShard {
                                stats.MetricsPerShard[i].Vote.RawStake = spread
                        }
                }

</span>                // This means it's already in staking epo</span><span class="cov0" title="0">ch, and
                // compute APR for validators in current committee only
                if currentEpochS</span><span class="cov0" title="0">uperCommittee.Epoch != nil {
                        if _, ok := existing.LookupSet[key]; ok {
                                w</span>rapper, err := state.ValidatorWrapper(key)
                                if err != nil {
                                <span class="cov0" title="0">        return nil, err
                                }

</span>                                if err := bc.ComputeAndUpdateAPR(
                                        </span>block, currentEpochSuperCommittee.Epoch, wrapper, stats,
                                ); err != nil {
                                        return nil, err
                <span class="cov0" title="0">                }
</span>                        }
                }
        <span class="cov0" title="0">        validatorStats[key] = sta</span>ts
        }

        return validatorStats, nil
}

// ComputeAndUpdateAPR ...
func (bc<span class="cov0" title="0"> *BlockChain) ComputeAndUpdateAPR(
        block *types.Block, now *big.Int,
        wrapper *staking.ValidatorWrapper, stats *staking.ValidatorStats,
) error {
</span>        if aprComputed, err := apr.ComputeForValidator(
</span>                bc, block, wrapper,
        );</span> err <span class="cov0" title="0">!= nil {
                if errors.Cause(err) == apr.ErrInsufficientEpoch {
                        </span>utils.Logger().Info().Err(err).Msg("apr could not be computed")
                } els<span class="cov0" title="0">e {
                        return err
                }
        } else {
                // only insert if APR for current epoch does not exists
                aprEntry := staking.APREntry{now, *aprComputed}
                l := len(stats.APRs)
                // first time inserting apr for validator or
</span>                // apr for current epoch does not exists
                /</span>/ check the last entry's epoch, if not same, insert
                if l == 0 || stats.APRs[l-1].Epoch.Cmp(now) != 0 {
                <span class="cov0" title="0">        stats.APRs = append(stats.APRs,</span><span class="cov0" title="0"> aprEntry)
                }
                /</span>/ if history is more than staking.APRHistoryLength, pop front
                if l &gt; staking.APRHistoryLength {
        <span class="cov0" title="0">                stats.AP</span>Rs = stats.APRs[1:]
                }
        }
        return nil
}

// UpdateValidatorSnapshots updates the content snapshot of all validators
// Note:<span class="cov0" title="0"> this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateValidatorSnapshots(
        batch rawdb.DatabaseWriter, epoch *big.Int, state *state.DB, newValidators []common.Address,
) error {
        // Note this i</span><span class="cov0" title="0">s reading the validator list from last block.
        // It's fine since the new validators from this block is already snapshot when created.
        a</span>llValidators, err := bc.ReadValidatorList()
        if err != nil {
        <span class="cov0" title="0">        return err
        }

        allValidators = append(allVal</span><span class="cov0" title="0">idators, newValidators...)

        // Read all validator's current data and snapshot them
        for i := range </span><span class="cov0" title="0">allValidators {
                // The snapshot will be captured in the state after the last epoch block is finalized
                v</span>alidator, err := state.ValidatorWrapper(allValidators[i])
                if err != nil {
                <span class="cov0" title="0">        return err
                }
</span>
                s</span>napshot := &amp;staking.ValidatorSnapshot{validator, epoch}
                if err := bc.WriteValidatorSnapshot(batch, snapshot); err != nil {
                        return err
        <span class="cov0" title="0">        }
</span>        }

        return nil
}

</span>// ReadValidatorList reads the addresses of current all validators
func (bc *BlockChain) ReadValidatorList() ([]common.Address, error) {
        if cached, ok := bc.validatorListCache.Get("val</span><span class="cov0" title="0">idatorList"); ok {
                by := cached.([]byte)
                m</span> := []common.Address{}
                <span class="cov0" title="0">if err := rlp</span>.DecodeBytes(by, &amp;m); err != nil {
                        return nil, err
        <span class="cov8" title="1">        }
</span>                return m, nil
        }
        return rawdb.ReadValidatorList(bc.db)
}

// WriteValidatorList writes the list of validator addresses to database
// Note:<span class="cov0" title="0"> this should only be called within the blockchain insert process.
func (bc *BlockChain) WriteValidatorList(
</span>        db rawdb.DatabaseWriter, addrs []common.Address,
) </span>error {
        <span class="cov0" title="0">if err := rawdb.WriteValidatorList(db, addrs); err != nil {
                return err
</span>        }
        b</span>ytes, err := rlp.EncodeToBytes(addrs)
        <span class="cov0" title="0">if err == </span>nil {
                bc.validatorListCache.Add("validatorList", bytes)
        }
        return nil
}

// ReadDelegationsByDelegator reads the add<span class="cov8" title="1">resses of validators delegated by a delegator
func (bc *BlockChain) ReadDelegationsByDelegator(
        delegator common.Address,
</span>) (m staking.DelegationIndexes, err error) {
        rawResult := staking.DelegationIndexes{}
</span>        if cached, ok := bc.validatorListByDelegatorCache.Get(string(delegator.Bytes())); ok {
                b</span>y := cached.([]byte)
                if er<span class="cov8" title="1">r := rlp.DecodeBytes(by, &amp;rawResult); err != nil {
                        return nil, err
</span>                }
        } </span>else {
                if rawResult, err = rawdb.ReadDelegationsByDelegator(bc.db, delegator); err != nil {
        <span class="cov8" title="1">                return nil, err
                }
</span>        }
</span>        blockNum := bc.CurrentBlock().Number()
        fo</span>r _, <span class="cov0" title="0">index := range rawResult {
                if index.BlockNum.Cmp(blockNum) &lt;= 0 {
                        m = append(m, index)
                } else {
                        </span>// Filter out index that's created beyond current height of chain.
                        // This only happens when there is a chain rollback.
        <span class="cov8" title="1">                utils.Logge</span>r().Warn().Msgf("Future delegation index encountered. Skip: %+v", index)
                }
        }
        return m, nil
}

// ReadDelegationsByDelegatorAt reads the a<span class="cov0" title="0">ddresses of validators delegated by a delegator at a given block
func (bc *BlockChain) ReadDelegationsByDelegatorAt(
        delegator common.Address, blockNum *big.Int,
</span>) (m staking.DelegationIndexes, err error) {
        rawResult := staking.DelegationIndexes{}
</span>        if cached, ok := bc.validatorListByDelegatorCache.Get(string(delegator.Bytes())); ok {
                b</span>y := cached.([]byte)
                if er<span class="cov0" title="0">r := rlp.DecodeBytes(by, &amp;rawResult); err != nil {
                        return nil, err
</span>                }
        } </span>else {
                if rawResult, err = rawdb.ReadDelegationsByDelegator(bc.db, delegator); err != nil {
        <span class="cov0" title="0">                return nil, err
</span>                }
</span>        }
        fo</span>r _, <span class="cov0" title="0">index := range rawResult {
                if index.BlockNum.Cmp(blockNum) &lt;= 0 {
                        m = append(m, index)
                } else {
                        </span>// Filter out index that's created beyond current height of chain.
                        // This only happens when there is a chain rollback.
        <span class="cov0" title="0">                utils.Logge</span>r().Warn().Msgf("Future delegation index encountered. Skip: %+v", index)
                }
        }
        return m, nil
}

// writeDelegationsByDelegator writes the list of validator addresses to database
func (bc *BlockChain) writeDelegationsByDelegator(
        batch r<span class="cov8" title="1">awdb.DatabaseWriter,
        delegator common.Address,
        indices []staking.DelegationIndex,
) error {
</span>        if err := rawdb.WriteDelegationsByDelegator(
                </span>batch, delegator, indices,
        <span class="cov8" title="1">); err != nil {
                return err
</span>        }
        b</span>ytes, err := rlp.EncodeToBytes(indices)
        <span class="cov8" title="1">if err == </span>nil {
                bc.validatorListByDelegatorCache.Add(string(delegator.Bytes()), bytes)
        }
        return nil
}

// UpdateStakingMetaData updates the metadata of validators and delegations,
// including the full validator list and delegation indexes.
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateStakingMetaData(
        batch rawdb.DatabaseWriter, block *types.Block,
        stakeMsgs []st</span><span class="cov0" title="0">aking.StakeMsg,
        state *state.DB, epoch, newEpoch *big.Int,
) (newValidators []common.Address, err error) {
        n</span>ewValidators, newDelegations, err := bc.prepareStakingMetaData(block, stakeMsgs, state)
        if err != nil {
        <span class="cov8" title="1">        utils.Logger().Warn().Msg</span><span class="cov0" title="0">f("oops, prepareStakingMetaData failed, err: %+v", err)
                return newValidators, err
        }
</span>
        if</span> len(newValidators) &gt; 0 {
                list, err := bc.ReadValidatorList()
                <span class="cov0" title="0">if err != nil {
                        return newValidators, err</span><span class="cov0" title="0">
                }

</span>                valMap := map[common.Address]struct{}{}
                <span class="cov0" title="0">for _, addr := range list {
                        valMap[addr] = struct{}{}
</span>                }
</span>
                ne</span>wAddrs := []common.Address{}
                for _, addr := range newValidators {
                        if _, ok := valMap[addr]; !ok {
                        <span class="cov0" title="0">        newAddrs = append(newAddrs, addr)
                        }
</span>
                        /</span>/ Update validator snapshot for the new validator
                        validator, err := state.ValidatorWrapper(addr)
                        <span class="cov0" title="0">if err != nil {
</span>                                return newValidators, err
                        }</span>

                        if err := bc.WriteValidatorSnapshot(batch, &amp;staking.ValidatorSnapshot{validator, epoch}); err != nil {
                        <span class="cov0" title="0">        return newValidators, err
</span>                        }
</span>                        // For validator created at exactly the last block of an epoch, we should create the snapshot
                        //</span> for next epoch too.
                        if newEpoch.Cmp(epoch) &gt; 0 {
                                if err := bc.WriteValidatorSnapshot(batch, &amp;staking.ValidatorSnapshot{validator, newEpoch}); err != nil {
                                        return newValidators, err
                                }
                <span class="cov0" title="0">        }
                }
</span>
                /</span>/ Update validator list
                list = append(list, newAddrs...)
                if err = bc.WriteValidatorList(batch, list); err != nil {
        <span class="cov8" title="1">                return newValidators, err
</span>                }
</span>        }

</span>        for addr, delegations := range newDelegations {
        <span class="cov8" title="1">        if err := bc.writeDelega</span>tionsByDelegator(batch, addr, delegations); err != nil {
                        return newValidators, err
                }
        }
        return newValidators, nil
}

// prepareStakingMetaData prepare the updates of validator's
// and the delegator's meta data according to staking transaction.
// The following return values are cached end state to be written to DB.
// The reason for the cached state is to solve the issue that batch DB changes
// won't be reflected immediately so the intermediary state can't be read from DB.
// newValidators - the addresses of the newly created validators
// newDelegations - the map of delegator address and their updated delegation indexes
func (bc *BlockChain) prepareStakingMetaData(
        b<span class="cov8" title="1">lock *types.Block, stakeMsgs []staking.StakeMsg, state *state.DB,
) ([]common.Address,
        map[common.Address]staking.DelegationIndexes,
        error,
) {
        var newValidators []common.Address
</span>        newDelegations := map[common.Address]staking.DelegationIndexe</span><span class="cov8" title="1">s{}
        blockNum := block.Number()
</span>        for _, stakeMsg := range stakeMsgs {
</span>                if delegate, ok := stakeMsg.(*staking.Delegate); ok {
                        if err := processDelegateMetadata(delegate,
                                newValidators,
                                newDelegations,
                                state,
</span>                                bc,
                                blo</span>ckNum); err != nil {
                                return<span class="cov8" title="1"> nil, nil, err
</span>                        }
                }
        }
        for _, txn := range block.StakingTransactions() {
                payload, err := txn.RLPEncodeStakeMsg()
                if err != nil {
</span>                        return nil, nil, err
                }
</span>                decodePayload, err := staking.RLPDecodeStakeMsg(payload, txn.StakingType())
                if err != nil {
                        return nil, nil, err
                }<span class="cov8" title="1">
</span>
                switch txn.StakingType() {
        <span class="cov8" title="1">        case staking.DirectiveCreateValidator:
</span>                        createValidator := decodePayload.(*staking.CreateValidator)
                        if err := pro</span><span class="cov0" title="0">cessCreateValidatorMetadata(createValidator,
                                &amp;newValidators,
                        </span>        newDelegations,
                <span class="cov8" title="1">                bc,
                                blockNum); e</span><span class="cov0" title="0">rr != nil {
                                return nil, nil, err
                        </span>}
                case staking.DirectiveEditValidator:
                <span class="cov8" title="1">case staking.DirectiveDel</span>egate:
                        delegate := decodePayload.(*staking.De<span class="cov8" title="1">legate)
                        if err := processDelegateMetadata(delegate,
                                newValidators,
                                newDelegations,
                                state,
                                bc,
                                blockNum); err != nil {</span><span class="cov0" title="0">
                                return nil, nil, err
                        }
</span>
</span>                case staking.DirectiveUndelegate<span class="cov8" title="1">:
                case staking.DirectiveCollectRewards:
                default:
                }
        }

        return newValidators, newDelegations, nil
}
</span>
func p</span>rocessCreateValidatorMetadata(createValidator *staking.CreateValidator,
        newValidators *[]common.Address,
        newDelegations map[common.Address]s<span class="cov0" title="0"></span>taking.DelegationIndexes,
        bc *BlockChain, blockNum *big.Int,
</span>) (err erro<span class="cov0" title="0"></span>r) {
        newList, appended := utils.AppendIfMissing(
                *newValidators, createValidator.ValidatorAddress,
        )
        <span class="cov8" title="1">if !appended {
</span>                return errValidatorExist
        }
        *newValidators = newList

        // Add self delegation into the index
        selfIndex := staking.DelegationIndex{
                createValida<span class="cov8" title="1">tor.ValidatorAddress,
                uint64(0),
                blockNum,
        }
        delegations, </span><span class="cov0" title="0">ok := newDelegations[createValidator.ValidatorAddress]
        if !ok {
                </span>// If the cache doesn't have it, load it from DB for the first time.
        <span class="cov8" title="1">        delegations, err = bc.ReadDelegationsByDelegator(createValidator.ValidatorAddress)
                if err != nil {
                        return err
                }
        }

        delegations = append(delegations, selfIndex)
        newDelegations[createValidator.ValidatorAddress] = delegations
        return nil
}
</span>
func processDelegateMetadata(delegate *staking.Delegate,
        newValidators [</span><span class="cov0" title="0">]common.Address,
        newDelegations map[common.Address]staking.DelegationIndexes,
        st</span>ate *state.DB, bc *BlockChain, blockNum *big.Int,
) (err error) {
        delegations, ok := newDelegations[delegate.DelegatorAddress]
        <span class="cov8" title="1">if !ok {
                // If the cache doesn't have it, load it from DB for the first time.
                delegatio</span>ns, err = bc.ReadDelegationsByDelegator(delegate.DelegatorAddress)
                if err != nil {
                        return err
                }
        }
        if delegations, err = bc.addDelegationIndex(
                delegations, delegate.DelegatorAddress, delegate.ValidatorAddress, state, blockNum,
        ); err != nil<span class="cov8" title="1"> {
                return err
        }
</span>        newDelegations[delegate.DelegatorAddress] = delegations
        return nil
}
</span>
// </span>ReadBlockRewardAccumulator must only be called on beaconchain
// Note that block rewards are only for staking era.
f<span class="cov8" title="1">unc (bc *BlockChain) ReadBlockRewardAccumulator(number uint64) (*big.Int, error) {
        if !bc.chainConfig.IsStaking(shard.Schedule.CalcEpochNumber(number)) {
                return big.Ne</span><span class="cov0" title="0">wInt(0), nil
        }
        i</span>f cached, ok := bc.blockAccumulatorCache.Get(number); ok {
        <span class="cov8" title="1">        return cached.(*big.Int), nil
        }
</span>        return rawdb.ReadBlockRewardAccumulator(bc.db, number)
}

// WriteBlockRewardAccumulator directly writes the BlockRewardAccumulator value
// Note: this should only be called once during staking launch.
func (bc *BlockChain) WriteBlockRewardAccumulator(
</span>        batch rawdb.DatabaseWriter, reward *big.Int, number uint64,
) </span>error {
        <span class="cov0" title="0">if err := rawdb.WriteBlockRewardAccumulator(
</span>                batch, reward, number,
        )</span>; err != nil {
        <span class="cov0" title="0">        return err
</span>        }
        bc.blockAccumulatorCache.Add(number, reward)
        return nil
}

// UpdateBlockRewardAccumulator ..
// Note:<span class="cov8" title="1"> this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateBlockRewardAccumulator(
        batch rawdb.DatabaseWriter, diff *big.Int, number uint64,
) error {
</span>        current, err := bc.ReadBlockRewardAccumulator(number - 1)
        i</span>f err != nil {
        <span class="cov8" title="1">        // one-off fix for pangaea, return after pangaea enter staking.
                current =</span> big.NewInt(0)
                bc.WriteBlockRewardAccumulator(batch, current, number)
        }
        return bc.WriteBlockRewardAccumulator(batch, new(big.Int).Add(current, diff), number)
}

// Note this should read from the state of current block in concern (root == newBlock.root)
func (bc<span class="cov0" title="0"> *BlockChain) addDelegationIndex(
        delegations staking.DelegationIndexes,
        delegatorAddre</span><span class="cov0" title="0">ss, validatorAddress common.Address, state *state.DB, blockNum *big.Int,
) (staking.DelegationIndexes, error) {
        // If there is an existing delegation, just return
        validatorAddressBytes := validatorAddress.Bytes()
        f</span>or _, delegation := range delegations {
        <span class="cov0" title="0">        if bytes.Equal(delegation.ValidatorAddress[:], validatorAddressBytes[:]) {
</span>                        return delegations, nil
                }
        }

        // Found the delegation from state and add the delegation index
        // Note this should read from the state of current block in concern
        wrapper, err := state.ValidatorWrapp<span class="cov8" title="1">er(validatorAddress)
        if err != nil {
                return delegations, err
        }
</span>        for i := range wrapper.Delegations {
</span>                if bytes.Equal(
                        </span>wrapper.Delegations[i].DelegatorAddress[:], delegatorAddress[:],
                ) {
                        // TODO(audit): change the way of indexing if we allow delegation deletion.
                        delegations = append(delegations, staking.DelegationIndex{
                                validatorAddress,
        <span class="cov0" title="0">                        uint64(i),
                                blockNum,
</span>                        })
                </span>}
        <span class="cov0" title="0">}
</span>        return delegations, nil
}

</span>// ValidatorCandidates returns the up to date validator candidates for next epoch
func (bc *BlockChain) ValidatorCandidates() []common.Address {
        list, err := bc.ReadValidatorList()
        if err != nil {
                return make([]common.Address, 0)
        }
        re</span>turn list
}

</span>// DelegatorsInformation returns up to date information of delegators of a given validator address
func (bc *BlockChain) DelegatorsInformation(addr common.Address) []*staking.Delegation {
        return make([]*staking.Delegation, 0)
}

// GetECDSAFrom</span><span class="cov0" title="0">Coinbase retrieve corresponding ecdsa address from Coinbase Address
// TODO: optimize this func by adding cache etc.
fu</span>nc (bc *BlockChain) GetECDSAFromCoinbase(header *block.Header) (common.Address, error) {
        <span class="cov0" title="0">// backward</span> compatibility: before isStaking epoch, coinbase address is the ecdsa address
        coinbase := header.Coinbase()
        isStaking := bc.Config().IsStaking(header.Epoch())
        if !isStaking {
                return coinbase, nil
        }

</span>        shardState, err := bc.ReadShardState(header.Epoch())
        if err != nil {
                return common.Address{}, errors.Wrapf(
                        err, "cannot read shard state",
                )
        }

        committee, err</span><span class="cov8" title="1"> := shardState.FindCommitteeByID(header.ShardID())
        if err != nil {
                </span>return common.Address{}, errors.Wrapf(
                        err, "cannot find shard in the shard state",
        <span class="cov0" title="0">        )
        }
</span>        for _, member := range committee.Slots {
                // After staking the coinbase address will be the address of bls public key
                if bytes.Equal(member.EcdsaAddress[:], coinbase[:]) {
                </span>        return member.EcdsaAddress, nil
                }

                if utils.GetA</span><span class="cov0" title="0">ddressFromBLSPubKeyBytes(member.BLSPublicKey[:]) == coinbase {
                        return member.EcdsaAddress, nil
                }
        }
        r</span>eturn common.Address{}, errors.Errorf(
        <span class="cov0" title="0">        "cannot find corresponding ECDSA Addre</span><span class="cov0" title="0">ss for coinbase %s",
                header.Coinbase().Hash().Hex(),
        )
</span>}

</span>// SuperCommitteeForNextEpoch ...
//<span class="cov0" title="0"> isVerify=true means validators use it to verify
</span>// isVerify=false means leader is to propose
fun</span>c (bc *BlockChain) SuperCommitteeForNextEpoch(
        beacon consensus_engine.ChainReader,
        <span class="cov0" title="0">header *block.Header,
        isVerify bool,
) (*shard.State, error) {
        v</span>ar (
                nextCommittee = new(shard.State)
                err           error
                beaconEpoch   = new(big.Int)
                shardState    = shard.State{}
        )
        switch header.ShardID() {
        case shard.BeaconChainShardID:
                if shard.Schedule.IsLastBlock(header.Number().Uint64()) {
                        nextCommittee, err = committee.WithStakingEnabled.Compute(
                                new(big.Int).Add(hea<span class="cov0" title="0">der.Epoch(), common.Big1),
                                beacon,
                        )
                }
        default:
                // TODO: needs to make sure beacon chain sync works.
                if isVerify {
                        //verify
</span>                        shardState, err = header.Get<span class="cov0" title="0">ShardState()
                        if err != nil {
</span>                                return &amp;shard.State{}, err
                        }
                        // before staking epoch
                        if shardState.Epoch == nil {
                        </span>        beaconEpoch = new(big.Int).Add(header.Epoch(), common.Big1)
                        } else<span class="cov0" title="0"> { // after staking epoch
                                beaconEpoch = shardState.Epoch
                        }
</span>                } else {
                        //propose
                        beaconEpoch = </span><span class="cov0" title="0">beacon.CurrentHeader().Epoch()
                }
                ut</span>ils.Logger().Debug().Msgf("[SuperCommitteeCalculation] isVerify: %+v, realBeaconEpoch:%+v, beaconEpoch: %+v, headerEpoch:%+v, shardStateEpoch:%+v",
                        isVerify, beacon.CurrentHeader().Epoch(), beaconEpoch, header.Epoch(), shardState.Epoch)
                n<span class="cov0" title="0">extEpoch := new(big.Int).Ad</span><span class="cov0" title="0">d(header.Epoch(), common.Big1)
                if bc.Config().IsStaking(nextEpoch) {
                        /</span>/ If <span class="cov0" title="0">next epoch is staking epoch, I should wait and listen for beacon chain for epoch changes
                        switch beaconEpoch.Cmp(header.Epoch()) {
                        c</span>ase 1:
                                // I<span class="cov0" title="0">f beacon chain is bigger than shard chain in epoch, it means I should catch up with beacon chain now
                                nextCommittee, err = committee.WithStakingEnabled.ReadFromDB(
                                        beaconEpoch, beacon,
                        </span>        )

                                utils.Logger().Debug().
                                        Uint64("blockNum", header.Number().Uint64()).
                                        Uint64("myCurEpoch", header.Epoch</span><span class="cov0" title="0">().Uint64()).
                                        Uint64("beaconEpoch", beaconEpoch.Uint64()).
                                        Msg("Propose new epoch as beacon chai</span>n's epoch")
                        case 0:<span class="cov0" title="0">
                                // If it's same epoch, no need to propose new shard state (new epoch change)
                        case -1:
                                // If beacon chain is behind, shard chain should wait for the beacon chain by not changing epochs.
                        }
                } else {
                        if bc.Config().IsStaking(beaconEpoch) {
                                // If I am not even in the last epoch before staking epoch and beacon chain is already in staking epoch,
                                // I should just catch up with beacon chain's epoch
                                nextCommittee, err = committee.WithStakingEnabled.ReadFromDB(
                                        beaconEpoch, beacon,
</span>                                )
</span>
                                utils.L<span class="cov0" title="0"></span>ogger().Debug().
                                        Uint64("blockNum", header.Number().Uint64()).
                                        Uint64("myCurEpoch", header.Epoch().Uint64()).
                                        Uin<span class="cov0" title="0">t64("beaconEpoch", beaconEpoch.Uint64()).
                                        Msg("Propose entering staking along </span><span class="cov0" title="0">with beacon chain's epoch")
                        } else {
                                // If I are not in staking nor has beacon chain proposed a staking-based shard state,
                                // do pre-staking committee calculation
                                if shard.Schedule.IsLastBlock(header.Number().Uint64()) {
                                        nextCommittee, err = committee.WithStakingEnabled.Compute(
                                                nextEpoch,
                                                bc,
                                        )
                                }
                        }
                }

</span>        }
        return nextCommittee, err
}
</span>
var (
        leveldbErrSpec         = "leveldb"
        tooManyOpenFilesErrStr = "Too many open files"
)
</span>
// isUnrecoverableErr check whether the input error is not recoverable.
// When writing db, there could be some possible errors from storage level (leveldb).
// Known possible leveldb errors are:
/<span class="cov0" title="0">/  1. Leveldb is already </span>closed. (leveldb.ErrClosed)
//  2. ldb file missing from disk. (leveldb.ErrNotFound)
//  3. Corrupted db data. (leveldb.errors.ErrCorrupted)
//  4. OS error when open file (too many open files, ...)
//  5. OS error when write file (read-only, not enough disk space, ...)
// Among all the above leveldb errors, only `too many open files` error is known to be recoverable,
// thus the unrecoverable errors refers to error that is
//  1. The error is from the lower storage level (from module leveldb)
//  2. The error is not too many files error.
func isUnrecoverableErr(err error) bool {
        isLeveldbErr := strings.Contains(err.Error(), leveldbErrSpec)
        isTooManyOpenFiles := strings.Contains(err.Error(), tooManyOpenFilesErrStr)
        return isLeveldbErr &amp;&amp; !isTooManyOpenFiles
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "bytes"
        "errors"
        "math/big"
        "sort"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        staking "github.com/harmony-one/harmony/staking"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
)

// ChainContext supports retrieving headers and consensus parameters from the
// current blockchain to be used during transaction processing.
type ChainContext interface {
        // Engine retrieves the chain's consensus engine.
        Engine() consensus_engine.Engine

        // GetHeader returns the hash corresponding to their hash.
        GetHeader(common.Hash, uint64) *block.Header

        // ReadDelegationsByDelegator returns the validators list of a delegator
        ReadDelegationsByDelegator(common.Address) (stakingTypes.DelegationIndexes, error)

        // ReadValidatorSnapshot returns the snapshot of validator at the beginning of current epoch.
        ReadValidatorSnapshot(common.Address) (*stakingTypes.ValidatorSnapshot, error)

        // ReadValidatorList returns the list of all validators
        ReadValidatorList() ([]common.Address, error)

        // Config returns chain config
        Config() *params.ChainConfig

        ShardID() uint32 // this is implemented by blockchain.go already
}

// NewEVMContext creates a new context for use in the EVM.
func NewEVMContext(msg Message, header *block.Header, chain ChainContext, author *common.Address) vm.Context <span class="cov8" title="1">{
        // If we don't have an explicit author (i.e. not mining), extract from the header
        var beneficiary common.Address
        if author == nil </span><span class="cov8" title="1">{
                beneficiary = common.Address{} // Ignore error, we're past header validation
        }</span> else<span class="cov8" title="1"> {
                beneficiary = *author
        }</span>
        <span class="cov8" title="1">vrf := common.Hash{}
        if len(header.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                vrfAndProof := header.Vrf()
                copy(vrf[:], vrfAndProof[:32])
        }</span>
        <span class="cov8" title="1">return vm.Context{
                CanTransfer:     CanTransfer,
                Transfer:        Transfer,
                IsValidator:     IsValidator,
                GetHash:         GetHashFn(header, chain),
                GetVRF:          GetVRFFn(header, chain),
                CreateValidator: CreateValidatorFn(header, chain),
                EditValidator:   EditValidatorFn(header, chain),
                Delegate:        DelegateFn(header, chain),
                Undelegate:      UndelegateFn(header, chain),
                CollectRewards:  CollectRewardsFn(header, chain),
                Origin:          msg.From(),
                Coinbase:        beneficiary,
                BlockNumber:     header.Number(),
                EpochNumber:     header.Epoch(),
                VRF:             vrf,
                Time:            header.Time(),
                GasLimit:        header.GasLimit(),
                GasPrice:        new(big.Int).Set(msg.GasPrice()),
                ShardID:         chain.ShardID(),
        }</span>
}

// HandleStakeMsgFn returns a function which accepts
// (1) the chain state database
// (2) the processed staking parameters
// the function can then be called through the EVM context
func CreateValidatorFn(ref *block.Header, chain ChainContext) vm.CreateValidatorFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, createValidator *stakingTypes.CreateValidator) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndCreateValidatorFromMsg(
                        db, chain, ref.Epoch(), ref.Number(), createValidator,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := db.UpdateValidatorWrapper(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">db.SetValidatorFlag(createValidator.ValidatorAddress)
                db.SubBalance(createValidator.ValidatorAddress, createValidator.Amount)
                return nil</span>
        }
}

func EditValidatorFn(ref *block.Header, chain ChainContext) vm.EditValidatorFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, editValidator *stakingTypes.EditValidator) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndEditValidatorFromMsg(
                        db, chain, ref.Epoch(), ref.Number(), editValidator,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return db.UpdateValidatorWrapper(wrapper.Address, wrapper)</span>
        }
}

func DelegateFn(ref *block.Header, chain ChainContext) vm.DelegateFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, delegate *stakingTypes.Delegate) error </span><span class="cov8" title="1">{
                delegations, err := chain.ReadDelegationsByDelegator(delegate.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers, balanceToBeDeducted, fromLockedTokens, err := VerifyAndDelegateFromMsg(
                        db, ref.Epoch(), delegate, delegations, chain.Config())
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, wrapper := range updatedValidatorWrappers </span><span class="cov8" title="1">{
                        if err := db.UpdateValidatorWrapper(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">db.SubBalance(delegate.DelegatorAddress, balanceToBeDeducted)

                if len(fromLockedTokens) &gt; 0 </span><span class="cov8" title="1">{
                        sortedKeys := []common.Address{}
                        for key := range fromLockedTokens </span><span class="cov8" title="1">{
                                sortedKeys = append(sortedKeys, key)
                        }</span>
                        <span class="cov8" title="1">sort.SliceStable(sortedKeys, func(i, j int) bool </span><span class="cov0" title="0">{
                                return bytes.Compare(sortedKeys[i][:], sortedKeys[j][:]) &lt; 0
                        }</span>)
                        // Add log if everything is good
                        <span class="cov8" title="1">for _, key := range sortedKeys </span><span class="cov8" title="1">{
                                redelegatedToken, ok := fromLockedTokens[key]
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.New("Key missing for delegation receipt")
                                }</span>
                                <span class="cov8" title="1">encodedRedelegationData := []byte{}
                                addrBytes := key.Bytes()
                                encodedRedelegationData = append(encodedRedelegationData, addrBytes...)
                                encodedRedelegationData = append(encodedRedelegationData, redelegatedToken.Bytes()...)
                                // The data field format is:
                                // [first 20 bytes]: Validator address from which the locked token is used for redelegation.
                                // [rest of the bytes]: the bigInt serialized bytes for the token amount.
                                db.AddLog(&amp;types.Log{
                                        Address:     delegate.DelegatorAddress,
                                        Topics:      []common.Hash{staking.DelegateTopic},
                                        Data:        encodedRedelegationData,
                                        BlockNumber: ref.Number().Uint64(),
                                })</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }
}

func UndelegateFn(ref *block.Header, chain ChainContext) vm.UndelegateFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, undelegate *stakingTypes.Undelegate) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndUndelegateFromMsg(db, ref.Epoch(), undelegate)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return db.UpdateValidatorWrapper(wrapper.Address, wrapper)</span>
        }
}

func CollectRewardsFn(ref *block.Header, chain ChainContext) vm.CollectRewardsFunc <span class="cov8" title="1">{
        return func(db vm.StateDB, collectRewards *stakingTypes.CollectRewards) error </span><span class="cov8" title="1">{
                if chain == nil </span><span class="cov0" title="0">{
                        return errors.New("[CollectRewards] No chain context provided")
                }</span>
                <span class="cov8" title="1">delegations, err := chain.ReadDelegationsByDelegator(collectRewards.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers, totalRewards, err := VerifyAndCollectRewardsFromDelegation(
                        db, delegations,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, wrapper := range updatedValidatorWrappers </span><span class="cov8" title="1">{
                        if err := db.UpdateValidatorWrapper(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">db.AddBalance(collectRewards.DelegatorAddress, totalRewards)

                // Add log if everything is good
                db.AddLog(&amp;types.Log{
                        Address:     collectRewards.DelegatorAddress,
                        Topics:      []common.Hash{staking.CollectRewardsTopic},
                        Data:        totalRewards.Bytes(),
                        BlockNumber: ref.Number().Uint64(),
                })

                return nil</span>
        }
}

// GetHashFn returns a GetHashFunc which retrieves header hashes by number
func GetHashFn(ref *block.Header, chain ChainContext) func(n uint64) common.Hash <span class="cov8" title="1">{
        var cache map[uint64]common.Hash

        return func(n uint64) common.Hash </span><span class="cov0" title="0">{
                // If there's no hash cache yet, make one
                if cache == nil </span><span class="cov0" title="0">{
                        cache = map[uint64]common.Hash{
                                ref.Number().Uint64() - 1: ref.ParentHash(),
                        }
                }</span>
                // Try to fulfill the request from the cache
                <span class="cov0" title="0">if hash, ok := cache[n]; ok </span><span class="cov0" title="0">{
                        return hash
                }</span>
                // Not cached, iterate the blocks and cache the hashes
                <span class="cov0" title="0">for header := chain.GetHeader(ref.ParentHash(), ref.Number().Uint64()-1); header != nil; header = chain.GetHeader(header.ParentHash(), header.Number().Uint64()-1) </span><span class="cov0" title="0">{
                        cache[header.Number().Uint64()-1] = header.ParentHash()
                        if n == header.Number().Uint64()-1 </span><span class="cov0" title="0">{
                                return header.ParentHash()
                        }</span>
                }
                <span class="cov0" title="0">return common.Hash{}</span>
        }
}

// GetVRFFn returns a GetVRFFn which retrieves header vrf by number
func GetVRFFn(ref *block.Header, chain ChainContext) func(n uint64) common.Hash <span class="cov8" title="1">{
        var cache map[uint64]common.Hash

        return func(n uint64) common.Hash </span><span class="cov0" title="0">{
                // If there's no hash cache yet, make one
                if cache == nil </span><span class="cov0" title="0">{
                        curVRF := common.Hash{}
                        if len(ref.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                                vrfAndProof := ref.Vrf()
                                copy(curVRF[:], vrfAndProof[:32])
                        }</span>

                        <span class="cov0" title="0">cache = map[uint64]common.Hash{
                                ref.Number().Uint64(): curVRF,
                        }</span>
                }
                // Try to fulfill the request from the cache
                <span class="cov0" title="0">if hash, ok := cache[n]; ok </span><span class="cov0" title="0">{
                        return hash
                }</span>
                // Not cached, iterate the blocks and cache the hashes
                <span class="cov0" title="0">for header := chain.GetHeader(ref.ParentHash(), ref.Number().Uint64()-1); header != nil; header = chain.GetHeader(header.ParentHash(), header.Number().Uint64()-1) </span><span class="cov0" title="0">{

                        curVRF := common.Hash{}
                        if len(header.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                                vrfAndProof := header.Vrf()
                                copy(curVRF[:], vrfAndProof[:32])
                        }</span>

                        <span class="cov0" title="0">cache[header.Number().Uint64()] = curVRF

                        if n == header.Number().Uint64() </span><span class="cov0" title="0">{
                                return curVRF
                        }</span>
                }
                <span class="cov0" title="0">return common.Hash{}</span>
        }
}

// CanTransfer checks whether there are enough funds in the address' account to make a transfer.
// This does not take the necessary gas in to account to make the transfer valid.
func CanTransfer(db vm.StateDB, addr common.Address, amount *big.Int) bool <span class="cov8" title="1">{
        return db.GetBalance(addr).Cmp(amount) &gt;= 0
}</span>

// IsValidator determines whether it is a validator address or not
func IsValidator(db vm.StateDB, addr common.Address) bool <span class="cov8" title="1">{
        return db.IsValidator(addr)
}</span>

// Transfer subtracts amount from sender and adds amount to recipient using the given Db
func Transfer(db vm.StateDB, sender, recipient common.Address, amount *big.Int, txType types.TransactionType) <span class="cov8" title="1">{
        if txType == types.SameShardTx || txType == types.SubtractionOnly </span><span class="cov8" title="1">{
                db.SubBalance(sender, amount)
        }</span>
        <span class="cov8" title="1">if txType == types.SameShardTx </span><span class="cov8" title="1">{
                db.AddBalance(recipient, amount)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "bytes"
        "math/big"

        "github.com/harmony-one/harmony/staking/availability"

        "github.com/harmony-one/harmony/internal/params"

        "github.com/harmony-one/harmony/crypto/bls"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/common/denominations"
        "github.com/harmony-one/harmony/core/vm"
        common2 "github.com/harmony-one/harmony/internal/common"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/staking/effective"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var (
        errStateDBIsMissing    = errors.New("no stateDB was provided")
        errChainContextMissing = errors.New("no chain context was provided")
        errEpochMissing        = errors.New("no epoch was provided")
        errBlockNumMissing     = errors.New("no block number was provided")
)

func checkDuplicateFields(
        bc ChainContext, state vm.StateDB,
        validat<span class="cov8" title="1">or common.Address, identity string, blsKeys []bls.SerializedPublicKey,
) error {
        addrs, err := </span><span class="cov8" title="1">bc.ReadValidatorList()
        if err != nil {
                </span>return err
        }

        checkIdentity := identity != ""
        checkBlsKeys := len(blsKeys) != 0

        blsKeyMap := map[bls.Seriali</span><span class="cov8" title="1">zedPublicKey]struct{}{}
        for _, key := range blsKeys {
                </span>blsKeyMap[key] = struct{}{}
        }

</span>        for _, addr := range addrs {
</span>                if !bytes.Equal(validator.Bytes(), addr.Bytes()) {
                        wrapper, err := state.ValidatorWrapperCopy(addr)

</span>                        if err != nil {
                                </span>return err
                        }

</span>                        if checkIdentity &amp;&amp; wrapper.Identity == identity {
                                </span>return errors.Wrapf(errDupIdentity, "duplicate identity %s", identity)
                        <span class="cov8" title="1">}
</span>                        if checkBlsKeys {
</span>                                for _, existingKey := range wrapper.Slot</span><span class="cov8" title="1">PubKeys {
                                        if _, ok := blsKeyMap[existingKey]; ok {
                                                </span>return errors.Wrapf(errDupBlsKey, "duplicate bls key %x", existingKey)
                                        }
                                }
                        }
                }
        <span class="cov8" title="1">}
</span>        return nil
}

// TODO: add unit tests to check staking msg verification

// VerifyAndCreateValidatorFromMsg verifies the create validator message using
// the stateDB, epoch, &amp; blocknumber and returns the validatorWrapper created
// in the process.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndCreateValidatorFromMsg(
        stateDB vm.StateDB, chainContext Cha<span class="cov8" title="1">inContext, epoch *big.Int, blockNum *big.Int, msg *staking.CreateValidator,
) (*staking.Validat</span><span class="cov8" title="1">orWrapper, error) {
        if stateDB == nil {
                </span>return nil, errStateDBIsMissing
        <span class="cov8" title="1">}
</span>        if chainContext == nil {
                </span>return nil, errChainContextMissing
        <span class="cov8" title="1">}
</span>        if epoch == nil {
                </span>return nil, errEpochMissing
        <span class="cov8" title="1">}
</span>        if blockNum == nil {
                </span>return nil, errBlockNumMissing
        <span class="cov8" title="1">}
</span>        if msg.Amount.Sign() == -1 {
                </span>return nil, errNegativeAmount
        <span class="cov8" title="1">}
</span>        if stateDB.IsValidator(msg.ValidatorAddress) {
                return nil, errors.Wrapf(
                        errValidatorExist, common2.MustAddressToBech32(msg.ValidatorAddress),
                </span>)
        <span class="cov8" title="1">}
        if err := checkDuplicateFields(
                chainContext, stateDB,
                msg.ValidatorAddress,
                msg.Identity,
</span>                msg.SlotPubKeys); err != nil {
                </span>return nil, err
        <span class="cov8" title="1">}
</span>        if !CanTransfer(stateDB, msg.ValidatorAddress, msg.Amount) {
                </span>return nil, errInsufficientBalanceForStake
        <span class="cov8" title="1">}
        v, err := stak</span><span class="cov8" title="1">ing.CreateValidatorFromNewMsg(msg, blockNum, epoch)
        if err != nil {
                </span>return nil, err
        <span class="cov8" title="1">}
        wrapper := &amp;staking.ValidatorWrapper{}
        wrapper.Validator = *v
        wrapper.Delegations = []staking.Delegation{
                staking.NewDelegation(v.Address, msg.Amount),
        }
        wrapper.Counters.NumBlocksSigned = big.NewInt(0)
        wrapper.Counters.NumBlocksToSign = big.NewInt(0)
        wrapper.BlockReward = big.NewInt(0)
        // if there is a contract at this address, its code should be retained
        // so far there has been no writing to this address, so the code is available
        // via a simple call
        wrapper.ContractCode = stateDB.GetCode(msg.V</span><span class="cov8" title="1">alidatorAddress)
        if err := wrapper.SanityCheck(); err != nil {
                </span>return nil, err
        <span class="cov8" title="1">}
</span>        return wrapper, nil
}

// VerifyAndEditValidatorFromMsg verifies the edit validator message using
// the stateDB, chainContext and returns the edited validatorWrapper.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndEditValidatorFromMsg(
        stateDB vm.StateDB, chainContext ChainContext,
        epoch, blockNum *big.Int, msg *staki<span class="cov8" title="1">ng.EditValidator,
) (*staking.Validat</span><span class="cov8" title="1">orWrapper, error) {
        if stateDB == nil {
                </span>return nil, errStateDBIsMissing
        <span class="cov8" title="1">}
</span>        if chainContext == nil {
                </span>return nil, errChainContextMissing
        <span class="cov8" title="1">}
</span>        if blockNum == nil {
                </span>return nil, errBlockNumMissing
        <span class="cov8" title="1">}
</span>        if !stateDB.IsValidator(msg.ValidatorAddress) {
                </span>return nil, errValidatorNotExist
        <span class="cov8" title="1">}
        newBlsKeys := []bls.Seriali</span><span class="cov8" title="1">zedPublicKey{}
        if msg.SlotKeyToAdd != nil {
                </span>newBlsKeys = append(newBlsKeys, *msg.SlotKeyToAdd)
        <span class="cov8" title="1">}
        if err := checkDuplicateFields(
                chainContext, stateDB,
                msg.ValidatorAddress,
                msg.Identity,
</span>                newBlsKeys); err != nil {
                </span>return nil, err
        <span class="cov8" title="1">}
        wrapper, err :</span><span class="cov8" title="1">= stateDB.ValidatorWrapperCopy(msg.ValidatorAddress)
        if err != nil {
                </span>return nil, err
        <span class="cov8" title="1">}
</span>        if err := staking.UpdateValidatorFromEditMsg(&amp;wrapper.Validator, msg, epoch); err != nil {
                </span>return nil, err
        <span class="cov8" title="1">}
        newRate := wrapper.Validator.Rate
</span>        if newRate.GT(wrapper.Validator.MaxRate) {
                </span>return nil, errCommissionRateChangeTooHigh
        }

</span>        if chainContext.Config().IsMinCommissionRate(epoch) &amp;&amp; newRate.LT(availability.MinCommissionRate) {
                firstEpoch := stateDB.GetValidatorFirstElectionEpoch(msg.ValidatorAddress)
                promoPeriod := chainContext.Config().MinCommissionPromoPeriod.Int64()
</span>                if firstEpoch.Uint64() != 0 &amp;&amp; big.NewInt(0).Sub(epoch, firstEpoch).Int64() &gt;= promoPeriod {
                        </span>return nil, errCommissionRateChangeTooLow
                }
        }

        snapshotValida</span><span class="cov8" title="1">tor, err := chainContext.ReadValidatorSnapshot(wrapper.Address)
        if err != nil {
                </span>return nil, errors.WithMessage(err, "validator snapshot not found.")
        <span class="cov8" title="1">}
        rateAtBeginningOfEpoch := snapshotValidator.Validator.Rate

        if rateAtBeginningOfEpoch.IsNil() ||
</span>                (!newRate.IsNil() &amp;&amp; !rateAtBeginningOfEpoch.Equal(newRate)) {
                </span>wrapper.Validator.UpdateHeight = blockNum
        }

        if newRate.Sub(rateAtBeginningOfEpoch).Abs().GT(
                w</span><span class="cov8" title="1">rapper.Validator.MaxChangeRate,
        ) {
                </span>return nil, errCommissionRateChangeTooFast
        <span class="cov8" title="1">}
</span>        if err := wrapper.SanityCheck(); err != nil {
                </span>return nil, err
        <span class="cov8" title="1">}
</span>        return wrapper, nil
}

const oneThousand = 1000
const oneHundred = 100

var (
        oneAsBigInt             = big.NewInt(denominations.One)
        minimumDelegation       = new(big.Int).Mul(oneAsBigInt, big.NewInt(oneThousand))
        minimumDelegationV2     = new(big.Int).Mul(oneAsBigInt, big.NewInt(oneHundred))
        errDelegationTooSmall   = errors.New("minimum delegation amount for a delegator has to be greater than or equal to 1000 ONE")
        errDelegationTooSmallV2 = errors.New("minimum delegation amount for a delegator has to be greater than or equal to 100 ONE")
)

// VerifyAndDelegateFromMsg verifies the delegate message using the stateDB
// and returns the balance to be deducted by the delegator as well as the
// validatorWrapper with the delegation applied to it.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndDelegateFromMsg(
        stateDB vm.StateDB, epoch *big.Int, msg *staking.Delegate, delegations []stak<span class="cov8" title="1">ing.DelegationIndex, chainConfig *params.ChainConfig,
) ([]*staking.Valid</span><span class="cov8" title="1">atorWrapper, *big.Int, map[common.Address]*big.Int, error) {
        if stateDB == nil {
                </span>return nil, nil, nil, errStateDBIsMissing
        <span class="cov8" title="1">}
</span>        if !stateDB.IsValidator(msg.ValidatorAddress) {
                </span>return nil, nil, nil, errValidatorNotExist
        <span class="cov8" title="1">}
</span>        if msg.Amount.Sign() == -1 {
                </span>return nil, nil, nil, errNegativeAmount
        <span class="cov8" title="1">}
</span>        if msg.Amount.Cmp(minimumDelegation) &lt; 0 {</span><span class="cov8" title="1">
                if chainConfig.IsMinDelegation100(epoch) {
</span>                        if msg.Amount.Cmp(minimumDelegationV2) &lt; 0 {
                                </span>return nil, nil, nil, errDelegationTooSmallV2
                        }
                } else {
                        </span>return nil, nil, nil, errDelegationTooSmall
                }
        }

        updatedValidatorWrappers := []*staking.ValidatorWrapper{}
        delegateBalance := big.NewInt(0).Set(msg.Amount)
        fromLockedTokens := map[common.Address]*big.Int{}

        var delegateeWrapper *staking.Validat</span><span class="cov8" title="1">orWrapper
        if chainConfig.IsRedelegation(epoch) {
                // Check if we can use toke</span><span class="cov8" title="1">ns in undelegation to delegate (redelegate)
                for i := range delegations {
                        delegationIndex := &amp;delegations[i]
                        wrapper, err :</span><span class="cov0" title="0">= stateDB.ValidatorWrapperCopy(delegationIndex.ValidatorAddress)
                        if err != nil {
                                </span>return nil, nil, nil, err
                        <span class="cov8" title="1">}
</span>                        if uint64(len(wrapper.Delegations)) &lt;= delegationIndex.Index {
                                utils.Logger().Warn().
                                        Str("validator", delegationIndex.ValidatorAddress.String()).
                                        Uint64("delegation index", delegationIndex.Index).
                                        Int("delegations length", len(wrapper.Delegations)).
                                        Msg("Delegation index out of bound")
                                </span>return nil, nil, nil, errors.New("Delegation index out of bound")
                        }

                        delegation := &amp;wrapper.Delegations[delegationIndex.Index]

                        startBalance := big.NewInt(0).Set(delegateBalance)
                        // Start from the oldest undelegated tokens
                        curIndex := 0
</span>                        for ; curIndex &lt; len(delegation.Undelegations); curIndex++ {
</span>                                if del</span>egation.Undelegations[curIndex].Epoch.Cmp(epoch) &gt;= 0 {
                                        break
                                <span class="cov8" title="1">}
</span>                                if delegation.Undelegations[curIndex].Amount.Cmp(delegateBalance) &lt;= 0 {
                                        </span>deleg<span class="cov8" title="1">ateBalance.Sub(delegateBalance, delegation.Undelegations[curIndex].Amount)
                                } else {
                                        delegation.Undelegations[curIndex].Amount.Sub(
                                                delegation.Undelegations[curIndex].Amount, delegateBalance,
                                        )
                                        deleg</span>ateBalance = big.NewInt(0)
                                        break
                                }
                        }

</span>                        if startBalance.Cmp(delegateBalance) &gt; 0 {
                                // Used undelegated token for redelegation
                                delegation.Undelegations = delegation.Undele</span><span class="cov0" title="0">gations[curIndex:]
                                if err := wrapper.SanityCheck(); err != nil {
                                        </span>return nil, nil, nil, err
                                }

</span>                                if bytes.Equal(delegationIndex.ValidatorAddress[:], msg.ValidatorAddress[:]) {
                                        </span>delegateeWrapper = wrapper
                                <span class="cov8" title="1">}
                                updatedValidatorWrappers = append(updatedValidatorWrappers, wrapper)
</span>                                fromLockedTokens[delegationIndex.ValidatorAddress] = big.NewInt(0).Sub(startBalance, delegateBalance)
                        }
                }
        }

</span>        if delegateeWrapper == nil {
                var err error
                delegateeWrapp</span><span class="cov8" title="1">er, err = stateDB.ValidatorWrapperCopy(msg.ValidatorAddress)
                if err != nil {
                        </span>return nil, nil, nil, err
                <span class="cov8" title="1">}
</span>                updatedValidatorWrappers = append(updatedValidatorWrappers, delegateeWrapper)
        }

        <span class="cov8" title="1">// Add to existing delegation if any
        found := false
</span>        for i := range delegateeWrapper.Delegations {
                delegation := &amp;delegateeWrapper.Delegations[i]
</span>                if bytes.Equal(delegation.DelegatorAddress.Bytes(), msg.DelegatorAddress.Bytes()) {
                        delegation.Amount.Add(delegation.Amount, msg.Amount)
</span>                        if err := delegateeWrapper.SanityCheck(); err != nil {
                                </span>return nil, nil, nil, err
                        <span class="cov8" title="1">}
</span>                        found = true
                }
        }

</span>        if !found {
                // Add new delegation
                delegateeWrapper.Delegations = append(
                        delegateeWrapper.Delegations, staking.NewDelegation(
                                msg.DelegatorAddress, msg.Amount,
                        ),
                )
</span>                if err := delegateeWrapper.SanityCheck(); err != nil {
                        </span>return nil, nil, nil, err
                }
        }

</span>        if delegateBalance.Cmp(big.NewInt(0)) == 0 {
                // delegation fully from undelegated tokens, no need to deduct from balance.
                </span>return updatedValidatorWrappers, big.NewInt(0), fromLockedTokens, nil
        }

        // Still need to deduct tokens from balance for delegation
        <span class="cov8" title="1">// Check if there is enough liquid token to delegate
</span>        if !CanTransfer(stateDB, msg.DelegatorAddress, delegateBalance) {
                return nil, nil, nil, errors.Wrapf(
                        errInsufficientBalanceForStake, "totalRedelegatable: %v, balance: %v; trying to stake %v",
                </span>        big.NewInt(0).Sub(msg.Amount, delegateBalance), stateDB.GetBalance(msg.DelegatorAddress), msg.Amount)
        }

</span>        return updatedValidatorWrappers, delegateBalance, fromLockedTokens, nil
}

// VerifyAndUndelegateFromMsg verifies the undelegate validator message
// using the stateDB &amp; chainContext and returns the edited validatorWrapper
// with the undelegation applied to it.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndUndelegateFromMsg(
        stateDB vm.StateDB, epoch *big.Int, <span class="cov8" title="1">msg *staking.Undelegate,
) (*staking.Validat</span><span class="cov8" title="1">orWrapper, error) {
        if stateDB == nil {
                </span>return nil, errStateDBIsMissing
        <span class="cov8" title="1">}
</span>        if epoch == nil {
                </span>return nil, errEpochMissing
        }

</span>        if msg.Amount.Sign() == -1 {
                </span>return nil, errNegativeAmount
        }

</span>        if !stateDB.IsValidator(msg.ValidatorAddress) {
                </span>return nil, errValidatorNotExist
        }

        wrapper, err :</span><span class="cov8" title="1">= stateDB.ValidatorWrapperCopy(msg.ValidatorAddress)
        if err != nil {
                </span>return nil, err
        }

</span>        for i := range wrapper.Delegations {
                delegation := &amp;wrapper.Delegations[i]
</span>                if bytes.Equal(delegation.DelegatorAddress.Bytes(), msg.Delegato</span><span class="cov8" title="1">rAddress.Bytes()) {
                        if err := delegation.Undelegate(epoch, msg.Amount); err != nil {
                                </span>return nil, err
                        <span class="cov8" title="1">}
</span>                        if err := wrapper.SanityCheck(); err != nil {
                                // allow self delegation to go below min self delegation
                                // but set the status to inactive
</span>                                if errors.Cause(err) == staking.ErrInvalidSelfDelegation {
                                        </span>wrapp<span class="cov0" title="0">er.Status = effective.Inactive
                                } else {
                                        </span>return nil, err
                                }
                        <span class="cov8" title="1">}
</span>                        return wrapper, nil
                }
        <span class="cov8" title="1">}
</span>        return nil, errNoDelegationToUndelegate
}

// VerifyAndCollectRewardsFromDelegation verifies and collects rewards
// from the given delegation slice using the stateDB. It returns all of the
// edited validatorWrappers and the sum total of the rewards.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndCollectRewardsFromDelegation(
        stateDB vm.StateDB, delegations []staking.Delega<span class="cov8" title="1">tionIndex,
) ([]*staking.Valid</span><span class="cov8" title="1">atorWrapper, *big.Int, error) {
        if stateDB == nil {
                </span>return nil, nil, errStateDBIsMissing
        <span class="cov8" title="1">}
        updatedValidatorWrappers := []*staking.ValidatorWrapper{}
        totalRewards := big.NewInt(</span><span class="cov8" title="1">0)
        for i := range delegations {
                delegation := &amp;delegations[i]
                wrapper, err :</span><span class="cov8" title="1">= stateDB.ValidatorWrapperCopy(delegation.ValidatorAddress)
                if err != nil {
                        </span>return nil, nil, err
                <span class="cov8" title="1">}
</span>                if uint64(len(wrapper.Delegations)) &gt; delegation.Index {
                        delegation := &amp;wrapper.Delegations[delegat</span><span class="cov8" title="1">ion.Index]
                        if delegation.Reward.Cmp(common.Big0) &gt; 0 {
                                totalRewards.Add(totalRewards, delegation.Reward)
                                </span>delegation.Reward.SetUint64(0)
                        }
                } else {
                        utils.Logger().Warn().
                                Str("validator", delegation.ValidatorAddress.String()).
                                Uint64("delegation index", delegation.Index).
                                Int("delegations length", len(wrapper.Delegations)).
                                Msg("Delegation index out of bound")
                        </span>return nil, nil, errors.New("Delegation index out of bound")
                <span class="cov8" title="1">}
</span>                updatedValidatorWrappers = append(updatedValidatorWrappers, wrapper)
        <span class="cov8" title="1">}
</span>        if totalRewards.Int64() == 0 {
                </span>return nil, nil, errNoRewardsToCollect
        <span class="cov8" title="1">}
</span>        return updatedValidatorWrappers, totalRewards, nil
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "math/big"
        "time"

        lru "github.com/hashicorp/golang-lru"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/consensus/reward"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

const (
        resultCacheLimit = 64 // The number of cached results from processing blocks
)</span>

// StateProcessor is a basic Processor, which takes care o<span class="cov8" title="1">f transitioning
// state from one point to another.
/</span>/
// StateProcessor implements Processor.
type StateProcessor struct {
        config      *params.ChainConfig     // Chain configuration options
        bc          *BlockChain             // Canonical block chain
        engine      consensus_engine.Engine // Consensus engine used for block rewards
        resultCache *lru.Cache              // Cache for result after a certain block is processed
}

// this structure is cached, and each individual element is returned
type ProcessorResult struct {
        Receipts   types.Receipts
        CxReceipts types.CXReceipts
        StakeMsgs  []staking.StakeMsg
        Logs       []*types.Log
        UsedGas    uint64<span class="cov8" title="1">
        Reward     reward.Reader
        State      *state.DB
}

// NewStateProcessor initialises a new StateProcessor.
f</span>unc NewStateProcessor(
        config *params.ChainConfig, bc *BlockChain, engine consensus_engine.Engine,
) *StateProcessor {
        resultCache, _ := lru.New(resultCacheLimit)
        return &amp;StateProcessor{
                config:      config,
                bc:          bc,
                engine:      engine,
                resultCache: resultCache,
        }
}

// Process processes the state changes according to the Ethereum rules by running
// the transaction messages using the statedb and applying any rewards to both
//<span class="cov8" title="1"> the processor (coinbase) and any included uncles.
//
// Process returns the receipts and logs accumulated during the process and
// returns the amount of gas that was used in the process. If any of the
// transactions failed to execute due to insufficient gas it will return an error.
func (p *StateProcessor) Process(
        block *types.Block, statedb *state.DB, cfg vm.Config, readCache bool,
) (
        types.Receipts, types.CXReceipts, []staking.StakeMsg,
        []*types.Log, uint64, reward.Reader, *state.DB, error,
) {
        cacheKey := block.Hash()
        if readCache {</span><span class="cov0" title="0">
                if cached, ok := p.resultCache.Get(cacheKey); ok {
                </span>        // Return the cached result to avoid process the same block again.
                        // Only the successful results are cached in case for retry.
        <span class="cov8" title="1">                result := cached.(*ProcessorResult)
                        utils.Logger().Info().Str("block num", block.Number().String()).Msg("result cache hit.")
                        return result.Receipts, result.CxRecei</span><span class="cov0" title="0">pts, result.StakeMsgs, result.Logs, result.UsedGas, result.Reward, result.State, nil
                }
        }

        var (
                receipts      </span><span class="cov0" title="0"> types.Receipts
                outcxs         types.CXReceipts
                i</span>ncxs          = block.IncomingReceipts()
                <span class="cov0" title="0">usedGas        = new(uint64)
                header         = blo</span><span class="cov0" title="0">ck.Header()
                allLogs        []*types.Log
                g</span>p             = new(GasPool).AddGas(block.GasLimit())
                <span class="cov0" title="0">blockStakeMsgs []staking.StakeMsg
</span>        )

        beneficiary, err := p.bc.GetECDSAFromCoinbase(header)
        if err != nil {
                return nil, nil, nil, nil, 0, nil, statedb, err
        }

</span>        startTime := time.Now()
        // Iterate over and process the individual transactions
        for i, tx := range block.Transactions() {
                statedb.Prepare(tx.Hash(), block.Hash(), i)
                receipt, cxRec</span><span class="cov0" title="0">eipt, stakeMsgs, _, err := ApplyTransaction(
                        p.config, p.bc, &amp;beneficiary, gp, statedb, header, tx, usedGas, cfg,
                )</span>
                <span class="cov0" title="0">if err != nil {
                        return nil, nil, nil, nil, 0, nil, stated</span>b, err
                }
        <span class="cov8" title="1">        receipts = append(receipts, receipt)
                if cxReceipt != nil {
                        outcxs = append(outcxs, cxReceipt)
                }
                if stakeMsgs != nil {
</span>                        blockStakeMsgs = append(blockStakeMsgs, stakeMsgs...)
                }
                allLogs = appe</span><span class="cov0" title="0">nd(allLogs, receipt.Logs...)
        }
        utils.Logger().Debug().Int64("elapsed time", time.Now().Sub(startTime).Milliseconds()).Msg("Process Normal Txns")

</span>        startTime = time.Now()
        // Iterate over and process the staking transactions
        <span class="cov8" title="1">L := len(block.Transactions())
        for i, tx := range block.StakingTrans</span><span class="cov0" title="0">actions() {
                statedb.Prepare(tx.Hash(), block.Hash(), i+L)
</span>                receipt, _, err := ApplyStakingTransaction(
                        p.config, p.bc, &amp;beneficiary, gp, statedb, header, tx, usedGas, cfg,
                )
                i</span>f err != nil {
                        return nil, nil, nil, nil, 0, nil, statedb, err
                }
                receipts = append(receipts, receipt)
        <span class="cov8" title="1">        allLogs = append(allLogs, receipt.Logs...)
        }
</span>        utils.Logger().Debug().Int64("elapsed time", time.Now().Sub(startTime).Milliseconds()).Msg("Process Staking Txns")

        /</span>/ incomingReceipts should always be processed
        <span class="cov8" title="1">// after transactions (to be consistent with the block proposal)
        for _, cx := range block.IncomingReceipts() {
                if err := ApplyIncomingReceipt(
</span></span>                        p.config, statedb, header, cx,
        <span class="cov8" title="1">        ); err != nil</span><span class="cov0" title="0"> {
                        return nil, nil,
                </span>                nil, nil, 0, nil, statedb, errors.New("[Process] Cannot apply incoming receipts")
                }
        <span class="cov8" title="1">}
</span>
        slashes := slash.Records{}
        if s := header.Slashes(); len(s) &gt; 0 {
                if err := rlp.DecodeBytes(s, &amp;slashes); err != nil {
                        return nil, nil, nil, nil, 0, nil, statedb, errors.New(
                                "[Process] Cannot fi<span class="cov8" title="1">nalize block",
                        )
                }
        }
</span>
        /</span>/ Finalize the block, applying any consensus engine specific extras (e.g. block rewards)
        <span class="cov0" title="0">sigsReady := make(chan bool)
        go func() {
                // Block processing don't need to block on reward computation as in block proposal
                sigsReady &lt;- true
        }()
</span>        _, payout, err := p.engine.Finalize(
                </span>p.bc, header, statedb, block.Transactions(),
        <span class="cov0" title="0">        receipts, outcxs, inc</span>xs, block.StakingTransactions(), slashes, sigsReady, func() uint64 { return header.ViewID().Uint64() },
        )
        if err != nil {
                return nil, nil, nil, nil, 0, nil, statedb, errors.New("[Process] Cannot finalize block")
        }

        result := &amp;ProcessorResult{
                Receipts:   receipts,
                CxReceipts: outcxs,
                StakeMsgs:  blockStakeMsgs,
</span>                Logs:       allLogs,
                </span>UsedGas:    *usedGas,
                Reward:     payout,
        <span class="cov8" title="1">        State:      statedb,
</span>        }
        p.resultCache.Add(cacheKey, result)
        return receipts, outcxs, blockStakeMsgs, allLogs, *usedGas, payout, statedb, nil
}

</span>// CacheProcessorResult caches the process result on the cache key.
f<span class="cov8" title="1">unc (p *StateProcessor) CacheProcessorResult(cacheKey interface{}, result *ProcessorResult) {
        p.resultCache.Add(cacheK</span><span class="cov0" title="0">ey, result)
}
</span>
// </span>return true if it is valid
fu<span class="cov0" title="0">nc getTransactionType(
</span>        config<span class="cov8" title="1"> *params.ChainConfig, header *block.Header, tx *types.Transaction,
) types.TransactionType {
        i</span>f header.ShardID() == tx.ShardID() &amp;&amp;
        <span class="cov8" title="1">        (!config.AcceptsCrossTx(header.Epoch()) ||
                        tx.ShardID() == tx.ToShardID()) {
                return types.SameShardTx
        }
</span>        numShards := shard.Schedule.InstanceForEpoch(header.Epoch()).NumShards()
        /</span>/ Assuming here all the shards are consecutive from 0 to n-1, n is total number of shards
        if tx.ShardID() != tx.ToShardID() &amp;&amp;
                header.ShardID() == tx.ShardID() &amp;&amp;
        <span class="cov8" title="1">        tx.ToShardID() &lt; numShards {
                return types.SubtractionOnly
        }
        return types.InvalidTx
}

// ApplyTransaction attempts to apply a transaction to the given state database
// and uses the</span><span class="cov0" title="0"> input parameters for its environment. It returns the receipt
// for the transaction, gas used and an error if the transaction failed,
//</span> indicating the block was invalid.
f<span class="cov8" title="1">unc ApplyTransaction(confi</span><span class="cov0" title="0">g *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.DB, header *block.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, *types.CXReceipt, []staking.StakeMsg, uint64, error) {
        txType := getTransactionType(config, header, tx)
        if txType == types.InvalidTx {
                </span>return nil, nil, nil, 0, errors.New("Invalid Transaction Type")
        }

        if txType != types.SameShardTx </span><span class="cov8" title="1">&amp;&amp; !config.AcceptsCrossTx(header.Epoch()) {
                return nil, nil, nil, 0, errors.Errorf(
                </span>        "can<span class="cov0" title="0">not handle cross-shard transaction until after epoch %v (now %v)",
                        config.CrossTxEpoch, header.Epoch(),
                </span>)
        <span class="cov8" title="1">}

        var signer types.Signer
        if tx.IsEthCompatible() {
                if !config.IsEthCompatible(header.Epoch()) {
                        return nil, nil, nil, 0, errors.New("ethereum compatible transactions not supported at current epoch")
                }
                signer = types.NewEIP155Signer(config.EthCompatibleChainID)
        } else {
                signer = types.Mak</span><span class="cov0" title="0">eSigner(config, header.Epoch())
        }
        m</span>sg, err := tx.AsMessage(signer)

        // skip signer err for additiononly tx
        <span class="cov8" title="1">if err != nil {
</span>                return nil, nil, nil, 0, err
        }</span>

        // Create a new context to be used in the EVM environment
        context := NewEVMContext(msg, header, bc, author)
        context.TxType = txType
        // Create a new environment which holds all relev</span><span class="cov0" title="0">ant information
        // about the transaction and calling mechanisms.
        v</span>menv <span class="cov8" title="1">:= vm.NewEVM(context, statedb, config, cfg)
        // Apply the transaction to the current state (included in the env)
        r</span>esult, err := ApplyMessage(vmenv, msg, gp)
        if err != nil {
        <span class="cov8" title="1">        return nil, nil, nil, 0, err
</span>        }
        // Update the state with pending changes
        var root []byte
        if config.IsS3(header.Epoch()) {
                statedb.Finalise(true)
        } else {
                root = statedb.IntermediateRoot(config.IsS3(header.Epoch())).Bytes()
        }
        *usedGas += result.UsedGas

        failedExe := result.VMErr != nil
        // Create a new receipt for the transaction, storing the intermediate root and gas used by the tx
        // based on th</span><span class="cov0" title="0">e eip phase, we're passing whether the root touch-delete accounts.
        receipt := types.NewReceipt(root, failedExe, *usedGas)
        r</span>eceipt.TxHash = tx.Hash()
        receipt.GasUsed = result.UsedGas
        // if the transaction created a contract, store the creation address in the receipt.
        <span class="cov0" title="0">if msg.To() == nil {
                receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())
        }

        // Set the receipt logs and create a bloom for filtering
        if config.IsReceiptLog(header.Epoch()) {
                receipt.Logs = statedb.GetLogs(tx.Hash())
        }
        receipt.Bloom </span><span class="cov0" title="0">= types.CreateBloom(types.Receipts{receipt})

        v</span>ar cxReceipt *types.CXReceipt
        // Do not create cxReceipt if EVM call failed
        if txType == types.SubtractionOnly &amp;&amp; !failedExe {
        <span class="cov0" title="0">        cxReceipt = &amp;types.CXReceipt{tx.Hash(), msg.From(), msg.To(), tx.ShardID(), tx.ToShardID(), msg.Value()}
        } else {
</span>                cxReceipt = nil
        }</span>

        r</span>eturn receipt, cxReceipt, vmenv.StakeMsgs, result.UsedGas, err
}<span class="cov0" title="0">

// ApplyStakingTransaction attempts to apply a staking transaction to the given state database
// and uses the input parameters for its environment. It returns the receipt
// for the staking transaction, gas used and an error if the transaction failed,
// indicating the block was invalid.
</span>// staking transaction will use the code field in the account to store the staking information
func ApplyStakingTransaction(
        c</span>onfig *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.DB,
        header *block.Header, tx *staking.StakingTransaction, usedGas *uint64, cfg vm.Config) (receipt *types.Receipt, gas uint64, err error) {

</span>        msg, err := StakingToMessage(tx, header.Number())
        if err != nil {
                return nil, 0, err
        }

        // Create a new context to be used in the EVM environment
        context<span class="cov0" title="0"> := NewEVMContext(msg, header, bc, author)

</span>        // Create a new environment which holds all relevant information
        /</span>/ about the transaction and calling mechanisms.
        vmenv := vm.NewEVM(context, statedb, config, cfg)

</span>        // Apply the transaction to th</span><span class="cov0" title="0">e current state (included in the env)
        gas, err = ApplyStakingMessage(vmenv, msg, gp, bc)
        if err != nil {
                return nil, 0, err
        }
</span>
        // Update the state with pending changes
        var root []byte
        if config.IsS3(header.</span><span class="cov0" title="0">Epoch()) {
                statedb.Finalise(true)
        } </span>else {
                <span class="cov0" title="0">root = statedb.IntermediateRoot(config.IsS3(header.Epoch())).Bytes()
        }
</span>        *usedGas += gas
        <span class="cov0" title="0">receipt = </span>types.NewReceipt(root, false, *usedGas)
        receipt.TxHash = tx.Hash()
        receipt.GasUsed = gas

        if config.IsReceiptLog(header.Epoch()) {
                receipt.Logs = statedb.GetLogs(tx.Hash())
                utils.Logger().Info().Interface("CollectReward", receipt.Logs)
        }

        return receipt, gas, nil
}
</span>
//</span> ApplyIncomingReceipt will add amount into ToAddress in the receipt
f<span class="cov8" title="1">unc ApplyIncomingReceipt(
        config *params</span><span class="cov0" title="0">.ChainConfig, db *state.DB,
        header *block.Header, cxp *types.CXReceiptsProof,
) </span>error {
        if cxp == nil {
        <span class="cov8" title="1">        return nil
        }

</span>        for _, cx := range cxp.Receipts {
                </span>if cx == nil || cx.To == nil { // should not happend
        <span class="cov8" title="1">                return errors.Errorf(
                                "ApplyIncomi</span>ngReceipts: Invalid incomingReceipt! %v", cx,
                        )
                }
                utils.Logger().Info().Interface("receipt", cx).
                        Msgf("ApplyIncomingReceipts: ADDING BALANCE %d", cx.Amount)

                if !db.Exist(*cx.To) {
                        db.CreateAccount(*cx.To)
                }
                db.AddBalance(*cx.To, cx.Amount)
                db.IntermediateRoot(config.IsS3(header.Epoch()))
        }
        return nil
}

// StakingToMessage returns the staking transaction as a core.Message.
// requires a signer to derive the sender.
// put it here to avoid cyclic import
func StakingToMessage(
        tx *staking.StakingTransaction, blockNum *big.Int,
) (types.Message, error) {
        payload, err := tx.RLPEncodeStakeMsg()
        if err != nil {
                return types.Message{}, err
        }
        from, err := tx.SenderAddress()
        if err != nil {
                return types.Message{}, err
        }

        msg := types.NewStakingMessage(from, tx.Nonce(), tx.GasLimit(), tx.GasPrice(), payload, blockNum)
        stkType := tx.StakingType()
        if _, ok := types.StakingTypeMap[stkType]; !ok {
                return types.Message{}, staking.ErrInvalidStakingKind
        }
        msg.SetType(types.StakingTypeMap[stkType])
        return msg, nil
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "fmt"
        "math"
        "math/big"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var (
        errInvalidSigner               = errors.New("invalid signer for staking transaction")
        errInsufficientBalanceForGas   = errors.New("insufficient balance to pay for gas")
        errInsufficientBalanceForStake = errors.New("insufficient balance to stake")
        errValidatorExist              = errors.New("staking validator already exists")
        errValidatorNotExist           = errors.New("staking validator does not exist")
        errNoDelegationToUndelegate    = errors.New("no delegation to undelegate")
        errCommissionRateChangeTooFast = errors.New("change on commission rate can not be more than max change rate within the same epoch")
        errCommissionRateChangeTooHigh = errors.New("commission rate can not be higher than maximum commission rate")
        errCommissionRateChangeTooLow  = errors.New("commission rate can not be lower than min rate of 5%")
        errNoRewardsToCollect          = errors.New("no rewards to collect")
        errNegativeAmount              = errors.New("amount can not be negative")
        errDupIdentity                 = errors.New("validator identity exists")
        errDupBlsKey                   = errors.New("BLS key exists")
)

/*
StateTransition is the State Transitioning Model which is described as follows:

A state transition is a change made when a transaction is applied to the current world state
The state transitioning model does all the necessary work to work out a valid new state root.

1) Nonce handling
2) Pre pay gas
3) Create a new state object if the recipient is \0*32
4) Value transfer
== If contract creation ==
  4a) Attempt to run transaction data
  4b) If valid, use result as code for the new state object
== end ==
5) Run Script section
6) Derive new state root
*/
type StateTransition struct {
        gp         *GasPool
        msg        Message
        gas        uint64
        gasPrice   *big.Int
        initialGas uint64
        value      *big.Int
        data       []byte
        state      vm.StateDB
        evm        *vm.EVM
        bc         ChainContext
}

// Message represents a message sent to a contract.
type Message interface {
        From() common.Address
        //FromFrontier() (common.Address, error)
        To() *common.Address

        GasPrice() *big.Int
        Gas() uint64
        Value() *big.Int

        Nonce() uint64
        CheckNonce() bool
        Data() []byte
        Type() types.TransactionType
        BlockNum() *big.Int
}

// ExecutionResult is the return value from a transaction committed to the DB
type ExecutionResult struct {
        ReturnData []byte
        UsedGas    uint64
        VMErr      error
}

// Unwrap returns the internal evm error which<span class="cov0" title="0"> allows us for further
// analysis outside.
f</span>unc (result *ExecutionResult) Unwrap() error {
        return result.VMErr
}

</span>// Failed returns the indicator whether the execution is successful or not
func (result *ExecutionResult) Failed() bool { return result.VMErr != nil }

// Return is a helper function to help caller d<span class="cov0" title="0">istinguish between revert reason
// and function return. </span><span class="cov0" title="0">Return returns the data after execution if no error occurs.
func (result *ExecutionResult) Return() []byte {
        i</span>f result.VMErr != nil {
        <span class="cov0" title="0">        return nil
</span>        }
        return common.CopyBytes(result.ReturnData)
}

// IntrinsicGas computes the 'intrinsic gas' fo<span class="cov0" title="0">r a message with the given data.
func IntrinsicGas(data []byte, contractCreat</span><span class="cov0" title="0">ion, homestead, istanbul, isValidatorCreation bool) (uint64, error) {
        // Set the starting gas for the raw transaction
        v</span>ar gas uint64
        <span class="cov0" title="0">if contractCreation &amp;&amp; homestead {
</span>                gas = params.TxGasContractCreation
        } else if isValidatorCreation {
                gas = params.TxGasValidatorCreation
        } else {
                gas = params.TxGas
        }
        // Bump the required gas by the amount of transactional data
        if len(data) &gt; 0 {
                // Zero and non-zero bytes are priced differently
                var nz uint64
                for _, byt := range data {
                        if byt != 0 {
                                nz++
                        }
        </span>        }
                // Make sure we don't exceed uint64 for all data combinations
                nonZeroGas := params.TxDataNonZeroGasFrontier
                if istanbul {
                        nonZeroGas = params.TxDataNonZeroGasEIP2028
                }
                if (math.MaxUint64-gas)/nonZeroGas &lt; nz {
                        return 0, vm.ErrOutOfGas
                }
                gas += nz * nonZeroGas

        </span>        z := uint64(len(data)) - nz
                if (math.MaxUint64-gas)/params.TxDataZeroGas &lt; z {
                        return 0, vm.ErrOutOfGas
                }
                gas += z * params.TxDataZeroGas
        </span>}
        return gas, nil
}

// Revert returns the concrete revert reason if the execution is</span><span class="cov0" title="0"> aborted by `REVERT`
// opcode. Note the reason can be nil if no data supplied with revert opcode.
fu</span>nc (result *ExecutionResult) Revert() []byte {
        <span class="cov8" title="1">if result.VMErr != </span>vm.ErrExecutionReverted {
                return nil
        }
        return common.CopyBytes(result.ReturnData)
}
</span>
//</span> NewStateTransition initialises and returns a new state transition object.
f<span class="cov8" title="1">unc NewStateTransition(evm *vm.EVM, msg Message, gp *GasPool, bc ChainContext) *StateTransition {
        return &amp;StateTransition{
                gp:      </span> gp,
                evm:      evm,
                msg:      msg,
                gasPrice: msg.GasPrice(),
                value:    msg.Value(),
                data:     msg.Data(),
</span>                state:    evm.StateDB,
                bc:       bc,
        }
}

</span>/<span class="cov8" title="1">/ ApplyMessage computes the new state by applying</span><span class="cov0" title="0"> the given message
// against the old state within the environment.
//</span>
/<span class="cov8" title="1">/ ApplyMessage returns the bytes returned by any EVM execution (if it took place),
// the gas used (which includes gas refunds) and an error if it failed. An error always
// indicates a core error meaning that the message would always fail for that particular
// state and would never be accepted within a block.
func ApplyM</span>essage(evm *vm.EVM, msg Message, gp *GasPool) (ExecutionResult, error) {
        return NewStateTransition(evm, msg, gp, nil).TransitionDb()
}

// ApplyStakingMessage computes the new state for staking message
func ApplyStakingMessage</span><span class="cov8" title="1">(evm *vm.EVM, msg Message, gp *GasPool, bc ChainContext) (uint64, error) {
        return NewStateTransition(evm, msg, gp, bc).StakingTransitionDb()
}

</span>// to returns the recipient of the message.
fun</span>c (st<span class="cov8" title="1"> *StateTransition) to() com</span><span class="cov0" title="0">mon.Address {
        if st.msg == nil || st.msg.To() == nil /* contract creation */ {
                r</span>eturn common.Address{}
        }
        <span class="cov8" title="1">return *st.msg.To(</span>)
}

func (st *StateTransition) useGas(amount uint64) error {
        if st.gas &lt; amount {
                return vm.ErrOutOfGas
        }
        st.gas -= amount
</span>
        r</span>eturn nil
}<span class="cov8" title="1">

func (st *StateTransition) buyGas() error {
        mgval := new(big.Int).Mul(new(big.Int).SetUint64(st.msg.Gas()), st.gasPrice)
        if have := st.state.GetBalance(st.msg.From()); have.Cmp(mgval) &lt; 0 {
                return errors.Wrapf(
                        errInsufficientBalanceForGas,
                        "had: %s but need: %s", have.String(), mgval.String(),
                )
</span>        }
        i</span>f err := st.gp.SubGas(st.msg.Gas()); err != nil {
        <span class="cov8" title="1">        return err
</span>        }
        s</span>t.gas += st.msg.Gas()

        <span class="cov8" title="1">st.initialGas = st.msg.Gas()
        st.state.SubBalance(st.msg.From(), mgval)
        return nil
}

func (st *StateTransition) preCheck() error {
        // Make sure this tr</span><span class="cov0" title="0">ansaction's nonce is correct.
        if st.msg.CheckNonce() {
                </span>nonce<span class="cov8" title="1"> := st.state.GetNonce(st.msg.From())

                if nonce &lt; st.msg.Nonce() {
                        return ErrNonceTooHigh
                </span>} else if nonce &gt; st.msg.Nonce() {
        <span class="cov8" title="1">                return ErrNonc</span><span class="cov0" title="0">eTooLow
                }
        }
        return st.buyGas()
}

// TransitionDb will transition the stat</span><span class="cov0" title="0">e by applying the current message and
// returning the result including the used gas. It returns an error if failed.
// </span>An error indicates a consensus issue.
func (st *StateTransition) TransitionDb() (ExecutionResult, error) {
        <span class="cov8" title="1">if err := st.preCheck(); err != nil {
                return ExecutionResult{}, err
        }
        msg := st.msg
</span>        sender := vm.AccountRef(msg.From())
        homestead := st.evm.ChainConfig().IsS3(st.evm.EpochNumber) // s3 includes homestead
        i</span>stanbul := st.evm.ChainConfig().IsIstanbul(st.evm.EpochNumber)
        contractCreation := msg.To() == nil

        // Pay intrinsic gas
        gas, err := IntrinsicGas(st.data, contractCreation, homestead, istanbul, false)
        if err != nil {
                retur</span>n ExecutionResult{}, err
        }
        if err = st.useGas(gas); err != nil {
                return ExecutionResult{}, fmt.Errorf(<span class="cov8" title="1">"%w: have %d, want %d", ErrIntrinsicGas, st.gas, gas)
        }

        evm := st.evm
</span>
        v</span>ar ret []byte
        <span class="cov8" title="1">// All VM errors are valid except for insufficient balance, therefore returned separately
        var vmErr error

        if contractCreation {
                ret, _, st.gas, vmErr = evm.Create(sender, st.data, st.gas, st.value)
        } else {
                // Increment the nonce for the next transaction
                st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)
                ret, st.gas, vmErr </span>= evm.Call(sender, st.to(), st.data, st.gas, st.value)
        }
        if vmErr != nil {
                utils.Logger().Debug().Err(vmErr).Msg("VM returned with error")
                // The only possible consensus-error would<span class="cov8" title="1"> be if there wasn't
                // sufficient balance to make the transfer happen. The first
        </span>        // balance transfer may never fail.

                if vmErr == vm.ErrInsufficientBalance {
                        return ExecutionResult{}, vmErr
                }
        }
        st.refundGas()
</span>
        /</span>/ Burn Txn Fees after staking epoch
        <span class="cov8" title="1">if !st.evm.ChainConfig().IsStaking(st.evm.EpochNumber) {
                txFee := new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice)
                st.state.AddBalance(st.evm.Coinbase, txFee)
        }

        return ExecutionResult{
                ReturnData: ret,
                UsedGas:    st.gasUsed(),
                VMErr:      vmErr,
        }, err
</span>}

</span>f<span class="cov8" title="1">unc (st *StateTransition) refundGas(</span><span class="cov0" title="0">) {
        // Apply refund counter, capped to half of the used gas.
        r</span>efund := st.gasUsed() / 2
        if refund &gt; st.state.GetRefund() {
                refund = st.state.GetRefund()
        <span class="cov8" title="1">}
        st.gas += refund

</span>        // Return ETH for remainin<span class="cov8" title="1">g gas, exchanged at the original rate.
        remaining := new(big.Int).Mul(new(big.Int).SetUint64(st.gas), st.gasPrice)
        st.state.AddBalance(st.msg.From(), remaining)
</span>
        //</span> Also return remaining gas to the block gas counter so it is
        /<span class="cov8" title="1">/ available for the next transaction.
        st.gp.AddGas(st.gas)
}
</span>
// </span>gasUsed returns the amount of gas used up by the state transition.
fu<span class="cov8" title="1">nc (st *StateTransition) gasUsed() uint64 {
</span>        return st.initialGas - s<span class="cov8" title="1">t.gas
}

</span>// StakingTransitionDb will transition the state by applying the staking message and
// </span>returning the result including the used gas. It returns an error if failed.
//<span class="cov8" title="1"> It is used for staking transaction only
func (st *StateTransition) StakingTransitionDb() (usedGas uint64, err error) {
        if err = st.preCheck(); err != nil {
</span>                return 0, err
        }
</span>        m<span class="cov8" title="1">sg := st.msg
</span>
        sender := vm.AccountRef(msg.From())
        homestead := st.evm.ChainConfig().IsS3(st.evm.EpochNumber)</span><span class="cov0" title="0"> // s3 includes homestead
        istanbul := st.evm.ChainConfig().IsIstanbul(st.evm.EpochNumber)

</span>        /<span class="cov8" title="1">/ Pay intrinsic gas
        gas, err := IntrinsicGas(st.data, false, h</span><span class="cov0" title="0">omestead, istanbul, msg.Type() == types.StakeCreateVal)

        if</span> err != nil {
                <span class="cov8" title="1">return 0, err
</span>        }
        if err = st.useGas(gas); err != nil {
                return 0, err
</span>        }

</span>        /<span class="cov8" title="1">/ Increment the nonce for the next transaction
        st.state.SetNonce(msg.From(), st.state.Get</span><span class="cov0" title="0">Nonce(sender.Address())+1)

        //</span> from worker.go, we get here with shardID == BeaconChainShardID
        /<span class="cov8" title="1">/ from node_handler.go, via blockchain.go =&gt; it</span> is checked that block shard == node shard
        // same via consensus
        // so only possible to reach here if shardID == BeaconChainShardID (no need to check further)
        switch msg.Type() {
</span>        case types.StakeCreateVal:
                s</span>tkMsg := &amp;stakingTypes.CreateValidator{}
                <span class="cov8" title="1">if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil {
                        return 0, err
</span>                }
                u</span>tils.Logger().Info().
                <span class="cov8" title="1">        Msgf("[DEBUG STAKING] staking type: %s, gas: %d, t</span>xn: %+v", msg.Type(), gas, stkMsg)
                if msg.<span class="cov0" title="0">From() != stkMsg.ValidatorAddress {
                        return 0, errInvalidSigner
</span>                }
        <span class="cov8" title="1">        err = st.evm.CreateValidator(st.evm.StateDB, stkMsg)
        case types.StakeEditVal:
                stkMsg := &amp;stakingTypes.EditValidator{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil {
                        return 0, err
                }
                utils.Logger().Info().
</span>                        Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.ValidatorAddress {
                        return 0, errInvalidSigner
                }
                err = st.evm.EditValidator(st.evm.StateDB, stkMsg)
        case types.Delegate:
                stkMsg := &amp;stakingTypes.Delegate{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil {
                        return 0, err
                }
                utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress {
                        return 0, errInvalidSigner
                }
                err = st.evm.Delegate(st.evm.StateDB, stkMsg)
        case types.Undelegate:
                stkMsg := &amp;stakingTypes.Undelegate{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil {
                        return 0, err
                }
                utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress {
                        return 0, errInvalidSigner
                }
                err = st.evm.Undelegate(st.evm.StateDB, stkMsg)
        case types.CollectRewards:
                stkMsg := &amp;stakingTypes.CollectRewards{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil {
                        return 0, err
                }
                utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress {
                        return 0, errInvalidSigner
                }
                err = st.evm.CollectRewards(st.evm.StateDB, stkMsg)
        default:
                return 0, stakingTypes.ErrInvalidStakingKind
        }
        st.refundGas()

        // Burn Txn Fees
        //txFee := new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice)
        //st.state.AddBalance(st.evm.Coinbase, txFee)

        return st.gasUsed(), err
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package vm

import (
        "errors"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/shard"
        staking "github.com/harmony-one/harmony/staking"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
)

var WriteCapablePrecompiledContractsStaking = map[common.Address]WriteCapablePrecompiledContract{
        common.BytesToAddress([]byte{252}): &amp;stakingPrecompile{},
}

// Native Go contracts which are available as a precompile in the EVM
// These have the capability to alter the state (those in contracts.go do not)
type WriteCapablePrecompiledContract interface {
        // RequiredGas calculates the contract gas use
        RequiredGas(evm *EVM, input []byte) uint64
        // use a different name from read-only contracts to be safe
        RunWriteCapable(evm *EVM, contract *Contract, input []byte) ([]byte, error)
}

// RunPrecompil</span><span class="cov0" title="0">edContract runs and evaluates the output of a precompiled contract.
func RunWriteCapablePrecompiledContract(p WriteCapablePrecompiledContract, evm *EVM, contract *Contract, input []byte, readOnly bool) ([]byte, error) {
        /</span>/ immediately error out if readOnly
        <span class="cov8" title="1">if readOnly {
</span>                return nil, errWriteProtection
        }</span>
        <span class="cov8" title="1">gas := p.RequiredGas(evm, input)
</span>        if !contract.UseGas(gas) {
                return nil, ErrOutOfGas
        }
        return p.RunWriteCapable(evm, contract, input)
}

type stakingPrecompile struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
</span>// This method does not require any overflow checking as the input size gas costs
//</span> required for anything significant is so high it's impossible to pay for.
f<span class="cov8" title="1">unc (c *stakingPrecompile) RequiredGas(evm *EVM, input []byte) uint64 {
        // If you check the tests, they contain a bunch of successful transactions
        // which are of the type Delegate / Undelegate / CollectRewards
        // these consume anywhere between 22-25k of gas, which is in line with
        // what would happen for a non-EVM staking tx
        // so no additional gas needs to be consumed here
        return 0
        // nb: failed </span><span class="cov0" title="0">transactions result in consumption of
        // all the gas that was passed, as per core/vm/evm.go
        /</span>/ if err != ErrExecutionReverted {
        <span class="cov8" title="1">//        contract.Use</span>Gas(contract.Gas)
        // }
}

func (c *stakingPrecompile) RunWriteCapable(evm *EVM, contract *Contract, input []byte) ([]byte, error) {
        // checks include input, shard, method
        // readOnly has already been checked by RunWriteCapablePrecompiledContract
        // first 32 for size and next 4 for method, at a minimum
        if len(input) &lt; 36 {
                return nil, errors</span><span class="cov0" title="0">.New("Input is malformed")
        }
        i</span>f evm.Context.ShardID != shard.BeaconChainShardID {
                return nil, errors.New("Staking not supported on this shard")
        <span class="cov8" title="1">        // we are not shard 0, so no processing
                // but do not fail silently
        }
        input = input[32:] // drop the initial start of word information
        method, err := staking.ParseStakingMethod(input)
        if err != nil {
</span>                return nil, stakingTypes.ErrInvalidStakingK<span class="cov8" title="1">i</span><span class="cov8" title="1">nd
        }
</span>        input = input[4:] // drop the method selector
        // </span>store passed information in map
        args := map[string]interface{}{}
        if<span class="cov8" title="1"> err = method.Inputs.UnpackIntoMap(args, input); err != nil {
                return nil, err</span><span class="cov8" title="1">
        }
        swi</span>tch method.Name {
        ca<span class="cov8" title="1">se "Delegate":
                {
</span>                        // a contract should only delegate its own balance - nobody else's
                        a</span>ddress, err := staking.ValidateContractAddress(contract.Caller(), args, "delegatorAddress")
                        <span class="cov8" title="1">if err != nil {
                                return nil, e</span><span class="cov0" title="0">rr
                        }
                        v</span>alidatorAddress, err := staking.ParseAddressFromKey(args, "validatorAddress")
                        <span class="cov8" title="1">if err != nil {
                                return nil, e</span><span class="cov0" title="0">rr
                        }
                        a</span>mount, err := staking.ParseBigIntFromKey(args, "amount")
                        <span class="cov8" title="1">if err != nil {
                                return nil, e</span><span class="cov0" title="0">rr
                        }
                        s</span>takeMsg := &amp;stakingTypes.Delegate{
                        <span class="cov8" title="1">        DelegatorAddress: address,
                                ValidatorAddr</span><span class="cov0" title="0">ess: validatorAddress,
                                Amount:           amount,
                        }</span>
                        <span class="cov8" title="1">if err := evm.Delegate(evm.StateDB, stakeMsg); err != nil {
                                return nil, e</span><span class="cov8" title="1">rr
                        } else {
                                </span>evm.StakeMsgs = append(evm.StakeMsgs, stakeMsg)
                        <span class="cov8" title="1">        return nil, nil
                        }
</span>                }
        cas</span>e "Undelegate":
                {<span class="cov8" title="1">
                        // a contract should only delegate its own balance - nobody else's
                        address, err := staking.ValidateContractAddress(contract.Caller(), args, "delegatorAddress")
                        if err != nil {
                                return nil, err
                        }
                        validatorAddress, err := staking.ParseAddressFromKey(args, "validatorAddress")
                        if err != nil {
                                return nil, err
                        }
                        // this type assertion is needed by Golang
</span>                        amount, err := staking.ParseBigIntFromKey(args, "amount")
                        i</span>f err<span class="cov8" title="1"> != nil {
                                return nil, err
                        }
                        s</span>takeMsg := &amp;stakingTypes.Undelegate{
                                DelegatorAddress: address,
                                ValidatorAddress: validatorAddress,
</span>                                Amount:           amount,
</span>                        }
                        r</span>eturn nil, evm.Undelegate(evm.StateDB, stakeMsg)
                }<span class="cov8" title="1">
        case "CollectRew</span><span class="cov8" title="1">ards":
                {
                        /</span>/ a contract should only collect its own rewards - nobody else's
                        <span class="cov8" title="1">address, err := staking.ValidateContractAddress(contract.Caller(), args, "delegatorAddress")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.CollectRewards{
                                DelegatorAddr</span><span class="cov0" title="0">ess: address,
                        }
                        r</span>eturn nil, evm.CollectRewards(evm.StateDB, stakeMsg)
                }<span class="cov8" title="1">
        default:
</span>                {
                        r</span>eturn nil, stakingTypes.ErrInvalidStakingKind
                }<span class="cov8" title="1">
        }
</span>        // return nil, nil -&gt; this never reached
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package vm

import (
        "math/big"
        "sync/atomic"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/internal/params"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
)

// emptyCodeHash is used by create to ensure deployment is disallowed to already
// deployed contract addresses (relevant after the account abstraction).
var emptyCodeHash = crypto.Keccak256Hash(nil)

type (
        // CanTransferFunc is the signature of a transfer guard function
        CanTransferFunc func(StateDB, common.Address, *big.Int) bool
        // IsValidatorFunc is the signature of IsValidator function
        IsValidatorFunc func(StateDB, common.Address) bool
        // TransferFunc is the signature of a transfer function
        TransferFunc func(StateDB, common.Address, common.Address, *big.Int, types.TransactionType)
        // GetHashFunc returns the nth block hash in the blockchain
        // and is used by the BLOCKHASH EVM op code.
        GetHashFunc func(uint64) common.Hash
        // GetVRFFunc returns the nth block vrf in the blockchain
        // and is used by the precompile VRF contract.
        GetVRFFunc func(uint64) common.Hash
        // Below functions are used by staking precompile / state transition
        CreateValidatorFunc func(db StateDB, stakeMsg *stakingTypes.CreateValidator) error
        EditValidatorFunc   func(db StateDB, stakeMsg *stakingTypes.EditValidator) error
        DelegateFunc        func(db StateDB, stakeMsg *stakingTypes.Delegate) error
        UndelegateFunc      func(db StateDB, stakeMsg *stakingTypes.Undelegate) error
        CollectRewardsFunc  func(db StateDB, stakeMsg *stakingTypes.CollectRewards) error
)

// run runs the given contract and takes care of running precompiles with a fallback to the byte code interpreter.
func run(evm *EVM, contract *Contract, input []byte, readOnly bool) ([]byte, error) <span class="cov8" title="1">{
        if contract.CodeAddr != nil </span><span class="cov8" title="1">{
                precompiles := PrecompiledContractsHomestead
                // assign empty write capable precompiles till they are available in the fork
                writeCapablePrecompiles := make(map[common.Address]WriteCapablePrecompiledContract)
                if evm.ChainConfig().IsS3(evm.EpochNumber) </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsByzantium
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsIstanbul </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsIstanbul
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsVRF </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsVRF
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsSHA3 </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsSHA3FIPS
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsStakingPrecompile </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsStaking
                        </span>writeCapablePrecompiles = WriteCapablePrecompiledContractsStaking
                <span class="cov8" title="1">}
</span>                if p := precompiles[*contr</span><span class="cov0" title="0">act.CodeAddr]; p != nil {
                        if _, ok := p.(*vrf); ok {
</span>                                if evm.chainRules.IsPrevVRF {
                                        requestedBlockNum := big.NewInt(0).SetBytes(input)
                                        minBlockNum := big.NewInt(0).Sub(evm.BlockNumber, common.Big257)

</span>                                        if requestedBlockNum.Cmp(evm.BlockNumber) == 0 {
                                                </span>input<span class="cov0" title="0"> = evm.Context.VRF.Bytes()
</span>                                        } else if requestedBlockNum.Cmp(minBlockNum) &gt; 0 &amp;&amp; requestedBlockNum.Cmp(evm.BlockNumber) &lt; 0 {
                                                // requested block number is in range
                                                </span>input<span class="cov0" title="0"> = evm.GetVRF(requestedBlockNum.Uint64()).Bytes()
                                        } else {
                                                // else default to the current block's VRF
                                                </span>input = evm.Context.VRF.Bytes()
                                        }
                                } else {
                                        // Override the input with vrf data of the requested block so it can be returned to the contract program.
                                        </span>input = evm.Context.VRF.Bytes()
                                }
                        <span class="cov0" title="0">}
</span>                        return RunPrecompiledContract(p, input, contract)
                <span class="cov8" title="1">}
</span>                if p := writeCapablePrecompiles[*contract.CodeAddr]; p != nil {
                        </span>return RunWriteCapablePrecompiledContract(p, evm, contract, input, readOnly)
                }
        <span class="cov8" title="1">}
</span>        for _, interpreter := range evm.interp</span><span class="cov8" title="1">reters {
                if interpreter.CanRun(contract.Code</span><span class="cov0" title="0">) {
                        if evm.interpreter != interpreter {
                                // Ensure that the interpreter pointer is set back
                                // to its current value up</span><span class="cov0" title="0">on return.
                                defer func(i Interpreter) {
                                        </span>evm.interpreter = i
                                <span class="cov0" title="0">}(evm.interpreter)
</span>                                evm.interpreter = interpreter
                        }

</span>                        if evm.ChainConfig().IsDataCopyFixEpoch(evm.EpochNumber) {
                                </span>contract.WithDataCopyFix = true
                        <span class="cov8" title="1">}
</span>                        return interpreter.Run(contract, input, readOnly)

                }
        <span class="cov0" title="0">}
</span>        return nil, ErrNoCompatibleInterpreter
}

// Context provides the EVM with auxiliary information. Once provided
// it shouldn't be modified.
type Context struct {
        // CanTransfer returns whether the account contains
        // sufficient ether to transfer the value
        CanTransfer CanTransferFunc
        // Transfer transfers ether from one account to the other
        Transfer TransferFunc
        // GetHash returns the hash corresponding to n
        GetHash GetHashFunc
        // GetVRF returns the VRF corresponding to n
        GetVRF GetVRFFunc

        // IsValidator determines whether the address corresponds to a validator or a smart contract
        // true: is a validator address; false: is smart contract address
        IsValidator IsValidatorFunc

        // Message information
        Origin   common.Address // Provides information for ORIGIN
        GasPrice *big.Int       // Provides information for GASPRICE

        // Block information
        Coinbase    common.Address // Provides information for COINBASE
        GasLimit    uint64         // Provides information for GASLIMIT
        BlockNumber *big.Int       // Provides information for NUMBER
        EpochNumber *big.Int       // Provides information for EPOCH
        Time        *big.Int       // Provides information for TIME
        VRF         common.Hash    // Provides information for VRF

        TxType types.TransactionType

        CreateValidator CreateValidatorFunc
        EditValidator   EditValidatorFunc
        Delegate        DelegateFunc
        Undelegate      UndelegateFunc
        CollectRewards  CollectRewardsFunc

        // staking precompile checks this before proceeding forward
        ShardID uint32
}

// EVM is the Ethereum Virtual Machine base object and provides
// the necessary tools to run a contract on the given state with
// the provided context. It should be noted that any error
// generated through any of the calls should be considered a
// revert-state-and-consume-all-gas operation, no checks on
// specific errors should ever be performed. The interpreter makes
// sure that any errors generated are to be considered faulty code.
//
// The EVM should never be reused and is not thread safe.
type EVM struct {
        // Context provides auxiliary blockchain related information
        Context
        // DB gives access to the underlying state
        StateDB StateDB
        // Depth is the current call stack
        depth int

        // chainConfig contains information about the current chain
        chainConfig *params.ChainConfig
        // chain rules contains the chain rules for the current epoch
        chainRules params.Rules
        // virtual machine configuration options used to initialise the
        // evm.
        vmConfig Config
        // global (to this context) ethereum virtual machine
        // used throughout the execution of the tx.
        interpreters []Interpreter
        interpreter  Interpreter
        // abort is used to abort the EVM calling operations
        // NOTE: must be set atomically
        abort int32
        // callGasTemp holds the gas available for the current call. This is needed because the
        // available gas is calculated in gasCall* according to the 63/64 rule and later
        // applied in opCall*.
        callGasTemp uint64
        // stored temporarily by stakingPrecompile and cleared immediately after return
        // (although the EVM object itself is ephemeral)
        StakeMsgs []stakingTypes.StakeMsg
}

// NewEVM returns a new EVM. The returned EVM is not thread safe and should
// only ever be used *once*.
func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM {
        evm := &amp;EVM{
                Context:      ctx,
                StateDB:      statedb,
                vmConfig:     vmConfig,
                chainConfig:  chainConfig,
                chainRules:   chainConfig.Rules(ctx.EpochNumber),
                interpreters: make([]Interpreter, 0, 1),
        }

        //if chainConfig.IsS3(ctx.EpochNumber) {
        //        to be implemented by EVM-C and Wagon PRs.
        //        if vmConfig.EWASMInterpreter != "" {
        //         extIntOpts := strings.Split(vmConfig.EWASMInterpreter, ":")
        //         path := extIntOpts[0]
        //         options := []string{}
        //         if len(extIntOpts) &gt; 1 {
        //           options = extIntOpts[1..]
        //         }
        //         evm.interpreters = append(evm.interpreters, NewEVMVCInterpreter(evm, vmConfig, options))
        //        } else {
        //                evm.interpreters = append(evm.interpreters, NewEWASMInterpreter(evm, vmConfig))
        //        }
        //        panic("No supported ewasm interpreter yet.")
        //}

        // vmConfig.EVMInterpreter will be used by EVM-C, it won't be checked here
        // as we always want to have the built-in EVM as the failover option.
        evm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig))
        evm.interpreter = evm.interpreters[0]

        </span>return evm
}

// Cancel cancels any running EVM operation. This may be called concurrently and
// it's safe to be called<span class="cov0" title="0"> multiple times.
func (evm *EVM) Cancel() {
        </span>atomic.StoreInt32(&amp;evm.abort, 1)
}

// Cancelled returns true if Canc<span class="cov0" title="0">el has been called
func (evm *EVM) Cancelled() bool {
        </span>return atomic.LoadInt32(&amp;evm.abort) == 1
}

// Interpreter returns the current interpr<span class="cov0" title="0">eter
func (evm *EVM) Interpreter() Interpreter {
        </span>return evm.interpreter
}

// Call executes the contract associated with the addr with the given input as
// parameters. It also handles any necessary value transfer required and takes
// the necessary steps to create accounts and reverses the state in case of an
// execution error or failed value transfer.
func (evm *EVM) Call(caller ContractRef, addr </span><span class="cov0" title="0">common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {
                </span>return nil, gas, nil
        }

        <span class="cov8" title="1">// Fail if we're trying to execute above th</span><span class="cov0" title="0">e call depth limit
        if evm.depth &gt; int(params.CallCreateDepth) {
                </span>return nil, gas, ErrDepth
        }

        txType := evm.Context.TxType

        // Fail if we're trying to transfer more than the available balanc</span><span class="cov0" title="0">e
        if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {
                </span>return nil, gas, ErrInsufficientBalance
        }

        var (
                to       = AccountRef(addr)
                snapshot = evm.StateDB.Snapshot()
        )
</span>        if !evm.StateDB.Exist(addr) &amp;&amp; txType != types.SubtractionOnly {
                precompiles := PrecompiledContractsHomestead
                writeCapablePrecompiles := make(map[common.</span><span class="cov8" title="1">Address]WriteCapablePrecompiledContract)
                if evm.ChainConfig().IsS3(evm.EpochNumber) {
                        </span>precompiles = PrecompiledContractsByzantium
                <span class="cov8" title="1">}
</span>                if evm.chainRules.IsIstanbul {
                        </span>precompiles = PrecompiledContractsIstanbul
                <span class="cov8" title="1">}
</span>                if evm.chainRules.IsVRF {
                        </span>precompiles = PrecompiledContractsVRF
                <span class="cov8" title="1">}
</span>                if evm.chainRules.IsSHA3 {
                        </span>precompiles = PrecompiledContractsSHA3FIPS
                <span class="cov8" title="1">}
</span>                if evm.chainRules.IsStakingPrecompile {
                        </span>precompiles = PrecompiledContractsStaking
                        writeCapablePrecompiles = WriteCapablePrecompiledContractsStaking
                <span class="cov8" title="1">}
</span>
                if writeCapablePrecompiles[addr] == nil &amp;</span><span class="cov0" title="0">&amp; precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsS3(evm.EpochNumber) &amp;&amp; value.Sign() == 0 {
                        // Calling a non existing account, don't do anything, but ping the tracer
                        if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 {
                                </span>evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)
                        <span class="cov0" title="0">        evm.vmConfig.Tracer</span>.CaptureEnd(ret, 0, 0, nil)
                        }
                <span class="cov8" title="1">        return nil, gas, nil
</span>                }
        <span class="cov8" title="1">        evm.StateDB.CreateAccount(addr)
        }
        evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value, txType)

        codeHash := evm.StateDB.GetCodeHash(addr)
        code := evm.StateDB.GetCode(addr)
        // If address is a validator address, then it'</span><span class="cov8" title="1">s not a smart contract address
        // we don't use its code and codeHash f</span><span class="cov8" title="1">ields
        if evm.Context.IsValidator(evm.StateDB, addr) {
                codeHash = emptyCodeHash
                code = nil
</span>        }
        // </span>Initialise a new contract and set the code that is to be used by the EVM.
        //<span class="cov8" title="1"> The contract is a scoped environment for this execution context only.
        contract := NewContract(caller, to, val</span>ue, gas)
        contrac<span class="cov8" title="1">t.SetCallCode(&amp;addr, codeHash, code)

        // Even if the account has no code, we need to continue because it might be a precompile
        st</span>art := time.Now()

        // Capture the tracer start/end events in debug mode
        if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 {
        <span class="cov8" title="1">        evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)

                defer func() { // Lazy evaluation of the parameters
                        evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)
                }()
        }
        ret, err = run(evm, contract, input, false)

</span>        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're </span><span class="cov0" title="0">in homestead this also counts for code storage gas errors.
        if err != nil {
                e</span>vm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted {
        <span class="cov8" title="1">                contract.UseGas(contract.Gas)
                }
        }
        return ret, contract.Gas, err
}

</span>// CallCode executes the contract associated with the addr with the given input
// as parameters. It also handles</span><span class="cov8" title="1"> any necessary value transfer required and takes
// the necessary steps to create accounts and reverses the state in case of an
// </span>execution error or failed value transfer.
//
/<span class="cov8" title="1">/ CallCode differs from Call </span>in the sense that it executes the given address'
// code with the caller as context.
func (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {
                return nil, gas, nil
        }

        // Fail if we're trying to execute above the call depth limit
        if evm.depth &gt; int(params.CallCreateDepth) {
                return nil, gas, ErrDepth
        }
        // Fail if we're trying to transfer more than</span><span class="cov0" title="0"> the available balance
        if !evm.CanTransfer(evm.StateDB, caller.Address(), value) {
                </span>return nil, gas, ErrInsufficientBalance
        }

        <span class="cov0" title="0">var (
</span>                snapshot = evm.StateDB.Snapshot()
                </span>to       = AccountRef(caller.Address())
        )
        <span class="cov0" title="0">// initialise a new contract and set the code that is to b</span><span class="cov0" title="0">e used by the
        // EVM. The contract is a scoped environment for this execution context
        /</span>/ only.
        contract := NewContract(caller, to, value, gas)
        <span class="cov0" title="0">contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        ret, err = run(evm, contract, input, false)
        if err != nil {
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted {
                        contract.UseGas(contract.Gas)
                }
        }
        return ret, contract.Gas, err
}

</span>// DelegateCall executes the contract associated with the addr with the given input
// as parameters. It reverses the</span><span class="cov0" title="0"> state in case of an execution error.
//
// </span>DelegateCall differs from CallCode in the sense that it executes the given address'
// code with the caller as context and the caller is set to the caller of the caller.
f<span class="cov0" title="0">unc (evm *EVM) DelegateCall(c</span>aller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {
                return nil, gas, nil
        }
        // Fail if we're trying to execute above the call depth limit
        if evm.depth &gt; int(params.CallCreateDepth) {
                return nil, gas, ErrDepth
        }

        var (
</span>                snapshot = evm.StateDB.Snapshot()
                </span>to       = AccountRef(caller.Address())
        )

</span>        // Initialise a new contract and make initialise the delegate values
        c</span>ontract := NewContract(caller, to, nil, gas).AsDelegate()
        contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        ret, err = run(evm, contract, input, false)
        if err != nil {
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted {
                        contract.UseGas(contract.Gas)
                }
        }
        return ret, contract.Gas, err
}

</span>// StaticCall executes the contract associated with the addr with the given input
// as parameters while disallowin</span><span class="cov0" title="0">g any modifications to the state during the call.
// Opcodes that attempt to perform such modifications will result in exceptions
// </span>instead of performing the modifications.
func (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {
        <span class="cov0" title="0">if evm.vmConfig.NoRecursion &amp;</span>&amp; evm.depth &gt; 0 {
                return nil, gas, nil
        }
        // Fail if we're trying to execute above the call depth limit
        if evm.depth &gt; int(params.CallCreateDepth) {
                return nil, gas, ErrDepth
        }

        var (
</span>                to       = AccountRef(addr)
                </span>snapshot = evm.StateDB.Snapshot()
        )
        <span class="cov0" title="0">// Initialise a new contract and set the co</span><span class="cov0" title="0">de that is to be used by the
        // EVM. The contract is a scoped environment for this execution context
        /</span>/ only.
        contract := NewContract(caller, to, new(big.Int), gas)
        <span class="cov0" title="0">contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        // We do an AddBalance of zero here, just in order to trigger a touch.
        // This doesn't matter on Mainnet, where all empties are gone at the time of Byzantium,
        // but is the correct thing to do and matters on other networks, in tests, and potential
        // future scenarios
        evm.StateDB.AddBalance(addr, bigZero)

        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're in Homestead this also counts for code storage gas errors.
        ret, err = run(evm, contract, input, true)
        if err != nil {
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted {
                        contract.UseGas(contract.Gas)
                }
        }
        return ret, contract.Gas, err
}

</span>type codeAndHash struct {
        code []byte
</span>        hash common.Hash
}
</span>
f<span class="cov0" title="0">unc (c *codeAndHash) Hash() c</span>ommon.Hash {
        if c.hash == (common.Hash{}) {
                c.hash = crypto.Keccak256Hash(c.code)
        }
        return c.hash
}

// create creates a new contract using code as deployment code.
func (evm *EVM) create(caller ContractRef<span class="cov0" title="0">, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) {
        // Depth check execution. Fai</span><span class="cov0" title="0">l if we're trying to execute above the
        // limit.
        i</span>f evm.depth &gt; int(params.CallCreateDepth) {
        <span class="cov0" title="0">        return nil, </span>common.Address{}, gas, ErrDepth
        }
        if !evm.CanTransfer(evm.StateDB, caller.Address(), value) {
                return nil, common.Address{}, gas, ErrInsufficientBalance
        }
        nonce := evm.StateDB.GetNonce(caller.Address())
        evm.StateDB.SetNonce(caller.Address(), nonce+1)

</span>        // Ensure there's no existing contract already at the designated address
        c</span>ontractHash := evm.StateDB.GetCodeHash(address)
        <span class="cov0" title="0">if evm.StateDB.GetNonce(address) != 0 || (contractHash != </span><span class="cov0" title="0">(common.Hash{}) &amp;&amp; contractHash != emptyCodeHash) {
                return nil, common.Address{}, 0, ErrContractAddressCollision
        }</span>
        <span class="cov0" title="0">// Create a new account on the state
        snapshot := evm.StateDB.Snapshot()
        evm.StateDB.CreateAccount(address)
        if evm.ChainConfig().IsEIP155(evm.EpochNumber) {
                evm.StateDB.SetNonce(address, 1)
        }
</span>        evm.Transfer(evm.StateDB, caller.Address(), address, value, types.SameShardTx)

</span>        // initialise a new contract and set the code that is to be used by the
        <span class="cov0" title="0">// EVM. The contract is a scoped environment for this execution context
        // only.
        contract := NewContract(caller, AccountRef(addr</span><span class="cov0" title="0">ess), value, gas)
        contract.SetCodeOptionalHash(&amp;address, codeAndHash)

</span>        <span class="cov0" title="0">if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {
                return nil, address, gas, nil
        }

        if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 {
                evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), address, true, codeAndHash.code, gas, value)
        }
        start := time.Now()

</span>        ret, err := run(evm, contract, nil, false)

</span>        // check whether the max code size has been exceeded
        <span class="cov0" title="0">maxCodeSizeExceeded := evm.ChainConfig()</span><span class="cov0" title="0">.IsEIP155(evm.EpochNumber) &amp;&amp; len(ret) &gt; params.MaxCodeSize
        // if the contract creation ran successfully and no errors were returned
        /</span>/ calculate the gas required to store the code. If the code could not
        <span class="cov0" title="0">// be stored due to not enough gas set an error and let it be handled
        // by the error checking condition below.
        if err == nil &amp;&amp; !maxCodeSizeExceeded {
                createDataGas := uint64(len(ret)) * params.CreateDataGas
                if contract.UseGas(createDataGas) {
                        evm.StateDB.SetCode(address, ret)
                } else {
                        err = ErrCodeStoreOutOfGas
                }
        }

</span>        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot </span><span class="cov0" title="0">and consume any gas remaining. Additionally
        // when we're in homestead this also counts for code storage gas errors.
        if</span> maxC<span class="cov0" title="0">odeSizeExceeded || (err != nil &amp;&amp; (evm.ChainConfig().IsS3(evm.EpochNumber) || err != ErrCodeStoreOutOfGas)) {
                evm.StateDB.RevertToSnapshot(snapshot)
                i</span>f err != ErrExecutionReverted {
                        contract.UseGas(contract.Gas)
                }
        }
        // Assign err if contract code size exceeds the max while the err is still empty.
        if maxCodeSizeExceeded &amp;&amp; err == nil {
        <span class="cov0" title="0">        err = errMaxCodeSizeExceeded
</span>        }
        if evm.vmConfig.Debug &amp;&amp; evm.dep</span><span class="cov0" title="0">th == 0 {
                evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)
        }
</span>        return ret, address, contract.Gas, err

}<span class="cov0" title="0">
</span>
//</span> Create creates a new contract using code as deployment code.
f<span class="cov0" title="0">unc (evm *EVM) Create(caller ContractRef</span><span class="cov0" title="0">, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {
        contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))
        r</span>eturn evm.create(caller, &amp;codeAndHash{code: code}, gas, value, contractAddr)
}<span class="cov0" title="0">
</span>
// Create2 creates a new contract using code as deployment code.
//
// The different between Create2 with Create is Create2 uses sha3(0xff ++ msg.sender ++ salt ++ sha3(init_code))[12:]
// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.
func (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {
        codeAndHash := &amp;codeAndHash{code: code}
        </span>contractAddr = crypto.CreateAddress2(caller.Address(), common.BigToHash(salt), codeAndHash.Hash().Bytes())
        return evm.create(caller, codeAndHash, gas, endowment, contractAddr)
}

// ChainConfig returns the environment's chain configuration
func (evm *EVM) ChainConfig() *params.ChainConfig { return evm.chainConfig }
</pre>
		
		<pre class="file" id="file7" style="display: none">package params

import (
        "fmt"
        "math/big"
        "sync"

        "github.com/ethereum/go-ethereum/common"
)

// Well-known chain IDs.
var (
        MainnetChainID            = big.NewInt(1)
        TestnetChainID            = big.NewInt(2)
        PangaeaChainID            = big.NewInt(3)
        PartnerChainID            = big.NewInt(4)
        StressnetChainID          = big.NewInt(5)
        TestChainID               = big.NewInt(99)  // not a real network
        AllProtocolChangesChainID = big.NewInt(100) // not a real network

        // EthMainnetShard0ChainID to be reserved unique chain ID for eth compatible chains.
        EthMainnetShard0ChainID            = big.NewInt(1666600000)
        EthTestnetShard0ChainID            = big.NewInt(1666700000)
        EthPangaeaShard0ChainID            = big.NewInt(1666800000)
        EthPartnerShard0ChainID            = big.NewInt(1666900000)
        EthStressnetShard0ChainID          = big.NewInt(1667000000)
        EthTestShard0ChainID               = big.NewInt(1667100000) // not a real network
        EthAllProtocolChangesShard0ChainID = big.NewInt(1667200000) // not a real network
)

// EpochTBD is a large, â€œnot anytime soonâ€ epoch.  It used as a placeholder
// until the exact epoch is decided.
var EpochTBD = big.NewInt(10000000)
var once sync.Once

var (
        // MainnetChainConfig is the chain parameters to run a node on the main network.
        MainnetChainConfig = &amp;ChainConfig{
                ChainID:                    MainnetChainID,
                EthCompatibleChainID:       EthMainnetShard0ChainID,
                EthCompatibleShard0ChainID: EthMainnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(442), // Around Thursday Feb 4th 2020, 10AM PST
                CrossTxEpoch:               big.NewInt(28),
                CrossLinkEpoch:             big.NewInt(186),
                AggregatedRewardEpoch:      big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                StakingEpoch:               big.NewInt(186),
                PreStakingEpoch:            big.NewInt(185),
                QuickUnlockEpoch:           big.NewInt(191),
                FiveSecondsEpoch:           big.NewInt(230),
                TwoSecondsEpoch:            big.NewInt(366), // Around Tuesday Dec 8th 2020, 8AM PST
                SixtyPercentEpoch:          big.NewInt(530), // Around Monday Apr 12th 2021, 22:30 UTC
                RedelegationEpoch:          big.NewInt(290),
                NoEarlyUnlockEpoch:         big.NewInt(530), // Around Monday Apr 12th 2021, 22:30 UTC
                VRFEpoch:                   big.NewInt(631), // Around Wed July 7th 2021
                PrevVRFEpoch:               big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                MinDelegation100Epoch:      big.NewInt(631), // Around Wed July 7th 2021
                MinCommissionRateEpoch:     big.NewInt(631), // Around Wed July 7th 2021
                MinCommissionPromoPeriod:   big.NewInt(100),
                EPoSBound35Epoch:           big.NewInt(631), // Around Wed July 7th 2021
                EIP155Epoch:                big.NewInt(28),
                S3Epoch:                    big.NewInt(28),
                DataCopyFixEpoch:           big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                IstanbulEpoch:              big.NewInt(314),
                ReceiptLogEpoch:            big.NewInt(101),
                SHA3Epoch:                  big.NewInt(725), // Around Mon Oct 11 2021, 19:00 UTC
                HIP6And8Epoch:              big.NewInt(725), // Around Mon Oct 11 2021, 19:00 UTC
                StakingPrecompileEpoch:     EpochTBD,
        }

        // TestnetChainConfig contains the chain parameters to run a node on the harmony test network.
        TestnetChainConfig = &amp;ChainConfig{
                ChainID:                    TestnetChainID,
                EthCompatibleChainID:       EthTestnetShard0ChainID,
                EthCompatibleShard0ChainID: EthTestnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(73290),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(74275),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(16500),
                TwoSecondsEpoch:            big.NewInt(73000),
                SixtyPercentEpoch:          big.NewInt(73282),
                RedelegationEpoch:          big.NewInt(36500),
                NoEarlyUnlockEpoch:         big.NewInt(73580),
                VRFEpoch:                   big.NewInt(73880),
                PrevVRFEpoch:               big.NewInt(74384),
                MinDelegation100Epoch:      big.NewInt(73880),
                MinCommissionRateEpoch:     big.NewInt(73880),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(73880),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(74412),
                IstanbulEpoch:              big.NewInt(43800),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(74570),
                HIP6And8Epoch:              big.NewInt(74570),
                StakingPrecompileEpoch:     EpochTBD,
        }

        // PangaeaChainConfig contains the chain parameters for the Pangaea network.
        // All features except for CrossLink are enabled at launch.
        PangaeaChainConfig = &amp;ChainConfig{
                ChainID:                    PangaeaChainID,
                EthCompatibleChainID:       EthPangaeaShard0ChainID,
                EthCompatibleShard0ChainID: EthPangaeaShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(0),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:     big.NewInt(0),
        }

        // PartnerChainConfig contains the chain parameters for the Partner network.
        // All features except for CrossLink are enabled at launch.
        PartnerChainConfig = &amp;ChainConfig{
                ChainID:                    PartnerChainID,
                EthCompatibleChainID:       EthPartnerShard0ChainID,
                EthCompatibleShard0ChainID: EthPartnerShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(0),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:     big.NewInt(0),
        }

        // StressnetChainConfig contains the chain parameters for the Stress test network.
        // All features except for CrossLink are enabled at launch.
        StressnetChainConfig = &amp;ChainConfig{
                ChainID:                    StressnetChainID,
                EthCompatibleChainID:       EthStressnetShard0ChainID,
                EthCompatibleShard0ChainID: EthStressnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(10),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:     big.NewInt(0),
        }

        // LocalnetChainConfig contains the chain parameters to run for local development.
        LocalnetChainConfig = &amp;ChainConfig{
                ChainID:                    TestnetChainID,
                EthCompatibleChainID:       EthTestnetShard0ChainID,
                EthCompatibleShard0ChainID: EthTestnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(0),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(3),
                SixtyPercentEpoch:          EpochTBD, // Never enable it for localnet as localnet has no external validator setup
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              EpochTBD, // Never enable it for localnet as localnet has no external validator setup
                StakingPrecompileEpoch:     big.NewInt(0),
        }

        // AllProtocolChanges ...
        // This configuration is intentionally not using keyed fields to force anyone
        // adding flags to the config to also have to set these fields.
        AllProtocolChanges = &amp;ChainConfig{
                AllProtocolChangesChainID,          // ChainID
                EthAllProtocolChangesShard0ChainID, // EthCompatibleChainID
                EthAllProtocolChangesShard0ChainID, // EthCompatibleShard0ChainID
                big.NewInt(0),                      // EthCompatibleEpoch
                big.NewInt(0),                      // CrossTxEpoch
                big.NewInt(0),                      // CrossLinkEpoch
                big.NewInt(0),                      // AggregatedRewardEpoch
                big.NewInt(0),                      // StakingEpoch
                big.NewInt(0),                      // PreStakingEpoch
                big.NewInt(0),                      // QuickUnlockEpoch
                big.NewInt(0),                      // FiveSecondsEpoch
                big.NewInt(0),                      // TwoSecondsEpoch
                big.NewInt(0),                      // SixtyPercentEpoch
                big.NewInt(0),                      // RedelegationEpoch
                big.NewInt(0),                      // NoEarlyUnlockEpoch
                big.NewInt(0),                      // VRFEpoch
                big.NewInt(0),                      // PrevVRFEpoch
                big.NewInt(0),                      // MinDelegation100Epoch
                big.NewInt(0),                      // MinCommissionRateEpoch
                big.NewInt(10),                     // MinCommissionPromoPeriod
                big.NewInt(0),                      // EPoSBound35Epoch
                big.NewInt(0),                      // EIP155Epoch
                big.NewInt(0),                      // S3Epoch
                big.NewInt(0),                      // DataCopyFixEpoch
                big.NewInt(0),                      // IstanbulEpoch
                big.NewInt(0),                      // ReceiptLogEpoch
                big.NewInt(0),                      // SHA3Epoch
                big.NewInt(0),                      // HIP6And8Epoch
                big.NewInt(0),                      // StakingPrecompileEpoch
        }

        // TestChainConfig ...
        // This configuration is intentionally not using keyed fields to force anyone
        // adding flags to the config to also have to set these fields.
        TestChainConfig = &amp;ChainConfig{
                TestChainID,          // ChainID
                EthTestShard0ChainID, // EthCompatibleChainID
                EthTestShard0ChainID, // EthCompatibleShard0ChainID
                big.NewInt(0),        // EthCompatibleEpoch
                big.NewInt(0),        // CrossTxEpoch
                big.NewInt(0),        // CrossLinkEpoch
                big.NewInt(0),        // AggregatedRewardEpoch
                big.NewInt(0),        // StakingEpoch
                big.NewInt(0),        // PreStakingEpoch
                big.NewInt(0),        // QuickUnlockEpoch
                big.NewInt(0),        // FiveSecondsEpoch
                big.NewInt(0),        // TwoSecondsEpoch
                big.NewInt(0),        // SixtyPercentEpoch
                big.NewInt(0),        // RedelegationEpoch
                big.NewInt(0),        // NoEarlyUnlockEpoch
                big.NewInt(0),        // VRFEpoch
                big.NewInt(0),        // PrevVRFEpoch
                big.NewInt(0),        // MinDelegation100Epoch
                big.NewInt(0),        // MinCommissionRateEpoch
                big.NewInt(10),       // MinCommissionPromoPeriod
                big.NewInt(0),        // EPoSBound35Epoch
                big.NewInt(0),        // EIP155Epoch
                big.NewInt(0),        // S3Epoch
                big.NewInt(0),        // DataCopyFixEpoch
                big.NewInt(0),        // IstanbulEpoch
                big.NewInt(0),        // ReceiptLogEpoch
                big.NewInt(0),        // SHA3Epoch
                big.NewInt(0),        // HIP6And8Epoch
                big.NewInt(0),        // StakingPrecompileEpoch
        }

        // TestRules ...
        TestRules = TestChainConfig.Rules(new(big.Int))
)

// TrustedCheckpoint represents a set of post-processed trie roots (CHT and
// BloomTrie) associated with the appropriate section index and head hash. It is
// used to start light syncing from this checkpoint and avoid downloading the
// entire header chain while still being able to securely access old headers/logs.
type TrustedCheckpoint struct {
        Name         string      `json:"-"`
        SectionIndex uint64      `json:"sectionIndex"`
        SectionHead  common.Hash `json:"sectionHead"`
        CHTRoot      common.Hash `json:"chtRoot"`
        BloomRoot    common.Hash `json:"bloomRoot"`
}

// ChainConfig is the core config which determines the blockchain settings.
//
// ChainConfig is stored in the database on a per block basis. This means
// that any network, identified by its genesis block, can have its own
// set of configuration options.
type ChainConfig struct {
        // ChainId identifies the current chain and is used for replay protection
        ChainID *big.Int `json:"chain-id"`

        // EthCompatibleChainID identifies the chain id used for ethereum compatible transactions
        EthCompatibleChainID *big.Int `json:"eth-compatible-chain-id"`

        // EthCompatibleShard0ChainID identifies the shard 0 chain id used for ethereum compatible transactions
        EthCompatibleShard0ChainID *big.Int `json:"eth-compatible-shard-0-chain-id"`

        // EthCompatibleEpoch is the epoch where ethereum-compatible transaction starts being
        // processed.
        EthCompatibleEpoch *big.Int `json:"eth-compatible-epoch,omitempty"`

        // CrossTxEpoch is the epoch where cross-shard transaction starts being
        // processed.
        CrossTxEpoch *big.Int `json:"cross-tx-epoch,omitempty"`

        // CrossLinkEpoch is the epoch where beaconchain starts containing
        // cross-shard links.
        CrossLinkEpoch *big.Int `json:"cross-link-epoch,omitempty"`

        // AggregatedRewardEpoch is the epoch when block rewards are distributed every 64 blocks
        AggregatedRewardEpoch *big.Int `json:"aggregated-reward-epoch,omitempty"`

        // StakingEpoch is the epoch when shard assign takes staking into account
        StakingEpoch *big.Int `json:"staking-epoch,omitempty"`

        // PreStakingEpoch is the epoch we allow staking transactions
        PreStakingEpoch *big.Int `json:"prestaking-epoch,omitempty"`

        // QuickUnlockEpoch is the epoch when undelegation will be unlocked at the current epoch
        QuickUnlockEpoch *big.Int `json:"quick-unlock-epoch,omitempty"`

        // FiveSecondsEpoch is the epoch when block time is reduced to 5 seconds
        // and block rewards adjusted to 17.5 ONE/block
        FiveSecondsEpoch *big.Int `json:"five-seconds-epoch,omitempty"`

        // TwoSecondsEpoch is the epoch when block time is reduced to 2 seconds
        // and block rewards adjusted to 7 ONE/block
        TwoSecondsEpoch *big.Int `json:"two-seconds-epoch,omitempty"`

        // SixtyPercentEpoch is the epoch when internal voting power reduced from 68% to 60%
        SixtyPercentEpoch *big.Int `json:"sixty-percent-epoch,omitempty"`

        // RedelegationEpoch is the epoch when redelegation is supported and undelegation locking time
        // is restored to 7 epoch
        RedelegationEpoch *big.Int `json:"redelegation-epoch,omitempty"`

        // NoEarlyUnlockEpoch is the epoch when the early unlock of undelegated token from validators who were elected for
        // more than 7 epochs is disabled
        NoEarlyUnlockEpoch *big.Int `json:"no-early-unlock-epoch,omitempty"`

        // VRFEpoch is the epoch when VRF randomness is enabled
        VRFEpoch *big.Int `json:"vrf-epoch,omitempty"`

        // PrevVRFEpoch is the epoch when previous VRF randomness can be fetched
        PrevVRFEpoch *big.Int `json:"prev-vrf-epoch,omitempty"`

        // MinDelegation100Epoch is the epoch when min delegation is reduced from 1000 ONE to 100 ONE
        MinDelegation100Epoch *big.Int `json:"min-delegation-100-epoch,omitempty"`

        // MinCommissionRateEpoch is the epoch when policy for minimum comission rate of 5% is started
        MinCommissionRateEpoch *big.Int `json:"min-commission-rate-epoch,omitempty"`

        // MinCommissionPromoPeriod is the number of epochs when newly elected validators can have 0% commission
        MinCommissionPromoPeriod *big.Int `json:"commission-promo-period,omitempty"`

        // EPoSBound35Epoch is the epoch when the EPoS bound parameter c is changed from 15% to 35%
        EPoSBound35Epoch *big.Int `json:"epos-bound-35-epoch,omitempty"`

        // EIP155 hard fork epoch (include EIP158 too)
        EIP155Epoch *big.Int `json:"eip155-epoch,omitempty"`

        // S3 epoch is the first epoch containing S3 mainnet and all ethereum update up to Constantinople
        S3Epoch *big.Int `json:"s3-epoch,omitempty"`

        // DataCopyFix epoch is the first epoch containing fix for evm datacopy bug.
        DataCopyFixEpoch *big.Int `json:"data-copy-fix-epoch,omitempty"`

        // Istanbul epoch
        IstanbulEpoch *big.Int `json:"istanbul-epoch,omitempty"`

        // ReceiptLogEpoch is the first epoch support receiptlog
        ReceiptLogEpoch *big.Int `json:"receipt-log-epoch,omitempty"`

        // IsSHA3Epoch is the first epoch in supporting SHA3 FIPS-202 standard
        SHA3Epoch *big.Int `json:"sha3-epoch,omitempty"`

        // IsHIP6And8Epoch is the first epoch to support HIP-6 and HIP-8
        HIP6And8Epoch *big.Int `json:"hip6_8-epoch,omitempty"`

        // StakingPrecompileEpoch is the first epoch to support the staking precompiles
        StakingPrecompileEpoch *big.Int `json:"staking-precompile-epoch,omitempty"`
}

// String implements the fmt.Stringer interface.
func (c *ChainConfig) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("{ChainID: %v EthCompatibleChainID: %v EIP155: %v CrossTx: %v Staking: %v CrossLink: %v ReceiptLog: %v SHA3Epoch: %v StakingPrecompileEpoch: %v}",
                c.ChainID,
                c.EthCompatibleChainID,
                c.EIP155Epoch,
                c.CrossTxEpoch,
                c.StakingEpoch,
                c.CrossLinkEpoch,
                c.ReceiptLogEpoch,
                c.SHA3Epoch,
                c.StakingPrecompileEpoch,
        )
}</span>

// IsEIP155 returns whether epoch is either equal to the EIP155 fork epoch or greater.
func (c *ChainConfig) IsEIP155(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.EIP155Epoch, epoch)
}</span>

// AcceptsCrossTx returns whether cross-shard transaction is accepted in the
// given epoch.
//
// Note that this is different from comparing epoch against CrossTxEpoch.
// Cross-shard transaction is accepted from CrossTxEpoch+1 and on, in order to
// allow for all shards to roll into CrossTxEpoch and become able to handle
// ingress receipts.  In other words, cross-shard transaction fields are
// introduced and ingress receipts are processed at CrossTxEpoch, but the shard
// does not accept cross-shard transactions from clients until CrossTxEpoch+1.
func (c *ChainConfig) AcceptsCrossTx(epoch *big.Int) bool <span class="cov8" title="1">{
        crossTxEpoch := new(big.Int).Add(c.CrossTxEpoch, common.Big1)
        return isForked(crossTxEpoch, epoch)
}</span>

// HasCrossTxFields returns whether blocks in the given epoch includes
// cross-shard transaction fields.
func (c *ChainConfig) HasCrossTxFields(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.CrossTxEpoch, epoch)
}</span>

// IsEthCompatible determines whether it is ethereum compatible epoch
func (c *ChainConfig) IsEthCompatible(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.EthCompatibleEpoch, epoch)
}</span>

// IsAggregatedRewardEpoch determines whether it is the epoch when rewards are distributed every 64 blocks
func (c *ChainConfig) IsAggregatedRewardEpoch(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.AggregatedRewardEpoch, epoch)
}</span>

// IsStaking determines whether it is staking epoch
func (c *ChainConfig) IsStaking(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.StakingEpoch, epoch)
}</span>

// IsFiveSeconds determines whether it is the epoch to change to 5 seconds block time
func (c *ChainConfig) IsFiveSeconds(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.FiveSecondsEpoch, epoch)
}</span>

// IsTwoSeconds determines whether it is the epoch to change to 3 seconds block time
func (c *ChainConfig) IsTwoSeconds(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.TwoSecondsEpoch, epoch)
}</span>

// IsSixtyPercent determines whether it is the epoch to reduce internal voting power to 60%
func (c *ChainConfig) IsSixtyPercent(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.SixtyPercentEpoch, epoch)
}</span>

// IsRedelegation determines whether it is the epoch to support redelegation
func (c *ChainConfig) IsRedelegation(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.RedelegationEpoch, epoch)
}</span>

// IsNoEarlyUnlock determines whether it is the epoch to stop early unlock
func (c *ChainConfig) IsNoEarlyUnlock(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.NoEarlyUnlockEpoch, epoch)
}</span>

// IsVRF determines whether it is the epoch to enable vrf
func (c *ChainConfig) IsVRF(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.VRFEpoch, epoch)
}</span>

// IsPrevVRF determines whether it is the epoch to enable previous vrf
func (c *ChainConfig) IsPrevVRF(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.PrevVRFEpoch, epoch)
}</span>

// IsMinDelegation100 determines whether it is the epoch to reduce min delegation to 100
func (c *ChainConfig) IsMinDelegation100(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.MinDelegation100Epoch, epoch)
}</span>

// IsMinCommissionRate determines whether it is the epoch to start the policy of 5% min commission
func (c *ChainConfig) IsMinCommissionRate(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.MinCommissionRateEpoch, epoch)
}</span>

// IsEPoSBound35 determines whether it is the epoch to extend the EPoS bound to 35%
func (c *ChainConfig) IsEPoSBound35(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.EPoSBound35Epoch, epoch)
}</span>

// IsPreStaking determines whether staking transactions are allowed
func (c *ChainConfig) IsPreStaking(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.PreStakingEpoch, epoch)
}</span>

// IsQuickUnlock determines whether it's the epoch when the undelegation should be unlocked at end of current epoch
func (c *ChainConfig) IsQuickUnlock(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.QuickUnlockEpoch, epoch)
}</span>

// IsCrossLink returns whether epoch is either equal to the CrossLink fork epoch or greater.
func (c *ChainConfig) IsCrossLink(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.CrossLinkEpoch, epoch)
}</span>

// IsS3 returns whether epoch is either equal to the S3 fork epoch or greater.
func (c *ChainConfig) IsS3(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.S3Epoch, epoch)
}</span>

// IsDataCopyFixEpoch returns whether epoch has the fix for DataCopy evm bug.
func (c *ChainConfig) IsDataCopyFixEpoch(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.DataCopyFixEpoch, epoch)
}</span>

// IsIstanbul returns whether epoch is either equal to the Istanbul fork epoch or greater.
func (c *ChainConfig) IsIstanbul(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.IstanbulEpoch, epoch)
}</span>

// IsReceiptLog returns whether epoch is either equal to the ReceiptLog fork epoch or greater.
func (c *ChainConfig) IsReceiptLog(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.ReceiptLogEpoch, epoch)
}</span>

// IsSHA3 returns whether epoch is either equal to the IsSHA3 fork epoch or greater.
func (c *ChainConfig) IsSHA3(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.SHA3Epoch, epoch)
}</span>

// IsHIP6And8Epoch determines whether it is the epoch to support
// HIP-6: reduce the internal voting power from 60% to 49%
// HIP-8: increase external nodes from 800 to 900
func (c *ChainConfig) IsHIP6And8Epoch(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.HIP6And8Epoch, epoch)
}</span>

// IsStakingPrecompileEpoch determines whether staking
// precompiles are available in the EVM
func (c *ChainConfig) IsStakingPrecompile(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.StakingPrecompileEpoch, epoch)
}</span>

// UpdateEthChainIDByShard update the ethChainID based on shard ID.
func UpdateEthChainIDByShard(shardID uint32) <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                MainnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(MainnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                TestnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(TestnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                PangaeaChainConfig.EthCompatibleChainID = big.NewInt(0).Add(PangaeaChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                PartnerChainConfig.EthCompatibleChainID = big.NewInt(0).Add(PartnerChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                StressnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(StressnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                LocalnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(LocalnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                AllProtocolChanges.EthCompatibleChainID = big.NewInt(0).Add(AllProtocolChanges.EthCompatibleChainID, big.NewInt(int64(shardID)))
                TestChainConfig.EthCompatibleChainID = big.NewInt(0).Add(TestChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
        }</span>)
}

// IsEthCompatible returns whether the chainID is for ethereum compatible txn or not
func IsEthCompatible(chainID *big.Int) bool <span class="cov8" title="1">{
        return chainID.Cmp(EthMainnetShard0ChainID) &gt;= 0
}</span>

// GasTable returns the gas table corresponding to the current phase (homestead or homestead reprice).
//
// The returned GasTable's fields shouldn't, under any circumstances, be changed.
func (c *ChainConfig) GasTable(epoch *big.Int) GasTable <span class="cov0" title="0">{
        if epoch == nil </span><span class="cov0" title="0">{
                return GasTableR3
        }</span>
        <span class="cov0" title="0">switch </span>{
        case c.IsS3(epoch):<span class="cov0" title="0">
                return GasTableS3</span>
        default:<span class="cov0" title="0">
                return GasTableR3</span>
        }
}

// isForked returns whether a fork scheduled at epoch s is active at the given head epoch.
func isForked(s, epoch *big.Int) bool <span class="cov8" title="1">{
        if s == nil || epoch == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return s.Cmp(epoch) &lt;= 0</span>
}

// Rules wraps ChainConfig and is merely syntactic sugar or can be used for functions
// that do not have or require information about the block.
//
// Rules is a one time interface meaning that it shouldn't be used in between transition
// phases.
type Rules struct {
        ChainID                                                                                              *big.Int
        EthChainID                                                                                           *big.Int
        IsCrossLink, IsEIP155, IsS3, IsReceiptLog, IsIstanbul, IsVRF, IsPrevVRF, IsSHA3, IsStakingPrecompile bool
}

// Rules ensures c's ChainID is not nil.
func (c *ChainConfig) Rules(epoch *big.Int) Rules <span class="cov8" title="1">{
        chainID := c.ChainID
        if chainID == nil </span><span class="cov0" title="0">{
                chainID = new(big.Int)
        }</span>
        <span class="cov8" title="1">ethChainID := c.EthCompatibleChainID
        if ethChainID == nil </span><span class="cov0" title="0">{
                ethChainID = new(big.Int)
        }</span>
        <span class="cov8" title="1">return Rules{
                ChainID:             new(big.Int).Set(chainID),
                EthChainID:          new(big.Int).Set(ethChainID),
                IsCrossLink:         c.IsCrossLink(epoch),
                IsEIP155:            c.IsEIP155(epoch),
                IsS3:                c.IsS3(epoch),
                IsReceiptLog:        c.IsReceiptLog(epoch),
                IsIstanbul:          c.IsIstanbul(epoch),
                IsVRF:               c.IsVRF(epoch),
                IsPrevVRF:           c.IsPrevVRF(epoch),
                IsSHA3:              c.IsSHA3(epoch),
                IsStakingPrecompile: c.IsStakingPrecompile(epoch),
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package staking

import (
        "math/big"
        "strings"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/accounts/abi"
        "github.com/pkg/errors"
)

var abiStaking abi.ABI

func init() {
        // for commission rates =&gt; solidity does not support floats directly
        // so send commission rates as string
        StakingABIJ<span class="cov8" title="1">SON := `
        [
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "delegatorAddress",
                "type": "address"
              }
            ],
            "name": "CollectRewards",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "delegatorAddress",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "validatorAddress",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              }
            ],
            "name": "Delegate",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "delegatorAddress",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "validatorAddress",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              }
            ],
            "name": "Undelegate",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          }
        ]
        `
        abiStaking, _ = abi.JSON(strings.NewReader(StakingABIJSON))
}

func ParseStakingMethod(input []byte) (*abi.Method, error) {
        return abiStaking.MethodById(input)
}

// used to ensure caller == delegatorAddress
func ValidateContractAddress(contractCaller common.Address, args map[string]interface{}, key string) (common.Address, error) {
        address, err := ParseAddressFromKey(args, key)
        if err != nil {
                return common.Address{}, err
        }
        if contractCaller != address {
                return common.Address{}, errors.Errorf(
                        "[StakingPrecompile] Address mismatch, expected %s have %s",
                        contractCaller.String(), address.String(),
                )
        } else {
                return address, nil
        }
}

// used for both delegatorAddress and validatorAddress
func ParseAddressFromKey(args map[string]interface{}, key string) (common.Address, error) {
        if byteAddress, ok := args[key].([]byte); ok {
                address := common.BytesToAddress(byteAddress)
                return address, nil
        } else if address, ok := args[key].(common.Address); ok {
                return address, nil
        } else {
                return common.Address{}, errors.Errorf("Cannot parse address from %v", args[key])
        }
}

// used for amounts
func ParseBigIntFromKey(args map[string]interface{}, key string) (*big.Int, error) {
        bigInt, ok := args[key].(*big.Int)
        if !ok {
                return nil, errors.Errorf(
                        "Cannot parse BigInt from %v", args[key])
        } else {
                return bigInt, nil
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package types

import (
        "encoding/json"
        "math/big"

        "github.com/harmony-one/harmony/crypto/bls"
        "github.com/harmony-one/harmony/shard"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        bls_core "github.com/harmony-one/bls/ffi/go/bls"
        "github.com/harmony-one/harmony/common/denominations"
        "github.com/harmony-one/harmony/consensus/votepower"
        "github.com/harmony-one/harmony/crypto/hash"
        common2 "github.com/harmony-one/harmony/internal/common"
        "github.com/harmony-one/harmony/internal/genesis"
        "github.com/harmony-one/harmony/numeric"
        "github.com/harmony-one/harmony/staking/effective"
        "github.com/pkg/errors"
)

// Define validator staking related const
const (
        MaxNameLength            = 140
        MaxIdentityLength        = 140
        MaxWebsiteLength         = 140
        MaxSecurityContactLength = 140
        MaxDetailsLength         = 280
        BLSVerificationStr       = "harmony-one"
        TenThousand              = 10000
        APRHistoryLength         = 30
        SigningHistoryLength     = 30
)

var (
        errAddressNotMatch = errors.New("validator key not match")
        // ErrInvalidSelfDelegation ..
        ErrInvalidSelfDelegation = errors.New(
                "self delegation can not be less than min_self_delegation",
        )
        errInvalidTotalDelegation = errors.New(
                "total delegation can not be bigger than max_total_delegation",
        )
        errMinSelfDelegationTooSmall = errors.New(
                "min_self_delegation must be greater than or equal to 10,000 ONE",
        )
        errInvalidMaxTotalDelegation = errors.New(
                "max_total_delegation can not be less than min_self_delegation",
        )
        errCommissionRateTooLarge = errors.New(
                "commission rate and change rate can not be larger than max commission rate",
        )
        errInvalidCommissionRate = errors.New(
                "commission rate, change rate and max rate should be a value ranging from 0.0 to 1.0",
        )
        errNeedAtLeastOneSlotKey = errors.New("need at least one slot key")
        errBLSKeysNotMatchSigs   = errors.New(
                "bls keys and corresponding signatures could not be verified",
        )
        errNilMinSelfDelegation    = errors.New("MinSelfDelegation can not be nil")
        errNilMaxTotalDelegation   = errors.New("MaxTotalDelegation can not be nil")
        errSlotKeyToRemoveNotFound = errors.New("slot key to remove not found")
        errSlotKeyToAddExists      = errors.New("slot key to add already exists")
        errDuplicateSlotKeys       = errors.New("slot keys can not have duplicates")
        // ErrExcessiveBLSKeys ..
        ErrExcessiveBLSKeys        = errors.New("more slot keys provided than allowed")
        errCannotChangeBannedTrait = errors.New("cannot change validator banned status")
)

// ValidatorSnapshotReader ..
type ValidatorSnapshotReader interface {
        ReadValidatorSnapshotAtEpoch(
                epoch *big.Int,
                addr common.Address,
        ) (*ValidatorSnapshot, error)
}

type counters struct {
        // The number of blocks the validator
        // should've signed when in active mode (selected in committee)
        NumBlocksToSign *big.Int `json:"to-sign",rlp:"nil"`
        // The number of blocks the validator actually signed
        NumBlocksSigned *big.Int `json:"signed",rlp:"nil"`
}

// ValidatorWrapper contains validator,
// its delegation information
type ValidatorWrapper struct {
        Validator
        Delegations Delegations
        //
        Counters counters `json:"-"`
        // All the rewarded accumulated so far
        BlockReward *big.Int `json:"-"`
        // if the contract becomes a validator
        // store the byte code here
        ContractCode []byte `json:"contract-code",rlp:"tail"`
}

// ValidatorSnapshot contains validator snapshot and the corresponding epoch
type ValidatorSnapshot struct {
        Validator *ValidatorWrapper
        Epoch     *big.Int
}

// Computed represents current epoch
// availability measures, mostly for RPC
type Computed struct {
        Signed            *big.Int    `json:"current-epoch-signed"`
        ToSign            *big.Int    `json:"current-epoch-to-sign"`
        BlocksLeftInEpoch uint64      `json:"-"`
        Percentage        numeric.Dec `json:"current-epoch-signing-percentage"`
        IsBelowThreshold  bool        `json:"-"`
}

func (c Computed) String() string <span class="cov0" title="0">{
        s, _ := json.Marshal(c)
        return string(s)
}</span>

// NewComputed ..
func NewComputed(
        signed, toSign *big.Int,
        blocksLeft uint64,
        percent numeric.Dec,
        isBelowNow bool) *Computed <span class="cov8" title="1">{
        return &amp;Computed{signed, toSign, blocksLeft, percent, isBelowNow}
}</span>

// NewEmptyStats ..
func NewEmptyStats() *ValidatorStats <span class="cov8" title="1">{
        return &amp;ValidatorStats{
                []APREntry{},
                numeric.ZeroDec(),
                []VoteWithCurrentEpochEarning{},
                effective.Booted,
        }
}</span>

// CurrentEpochPerformance represents validator performance in the context of
// whatever current epoch is
type CurrentEpochPerformance struct {
        CurrentSigningPercentage Computed `json:"current-epoch-signing-percent"`
}

// ValidatorRPCEnhanced contains extra information for RPC consumer
type ValidatorRPCEnhanced struct {
        Wrapper              ValidatorWrapper         `json:"validator"`
        Performance          *CurrentEpochPerformance `json:"current-epoch-performance"`
        ComputedMetrics      *ValidatorStats          `json:"metrics"`
        TotalDelegated       *big.Int                 `json:"total-delegation"`
        CurrentlyInCommittee bool                     `json:"currently-in-committee"`
        EPoSStatus           string                   `json:"epos-status"`
        EPoSWinningStake     *numeric.Dec             `json:"epos-winning-stake"`
        BootedStatus         *string                  `json:"booted-status"`
        ActiveStatus         string                   `json:"active-status"`
        Lifetime             *AccumulatedOverLifetime `json:"lifetime"`
}

// AccumulatedOverLifetime ..
type AccumulatedOverLifetime struct {
        BlockReward *big.Int            `json:"reward-accumulated"`
        Signing     counters            `json:"blocks"`
        APR         numeric.Dec         `json:"apr"`
        EpochAPRs   []APREntry          `json:"epoch-apr"`
        EpochBlocks []EpochSigningEntry `json:"epoch-blocks"`
}

func (w ValidatorWrapper) String() string <span class="cov8" title="1">{
        s, _ := json.Marshal(w)
        return string(s)
}</span>

// MarshalJSON ..
func (w ValidatorWrapper) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(struct {
                Validator
                Address     string      `json:"address"`
                Delegations Delegations `json:"delegations"`
        }{
                w.Validator,
                common2.MustAddressToBech32(w.Address),
                w.Delegations,
        })
}</span>

// VoteWithCurrentEpochEarning ..
type VoteWithCurrentEpochEarning struct {
        Vote   votepower.VoteOnSubcomittee `json:"key"`
        Earned *big.Int                    `json:"earned-reward"`
}

// APREntry ..
type APREntry struct {
        Epoch *big.Int    `json:"epoch"`
        Value numeric.Dec `json:"apr"`
}

// EpochSigningEntry ..
type EpochSigningEntry struct {
        Epoch  *big.Int `json:"epoch"`
        Blocks counters `json:"blocks"`
}

// ValidatorStats to record validator's performance and history records
type ValidatorStats struct {
        // APRs is the APR history containing APR's of epochs
        APRs []APREntry `json:"-"`
        // TotalEffectiveStake is the total effective stake this validator has
        TotalEffectiveStake numeric.Dec `json:"-"`
        // MetricsPerShard ..
        MetricsPerShard []VoteWithCurrentEpochEarning `json:"by-bls-key"`
        // BootedStatus
        BootedStatus effective.BootedStatus `json:"-"`
}

func (s ValidatorStats) String() string <span class="cov0" title="0">{
        str, _ := json.Marshal(s)
        return string(str)
}</span>

// Validator - data fields for a validator
type Validator struct {
        // ECDSA address of the validator
        Address common.Address `json:"address"`
        // The BLS public key of the validator for consensus
        SlotPubKeys []bls.SerializedPublicKey `json:"bls-public-keys"`
        // The number of the last epoch this validator is
        // selected in committee (0 means never selected)
        LastEpochInCommittee *big.Int `json:"last-epoch-in-committee"`
        // validator's self declared minimum self delegation
        MinSelfDelegation *big.Int `json:"min-self-delegation"`
        // maximum total delegation allowed
        MaxTotalDelegation *big.Int `json:"max-total-delegation"`
        // Is the validator active in participating
        // committee selection process or not
        Status effective.Eligibility `json:"-"`
        // commission parameters
        Commission
        // description for the validator
        Description
        // CreationHeight is the height of creation
        CreationHeight *big.Int `json:"creation-height"`
}

// MaxBLSPerValidator ..
const MaxBLSPerValidator = 106

var (
        oneAsBigInt  = big.NewInt(denominations.One)
        minimumStake = new(big.Int).Mul(oneAsBigInt, big.NewInt(TenThousand))
)

// SanityCheck checks basic requirements of a validator
func (v *Validator) SanityCheck() error <span class="cov8" title="1">{
        if _, err := v.EnsureLength(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(v.SlotPubKeys) == 0 </span><span class="cov8" title="1">{
                return errNeedAtLeastOneSlotKey
        }</span>

        <span class="cov8" title="1">if c := len(v.SlotPubKeys); c &gt; MaxBLSPerValidator </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        ErrExcessiveBLSKeys, "have: %d allowed: %d",
                        c, MaxBLSPerValidator,
                )
        }</span>

        <span class="cov8" title="1">if v.MinSelfDelegation == nil </span><span class="cov8" title="1">{
                return errNilMinSelfDelegation
        }</span>

        <span class="cov8" title="1">if v.MaxTotalDelegation == nil </span><span class="cov8" title="1">{
                return errNilMaxTotalDelegation
        }</span>

        // MinSelfDelegation must be &gt;= 10000 ONE
        <span class="cov8" title="1">if v.MinSelfDelegation.Cmp(minimumStake) &lt; 0 </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errMinSelfDelegationTooSmall,
                        "delegation-given %s", v.MinSelfDelegation.String(),
                )
        }</span>

        // MaxTotalDelegation must not be less than MinSelfDelegation
        <span class="cov8" title="1">if v.MaxTotalDelegation.Cmp(v.MinSelfDelegation) &lt; 0 </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidMaxTotalDelegation,
                        "max-total-delegation %s min-self-delegation %s",
                        v.MaxTotalDelegation.String(),
                        v.MinSelfDelegation.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.Rate.LT(zeroPercent) || v.Rate.GT(hundredPercent) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidCommissionRate, "rate:%s", v.Rate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.MaxRate.LT(zeroPercent) || v.MaxRate.GT(hundredPercent) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidCommissionRate, "max rate:%s", v.MaxRate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.MaxChangeRate.LT(zeroPercent) || v.MaxChangeRate.GT(hundredPercent) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidCommissionRate, "max change rate:%s", v.MaxChangeRate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.Rate.GT(v.MaxRate) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errCommissionRateTooLarge,
                        "rate:%s max rate:%s", v.Rate.String(), v.MaxRate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.MaxChangeRate.GT(v.MaxRate) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errCommissionRateTooLarge,
                        "rate:%s max change rate:%s", v.Rate.String(), v.MaxChangeRate.String(),
                )
        }</span>

        <span class="cov8" title="1">allKeys := map[bls.SerializedPublicKey]struct{}{}
        for i := range v.SlotPubKeys </span><span class="cov8" title="1">{
                if _, ok := allKeys[v.SlotPubKeys[i]]; !ok </span><span class="cov8" title="1">{
                        allKeys[v.SlotPubKeys[i]] = struct{}{}
                }</span> else<span class="cov8" title="1"> {
                        return errDuplicateSlotKeys
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// TotalDelegation - return the total amount of token in delegation
func (w *ValidatorWrapper) TotalDelegation() *big.Int <span class="cov8" title="1">{
        total := big.NewInt(0)
        for _, entry := range w.Delegations </span><span class="cov8" title="1">{
                total.Add(total, entry.Amount)
        }</span>
        <span class="cov8" title="1">return total</span>
}

var (
        hundredPercent = numeric.NewDec(1)
        zeroPercent    = numeric.NewDec(0)
)

// SanityCheck checks the basic requirements
func (w *ValidatorWrapper) SanityCheck() error <span class="cov8" title="1">{
        if err := w.Validator.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Self delegation must be &gt;= MinSelfDelegation
        <span class="cov8" title="1">switch len(w.Delegations) </span>{
        case 0:<span class="cov8" title="1">
                return errors.Wrapf(
                        ErrInvalidSelfDelegation, "no self delegation given at all",
                )</span>
        default:<span class="cov8" title="1">
                if w.Status != effective.Banned &amp;&amp;
                        w.Delegations[0].Amount.Cmp(w.Validator.MinSelfDelegation) &lt; 0 </span><span class="cov8" title="1">{
                        if w.Status == effective.Active </span><span class="cov8" title="1">{
                                return errors.Wrapf(
                                        ErrInvalidSelfDelegation,
                                        "min_self_delegation %s, amount %s",
                                        w.Validator.MinSelfDelegation, w.Delegations[0].Amount.String(),
                                )
                        }</span>
                }
        }
        <span class="cov8" title="1">totalDelegation := w.TotalDelegation()
        // Total delegation must be &lt;= MaxTotalDelegation
        if totalDelegation.Cmp(w.Validator.MaxTotalDelegation) &gt; 0 </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidTotalDelegation,
                        "total %s max-total %s",
                        totalDelegation.String(),
                        w.Validator.MaxTotalDelegation.String(),
                )
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Description - some possible IRL connections
type Description struct {
        Name            string `json:"name"`             // name
        Identity        string `json:"identity"`         // optional identity signature (ex. UPort or Keybase)
        Website         string `json:"website"`          // optional website link
        SecurityContact string `json:"security-contact"` // optional security contact info
        Details         string `json:"details"`          // optional details
}

// MarshalValidator marshals the validator object
func MarshalValidator(validator Validator) ([]byte, error) <span class="cov8" title="1">{
        return rlp.EncodeToBytes(validator)
}</span>

// UnmarshalValidator unmarshal binary into Validator object
func UnmarshalValidator(by []byte) (Validator, error) <span class="cov8" title="1">{
        decoded := Validator{}
        err := rlp.DecodeBytes(by, &amp;decoded)
        return decoded, err
}</span>

// UpdateDescription returns a new Description object with d1 as the base and the fields that's not empty in d2 updated
// accordingly. An error is returned if the resulting description fields have invalid length.
func UpdateDescription(d1, d2 Description) (Description, error) <span class="cov8" title="1">{
        newDesc := d1
        if d2.Name != "" </span><span class="cov8" title="1">{
                newDesc.Name = d2.Name
        }</span>
        <span class="cov8" title="1">if d2.Identity != "" </span><span class="cov8" title="1">{
                newDesc.Identity = d2.Identity
        }</span>
        <span class="cov8" title="1">if d2.Website != "" </span><span class="cov8" title="1">{
                newDesc.Website = d2.Website
        }</span>
        <span class="cov8" title="1">if d2.SecurityContact != "" </span><span class="cov8" title="1">{
                newDesc.SecurityContact = d2.SecurityContact
        }</span>
        <span class="cov8" title="1">if d2.Details != "" </span><span class="cov8" title="1">{
                newDesc.Details = d2.Details
        }</span>

        <span class="cov8" title="1">return newDesc.EnsureLength()</span>
}

// EnsureLength ensures the length of a validator's description.
func (d Description) EnsureLength() (Description, error) <span class="cov8" title="1">{
        if len(d.Name) &gt; MaxNameLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed maximum name length %d %d", len(d.Name), MaxNameLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.Identity) &gt; MaxIdentityLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length identity %d %d", len(d.Identity), MaxIdentityLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.Website) &gt; MaxWebsiteLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length website %d %d", len(d.Website), MaxWebsiteLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.SecurityContact) &gt; MaxSecurityContactLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length %d %d", len(d.SecurityContact), MaxSecurityContactLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.Details) &gt; MaxDetailsLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length for details %d %d", len(d.Details), MaxDetailsLength,
                )
        }</span>

        <span class="cov8" title="1">return d, nil</span>
}

// VerifyBLSKeys checks if the public BLS key at index i of pubKeys matches the
// BLS key signature at index i of pubKeysSigs.
func VerifyBLSKeys(pubKeys []bls.SerializedPublicKey, pubKeySigs []bls.SerializedSignature) error <span class="cov8" title="1">{
        if len(pubKeys) != len(pubKeySigs) </span><span class="cov8" title="1">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(pubKeys); i++ </span><span class="cov8" title="1">{
                if err := VerifyBLSKey(&amp;pubKeys[i], &amp;pubKeySigs[i]); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VerifyBLSKey checks if the public BLS key matches the BLS signature
func VerifyBLSKey(pubKey *bls.SerializedPublicKey, pubKeySig *bls.SerializedSignature) error <span class="cov8" title="1">{
        if len(pubKeySig) == 0 </span><span class="cov0" title="0">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">blsPubKey, err := bls.BytesToBLSPublicKey(pubKey[:])
        if err != nil </span><span class="cov0" title="0">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">msgSig := bls_core.Sign{}
        if err := msgSig.Deserialize(pubKeySig[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">messageBytes := []byte(BLSVerificationStr)
        msgHash := hash.Keccak256(messageBytes)
        if !msgSig.VerifyHash(blsPubKey, msgHash[:]) </span><span class="cov8" title="1">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func containsHarmonyBLSKeys(
        blsKeys []bls.SerializedPublicKey,
        hmyAccounts []genesis.DeployAccount,
        epoch *big.Int,
) error <span class="cov8" title="1">{
        for i := range blsKeys </span><span class="cov8" title="1">{
                if err := matchesHarmonyBLSKey(
                        &amp;blsKeys[i], hmyAccounts, epoch,
                ); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func matchesHarmonyBLSKey(
        blsKey *bls.SerializedPublicKey,
        hmyAccounts []genesis.DeployAccount,
        epoch *big.Int,
) error <span class="cov8" title="1">{
        type publicKeyAsHex = string
        cache := map[string]map[publicKeyAsHex]struct{}{}
        return func() error </span><span class="cov8" title="1">{
                key := epoch.String()
                if _, ok := cache[key]; !ok </span><span class="cov8" title="1">{
                        // one time cost per epoch
                        cache[key] = map[publicKeyAsHex]struct{}{}
                        for i := range hmyAccounts </span><span class="cov8" title="1">{
                                // invariant assume it is hex
                                cache[key][hmyAccounts[i].BLSPublicKey] = struct{}{}
                        }</span>
                }

                <span class="cov8" title="1">hex := blsKey.Hex()
                if _, exists := cache[key][hex]; exists </span><span class="cov8" title="1">{
                        return errors.Wrapf(
                                errDuplicateSlotKeys,
                                "slot key %s conflicts with internal keys",
                                hex,
                        )
                }</span>
                <span class="cov8" title="1">return nil</span>
        }()
}

// CreateValidatorFromNewMsg creates validator from NewValidator message
func CreateValidatorFromNewMsg(
        val *CreateValidator, blockNum, epoch *big.Int,
) (*Validator, error) <span class="cov8" title="1">{
        desc, err := val.Description.EnsureLength()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">commission := Commission{val.CommissionRates, blockNum}
        pubKeys := append(val.SlotPubKeys[0:0], val.SlotPubKeys...)

        instance := shard.Schedule.InstanceForEpoch(epoch)
        if err := containsHarmonyBLSKeys(
                pubKeys, instance.HmyAccounts(), epoch,
        ); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = VerifyBLSKeys(pubKeys, val.SlotKeySigs); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">v := Validator{
                Address:              val.ValidatorAddress,
                SlotPubKeys:          pubKeys,
                LastEpochInCommittee: new(big.Int),
                MinSelfDelegation:    val.MinSelfDelegation,
                MaxTotalDelegation:   val.MaxTotalDelegation,
                Status:               effective.Active,
                Commission:           commission,
                Description:          desc,
                CreationHeight:       blockNum,
        }
        return &amp;v, nil</span>
}

// UpdateValidatorFromEditMsg updates validator from EditValidator message
func UpdateValidatorFromEditMsg(validator *Validator, edit *EditValidator, epoch *big.Int) error <span class="cov8" title="1">{
        if validator.Address != edit.ValidatorAddress </span><span class="cov8" title="1">{
                return errAddressNotMatch
        }</span>
        <span class="cov8" title="1">desc, err := UpdateDescription(validator.Description, edit.Description)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">validator.Description = desc

        if edit.CommissionRate != nil </span><span class="cov8" title="1">{
                validator.Rate = *edit.CommissionRate
        }</span>

        <span class="cov8" title="1">if edit.MinSelfDelegation != nil &amp;&amp; edit.MinSelfDelegation.Sign() != 0 </span><span class="cov8" title="1">{
                validator.MinSelfDelegation = edit.MinSelfDelegation
        }</span>

        <span class="cov8" title="1">if edit.MaxTotalDelegation != nil &amp;&amp; edit.MaxTotalDelegation.Sign() != 0 </span><span class="cov8" title="1">{
                validator.MaxTotalDelegation = edit.MaxTotalDelegation
        }</span>

        <span class="cov8" title="1">if edit.SlotKeyToRemove != nil </span><span class="cov8" title="1">{
                index := -1
                for i, key := range validator.SlotPubKeys </span><span class="cov8" title="1">{
                        if key == *edit.SlotKeyToRemove </span><span class="cov8" title="1">{
                                index = i
                                break</span>
                        }
                }
                // we found key to be removed
                <span class="cov8" title="1">if index &gt;= 0 </span><span class="cov8" title="1">{
                        validator.SlotPubKeys = append(
                                validator.SlotPubKeys[:index], validator.SlotPubKeys[index+1:]...,
                        )
                }</span> else<span class="cov8" title="1"> {
                        return errSlotKeyToRemoveNotFound
                }</span>
        }

        <span class="cov8" title="1">if edit.SlotKeyToAdd != nil </span><span class="cov8" title="1">{
                found := false
                for _, key := range validator.SlotPubKeys </span><span class="cov8" title="1">{
                        if key == *edit.SlotKeyToAdd </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        instance := shard.Schedule.InstanceForEpoch(epoch)
                        if err := matchesHarmonyBLSKey(
                                edit.SlotKeyToAdd, instance.HmyAccounts(), epoch,
                        ); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := VerifyBLSKey(edit.SlotKeyToAdd, edit.SlotKeyToAddSig); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">validator.SlotPubKeys = append(validator.SlotPubKeys, *edit.SlotKeyToAdd)</span>
                } else<span class="cov8" title="1"> {
                        return errSlotKeyToAddExists
                }</span>
        }

        <span class="cov8" title="1">switch validator.Status </span>{
        case effective.Banned:<span class="cov8" title="1">
                return errCannotChangeBannedTrait</span>
        default:<span class="cov8" title="1">
                switch edit.EPOSStatus </span>{
                case effective.Active, effective.Inactive:<span class="cov8" title="1">
                        validator.Status = edit.EPOSStatus</span>
                default:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// String returns a human readable string representation of a validator.
func (v Validator) String() string <span class="cov0" title="0">{
        s, _ := json.Marshal(v)
        return string(s)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
