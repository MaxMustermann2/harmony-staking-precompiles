
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/harmony-one/harmony/core/blockchain.go (24.2%)</option>
				
				<option value="file1">github.com/harmony-one/harmony/core/chain_makers.go (0.0%)</option>
				
				<option value="file2">github.com/harmony-one/harmony/core/evm.go (65.8%)</option>
				
				<option value="file3">github.com/harmony-one/harmony/core/offchain.go (29.8%)</option>
				
				<option value="file4">github.com/harmony-one/harmony/core/staking_verifier.go (96.2%)</option>
				
				<option value="file5">github.com/harmony-one/harmony/core/state_processor.go (49.6%)</option>
				
				<option value="file6">github.com/harmony-one/harmony/core/state_transition.go (69.4%)</option>
				
				<option value="file7">github.com/harmony-one/harmony/core/tx_pool.go (61.0%)</option>
				
				<option value="file8">github.com/harmony-one/harmony/core/vm/contracts.go (77.6%)</option>
				
				<option value="file9">github.com/harmony-one/harmony/core/vm/contracts_write.go (75.9%)</option>
				
				<option value="file10">github.com/harmony-one/harmony/core/vm/evm.go (37.9%)</option>
				
				<option value="file11">github.com/harmony-one/harmony/core/vm/gas.go (63.3%)</option>
				
				<option value="file12">github.com/harmony-one/harmony/hmy/tracer.go (0.0%)</option>
				
				<option value="file13">github.com/harmony-one/harmony/internal/params/config.go (60.7%)</option>
				
				<option value="file14">github.com/harmony-one/harmony/node/worker/worker.go (42.5%)</option>
				
				<option value="file15">github.com/harmony-one/harmony/rosetta/services/construction_check.go (23.4%)</option>
				
				<option value="file16">github.com/harmony-one/harmony/staking/precompile.go (88.0%)</option>
				
				<option value="file17">github.com/harmony-one/harmony/staking/types/messages.go (89.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

// Package core implements the Ethereum consensus protocol.
package core

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "math/big"
        "os"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/mclock"
        "github.com/ethereum/go-ethereum/common/prque"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/ethdb"
        "github.com/ethereum/go-ethereum/event"
        "github.com/ethereum/go-ethereum/metrics"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/consensus/reward"
        "github.com/harmony-one/harmony/consensus/votepower"
        "github.com/harmony-one/harmony/core/rawdb"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/numeric"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/shard/committee"
        "github.com/harmony-one/harmony/staking/apr"
        "github.com/harmony-one/harmony/staking/effective"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        lru "github.com/hashicorp/golang-lru"
        "github.com/pkg/errors"
)

var (
        // blockInsertTimer
        blockInsertTimer = metrics.NewRegisteredTimer("chain/inserts", nil)
        // ErrNoGenesis is the error when there is no genesis.
        ErrNoGenesis = errors.New("Genesis not found in chain")
        // errExceedMaxPendingSlashes ..
        errExceedMaxPendingSlashes = errors.New("exceeed max pending slashes")
        errNilEpoch                = errors.New("nil epoch for voting power computation")
)

const (
        bodyCacheLimit                     = 2048
        blockCacheLimit                    = 2048
        receiptsCacheLimit                 = 32
        maxFutureBlocks                    = 256
        maxTimeFutureBlocks                = 30
        badBlockLimit                      = 10
        triesInMemory                      = 128
        shardCacheLimit                    = 10
        commitsCacheLimit                  = 10
        epochCacheLimit                    = 10
        randomnessCacheLimit               = 10
        validatorCacheLimit                = 1024
        validatorStatsCacheLimit           = 1024
        validatorListCacheLimit            = 10
        validatorListByDelegatorCacheLimit = 1024
        pendingCrossLinksCacheLimit        = 2
        blockAccumulatorCacheLimit         = 256
        maxPendingSlashes                  = 512
        // BlockChainVersion ensures that an incompatible database forces a resync from scratch.
        BlockChainVersion = 3
        pendingCLCacheKey = "pendingCLs"
)

// CacheConfig contains the configuration values for the trie caching/pruning
// that's resident in a blockchain.
type CacheConfig struct {
        Disabled      bool          // Whether to disable trie write caching (archive node)
        TrieNodeLimit int           // Memory limit (MB) at which to flush the current in-memory trie to disk
        TrieTimeLimit time.Duration // Time limit after which to flush the current in-memory trie to disk
}

// BlockChain represents the canonical chain given a database with a genesis
// block. The Blockchain manages chain imports, reverts, chain reorganisations.
//
// Importing blocks in to the block chain happens according to the set of rules
// defined by the two stage validator. Processing of blocks is done using the
// Processor which processes the included transaction. The validation of the state
// is done in the second part of the validator. Failing results in aborting of
// the import.
//
// The BlockChain also helps in returning blocks from **any** chain included
// in the database as well as blocks that represents the canonical chain. It's
// important to note that GetBlock can return any block and does not need to be
// included in the canonical one where as GetBlockByNumber always represents the
// canonical chain.
type BlockChain struct {
        chainConfig *params.ChainConfig // Chain &amp; network configuration
        cacheConfig *CacheConfig        // Cache configuration for pruning

        db     ethdb.Database // Low level persistent database to store final content in
        triegc *prque.Prque   // Priority queue mapping block numbers to tries to gc
        gcproc time.Duration  // Accumulates canonical block processing for trie dumping

        hc            *HeaderChain
        rmLogsFeed    event.Feed
        chainFeed     event.Feed
        chainSideFeed event.Feed
        chainHeadFeed event.Feed
        logsFeed      event.Feed
        scope         event.SubscriptionScope
        genesisBlock  *types.Block

        mu                          sync.RWMutex // global mutex for locking chain operations
        chainmu                     sync.RWMutex // blockchain insertion lock
        procmu                      sync.RWMutex // block processor lock
        pendingCrossLinksMutex      sync.RWMutex // pending crosslinks lock
        pendingSlashingCandidatesMU sync.RWMutex // pending slashing candidates

        currentBlock     atomic.Value // Current head of the block chain
        currentFastBlock atomic.Value // Current head of the fast-sync chain (may be above the block chain!)

        stateCache                    state.Database // State database to reuse between imports (contains state cache)
        bodyCache                     *lru.Cache     // Cache for the most recent block bodies
        bodyRLPCache                  *lru.Cache     // Cache for the most recent block bodies in RLP encoded format
        receiptsCache                 *lru.Cache     // Cache for the most recent receipts per block
        blockCache                    *lru.Cache     // Cache for the most recent entire blocks
        futureBlocks                  *lru.Cache     // future blocks are blocks added for later processing
        shardStateCache               *lru.Cache
        lastCommitsCache              *lru.Cache
        epochCache                    *lru.Cache    // Cache epoch number â†’ first block number
        randomnessCache               *lru.Cache    // Cache for vrf/vdf
        validatorSnapshotCache        *lru.Cache    // Cache for validator snapshot
        validatorStatsCache           *lru.Cache    // Cache for validator stats
        validatorListCache            *lru.Cache    // Cache of validator list
        validatorListByDelegatorCache *lru.Cache    // Cache of validator list by delegator
        pendingCrossLinksCache        *lru.Cache    // Cache of last pending crosslinks
        blockAccumulatorCache         *lru.Cache    // Cache of block accumulators
        quit                          chan struct{} // blockchain quit channel
        running                       int32         // running must be called atomically
        // procInterrupt must be atomically called
        procInterrupt int32          // interrupt signaler for block processing
        wg            sync.WaitGroup // chain processing wait group for shutting down

        engine                 consensus_engine.Engine
        processor              Processor // block processor interface
        validator              Validator // block and state validator interface
        vmConfig               vm.Config
        badBlocks              *lru.Cache              // Bad block cache
        shouldPreserve         func(*types.Block) bool // Function used to determine whether should preserve the given block.
        pendingSlashes         slash.Records
        maxGarbCollectedBlkNum int64
}

// NewBlockChain returns a fully initialised block chain using information
// available in the database. It initialises the default Ethereum validator and
// Processor.
func NewBlockChain(
        db ethdb.Database, cacheConfig *CacheConfig, chainConfig *params.ChainConfig,
        engine consensus_engine.Engine, vmConfig vm.Config,
        shouldPreserve func(block *types.Block) bool,
) (*BlockChain, error) <span class="cov8" title="1">{
        if cacheConfig == nil </span><span class="cov8" title="1">{
                cacheConfig = &amp;CacheConfig{
                        TrieNodeLimit: 256 * 1024 * 1024,
                        TrieTimeLimit: 2 * time.Minute,
                }
        }</span>
        <span class="cov8" title="1">bodyCache, _ := lru.New(bodyCacheLimit)
        bodyRLPCache, _ := lru.New(bodyCacheLimit)
        receiptsCache, _ := lru.New(receiptsCacheLimit)
        blockCache, _ := lru.New(blockCacheLimit)
        futureBlocks, _ := lru.New(maxFutureBlocks)
        badBlocks, _ := lru.New(badBlockLimit)
        shardCache, _ := lru.New(shardCacheLimit)
        commitsCache, _ := lru.New(commitsCacheLimit)
        epochCache, _ := lru.New(epochCacheLimit)
        randomnessCache, _ := lru.New(randomnessCacheLimit)
        validatorCache, _ := lru.New(validatorCacheLimit)
        validatorStatsCache, _ := lru.New(validatorStatsCacheLimit)
        validatorListCache, _ := lru.New(validatorListCacheLimit)
        validatorListByDelegatorCache, _ := lru.New(validatorListByDelegatorCacheLimit)
        pendingCrossLinksCache, _ := lru.New(pendingCrossLinksCacheLimit)
        blockAccumulatorCache, _ := lru.New(blockAccumulatorCacheLimit)

        bc := &amp;BlockChain{
                chainConfig:                   chainConfig,
                cacheConfig:                   cacheConfig,
                db:                            db,
                triegc:                        prque.New(nil),
                stateCache:                    state.NewDatabase(db),
                quit:                          make(chan struct{}),
                shouldPreserve:                shouldPreserve,
                bodyCache:                     bodyCache,
                bodyRLPCache:                  bodyRLPCache,
                receiptsCache:                 receiptsCache,
                blockCache:                    blockCache,
                futureBlocks:                  futureBlocks,
                shardStateCache:               shardCache,
                lastCommitsCache:              commitsCache,
                epochCache:                    epochCache,
                randomnessCache:               randomnessCache,
                validatorSnapshotCache:        validatorCache,
                validatorStatsCache:           validatorStatsCache,
                validatorListCache:            validatorListCache,
                validatorListByDelegatorCache: validatorListByDelegatorCache,
                pendingCrossLinksCache:        pendingCrossLinksCache,
                blockAccumulatorCache:         blockAccumulatorCache,
                engine:                        engine,
                vmConfig:                      vmConfig,
                badBlocks:                     badBlocks,
                pendingSlashes:                slash.Records{},
                maxGarbCollectedBlkNum:        -1,
        }
        bc.SetValidator(NewBlockValidator(chainConfig, bc, engine))
        bc.SetProcessor(NewStateProcessor(chainConfig, bc, engine))

        var err error
        bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">bc.genesisBlock = bc.GetBlockByNumber(0)
        if bc.genesisBlock == nil </span><span class="cov0" title="0">{
                return nil, ErrNoGenesis
        }</span>
        <span class="cov8" title="1">var nilBlock *types.Block
        bc.currentBlock.Store(nilBlock)
        bc.currentFastBlock.Store(nilBlock)
        if err := bc.loadLastState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Take ownership of this particular state
        <span class="cov8" title="1">go bc.update()
        return bc, nil</span>
}

// ValidateNewBlock validates new block.
func (bc *BlockChain) ValidateNewBlock(block *types.Block) error <span class="cov8" title="1">{
        state, err := state.New(bc.CurrentBlock().Root(), bc.stateCache)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // NOTE Order of mutating state here matters.
        // Process block using the parent state as reference point.
        // Do not read cache from processor.
        <span class="cov8" title="1">receipts, cxReceipts, _, _, usedGas, _, _, err := bc.processor.Process(
                block, state, bc.vmConfig, false,
        )
        if err != nil </span><span class="cov0" title="0">{
                bc.reportBlock(block, receipts, err)
                return err
        }</span>

        // Verify all the hash roots (state, txns, receipts, cross-shard)
        <span class="cov8" title="1">if err := bc.Validator().ValidateState(
                block, state, receipts, cxReceipts, usedGas,
        ); err != nil </span><span class="cov0" title="0">{
                bc.reportBlock(block, receipts, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsEpochBlock returns whether this block is the first block of an epoch.
// by checking if the previous block is the last block of the previous epoch
func IsEpochBlock(block *types.Block) bool <span class="cov8" title="1">{
        if block.NumberU64() == 0 </span><span class="cov8" title="1">{
                // genesis block is the first epoch block
                return true
        }</span>
        <span class="cov8" title="1">return shard.Schedule.IsLastBlock(block.NumberU64() - 1)</span>
}

func (bc *BlockChain) getProcInterrupt() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;bc.procInterrupt) == 1
}</span>

// loadLastState loads the last known chain state from the database. This method
// assumes that the chain manager mutex is held.
func (bc *BlockChain) loadLastState() error <span class="cov8" title="1">{
        // Restore the last known head block
        head := rawdb.ReadHeadBlockHash(bc.db)
        if head == (common.Hash{}) </span><span class="cov0" title="0">{
                // Corrupt or empty database, init from scratch
                utils.Logger().Warn().Msg("Empty database, resetting chain")
                return bc.Reset()
        }</span>
        // Make sure the entire head block is available
        <span class="cov8" title="1">currentBlock := bc.GetBlockByHash(head)
        if currentBlock == nil </span><span class="cov0" title="0">{
                // Corrupt or empty database, init from scratch
                utils.Logger().Warn().Str("hash", head.Hex()).Msg("Head block missing, resetting chain")
                return bc.Reset()
        }</span>
        // Make sure the state associated with the block is available
        <span class="cov8" title="1">if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil </span><span class="cov0" title="0">{
                // Dangling block without a state associated, init from scratch
                utils.Logger().Warn().
                        Str("number", currentBlock.Number().String()).
                        Str("hash", currentBlock.Hash().Hex()).
                        Msg("Head state missing, repairing chain")
                if err := bc.repair(&amp;currentBlock); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // Everything seems to be fine, set as the head block
        <span class="cov8" title="1">bc.currentBlock.Store(currentBlock)

        // We don't need the following as we want the current header and block to be consistent
        // Restore the last known head header
        //currentHeader := currentBlock.Header()
        //if head := rawdb.ReadHeadHeaderHash(bc.db); head != (common.Hash{}) {
        //        if header := bc.GetHeaderByHash(head); header != nil {
        //                currentHeader = header
        //        }
        //}
        currentHeader := currentBlock.Header()
        if err := bc.hc.SetCurrentHeader(currentHeader); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "headerChain SetCurrentHeader")
        }</span>

        // Restore the last known head fast block
        <span class="cov8" title="1">bc.currentFastBlock.Store(currentBlock)
        if head := rawdb.ReadHeadFastBlockHash(bc.db); head != (common.Hash{}) </span><span class="cov0" title="0">{
                if block := bc.GetBlockByHash(head); block != nil </span><span class="cov0" title="0">{
                        bc.currentFastBlock.Store(block)
                }</span>
        }

        // Issue a status log for the user
        <span class="cov8" title="1">currentFastBlock := bc.CurrentFastBlock()

        headerTd := bc.GetTd(currentHeader.Hash(), currentHeader.Number().Uint64())
        blockTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
        fastTd := bc.GetTd(currentFastBlock.Hash(), currentFastBlock.NumberU64())

        utils.Logger().Info().
                Str("number", currentHeader.Number().String()).
                Str("hash", currentHeader.Hash().Hex()).
                Str("td", headerTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentHeader.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local header")
        utils.Logger().Info().
                Str("number", currentBlock.Number().String()).
                Str("hash", currentBlock.Hash().Hex()).
                Str("td", blockTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentBlock.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local full block")
        utils.Logger().Info().
                Str("number", currentFastBlock.Number().String()).
                Str("hash", currentFastBlock.Hash().Hex()).
                Str("td", fastTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentFastBlock.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local fast block")

        return nil</span>
}

// SetHead rewinds the local chain to a new head. In the case of headers, everything
// above the new head will be deleted and the new one set. In the case of blocks
// though, the head may be further rewound if block bodies are missing (non-archive
// nodes after a fast sync).
func (bc *BlockChain) SetHead(head uint64) error <span class="cov0" title="0">{
        utils.Logger().Warn().Uint64("target", head).Msg("Rewinding blockchain")

        bc.mu.Lock()
        defer bc.mu.Unlock()

        // Rewind the header chain, deleting all block bodies until then
        delFn := func(db rawdb.DatabaseDeleter, hash common.Hash, num uint64) error </span><span class="cov0" title="0">{
                return rawdb.DeleteBody(db, hash, num)
        }</span>
        <span class="cov0" title="0">if err := bc.hc.SetHead(head, delFn); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "headerChain SetHeader")
        }</span>
        <span class="cov0" title="0">currentHeader := bc.hc.CurrentHeader()

        // Clear out any stale content from the caches
        bc.bodyCache.Purge()
        bc.bodyRLPCache.Purge()
        bc.receiptsCache.Purge()
        bc.blockCache.Purge()
        bc.futureBlocks.Purge()
        bc.shardStateCache.Purge()

        // Rewind the block chain, ensuring we don't end up with a stateless head block
        if currentBlock := bc.CurrentBlock(); currentBlock != nil &amp;&amp; currentHeader.Number().Uint64() &lt; currentBlock.NumberU64() </span><span class="cov0" title="0">{
                bc.currentBlock.Store(bc.GetBlock(currentHeader.Hash(), currentHeader.Number().Uint64()))
        }</span>
        <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock != nil </span><span class="cov0" title="0">{
                if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil </span><span class="cov0" title="0">{
                        // Rewound state missing, rolled back to before pivot, reset to genesis
                        bc.currentBlock.Store(bc.genesisBlock)
                }</span>
        }
        // Rewind the fast block in a simpleton way to the target head
        <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock != nil &amp;&amp; currentHeader.Number().Uint64() &lt; currentFastBlock.NumberU64() </span><span class="cov0" title="0">{
                bc.currentFastBlock.Store(bc.GetBlock(currentHeader.Hash(), currentHeader.Number().Uint64()))
        }</span>
        // If either blocks reached nil, reset to the genesis state
        <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock == nil </span><span class="cov0" title="0">{
                bc.currentBlock.Store(bc.genesisBlock)
        }</span>
        <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock == nil </span><span class="cov0" title="0">{
                bc.currentFastBlock.Store(bc.genesisBlock)
        }</span>
        <span class="cov0" title="0">currentBlock := bc.CurrentBlock()
        currentFastBlock := bc.CurrentFastBlock()

        if err := rawdb.WriteHeadBlockHash(bc.db, currentBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WriteHeadFastBlockHash(bc.db, currentFastBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return bc.loadLastState()</span>
}

// ShardID returns the shard Id of the blockchain.
// TODO: use a better solution before resharding shuffle nodes to different shards
func (bc *BlockChain) ShardID() uint32 <span class="cov8" title="1">{
        return bc.CurrentBlock().ShardID()
}</span>

// GasLimit returns the gas limit of the current HEAD block.
func (bc *BlockChain) GasLimit() uint64 <span class="cov0" title="0">{
        return bc.CurrentBlock().GasLimit()
}</span>

// CurrentBlock retrieves the current head block of the canonical chain. The
// block is retrieved from the blockchain's internal cache.
func (bc *BlockChain) CurrentBlock() *types.Block <span class="cov8" title="1">{
        return bc.currentBlock.Load().(*types.Block)
}</span>

// CurrentFastBlock retrieves the current fast-sync head block of the canonical
// chain. The block is retrieved from the blockchain's internal cache.
func (bc *BlockChain) CurrentFastBlock() *types.Block <span class="cov8" title="1">{
        return bc.currentFastBlock.Load().(*types.Block)
}</span>

// SetProcessor sets the processor required for making state modifications.
func (bc *BlockChain) SetProcessor(processor Processor) <span class="cov8" title="1">{
        bc.procmu.Lock()
        defer bc.procmu.Unlock()
        bc.processor = processor
}</span>

// SetValidator sets the validator which is used to validate incoming blocks.
func (bc *BlockChain) SetValidator(validator Validator) <span class="cov8" title="1">{
        bc.procmu.Lock()
        defer bc.procmu.Unlock()
        bc.validator = validator
}</span>

// Validator returns the current validator.
func (bc *BlockChain) Validator() Validator <span class="cov8" title="1">{
        bc.procmu.RLock()
        defer bc.procmu.RUnlock()
        return bc.validator
}</span>

// Processor returns the current processor.
func (bc *BlockChain) Processor() Processor <span class="cov0" title="0">{
        bc.procmu.RLock()
        defer bc.procmu.RUnlock()
        return bc.processor
}</span>

// State returns a new mutable state based on the current HEAD block.
func (bc *BlockChain) State() (*state.DB, error) <span class="cov0" title="0">{
        return bc.StateAt(bc.CurrentBlock().Root())
}</span>

// StateAt returns a new mutable state based on a particular point in time.
func (bc *BlockChain) StateAt(root common.Hash) (*state.DB, error) <span class="cov8" title="1">{
        return state.New(root, bc.stateCache)
}</span>

// Reset purges the entire blockchain, restoring it to its genesis state.
func (bc *BlockChain) Reset() error <span class="cov0" title="0">{
        return bc.ResetWithGenesisBlock(bc.genesisBlock)
}</span>

// ResetWithGenesisBlock purges the entire blockchain, restoring it to the
// specified genesis state.
func (bc *BlockChain) ResetWithGenesisBlock(genesis *types.Block) error <span class="cov0" title="0">{
        // Dump the entire block chain and purge the caches
        if err := bc.SetHead(0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.mu.Lock()
        defer bc.mu.Unlock()

        // Prepare the genesis block and reinitialise the chain
        if err := rawdb.WriteBlock(bc.db, genesis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bc.genesisBlock = genesis
        if err := bc.insert(bc.genesisBlock); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.hc.SetGenesis(bc.genesisBlock.Header())
        if err := bc.hc.SetCurrentHeader(bc.genesisBlock.Header()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.currentBlock.Store(bc.genesisBlock)
        bc.currentFastBlock.Store(bc.genesisBlock)

        return nil</span>
}

// repair tries to repair the current blockchain by rolling back the current block
// until one with associated state is found. This is needed to fix incomplete db
// writes caused either by crashes/power outages, or simply non-committed tries.
//
// This method only rolls back the current block. The current header and current
// fast block are left intact.
func (bc *BlockChain) repair(head **types.Block) error <span class="cov0" title="0">{
        valsToRemove := map[common.Address]struct{}{}
        for </span><span class="cov0" title="0">{
                // Abort if we've rewound to a head block that does have associated state
                if _, err := state.New((*head).Root(), bc.stateCache); err == nil </span><span class="cov0" title="0">{
                        utils.Logger().Info().
                                Str("number", (*head).Number().String()).
                                Str("hash", (*head).Hash().Hex()).
                                Msg("Rewound blockchain to past state")
                        return bc.removeInValidatorList(valsToRemove)
                }</span>
                // Repair last commit sigs
                <span class="cov0" title="0">lastSig := (*head).Header().LastCommitSignature()
                sigAndBitMap := append(lastSig[:], (*head).Header().LastCommitBitmap()...)
                bc.WriteCommitSig((*head).NumberU64()-1, sigAndBitMap)

                // Otherwise rewind one block and recheck state availability there
                for _, stkTxn := range (*head).StakingTransactions() </span><span class="cov0" title="0">{
                        if stkTxn.StakingType() == staking.DirectiveCreateValidator </span><span class="cov0" title="0">{
                                if addr, err := stkTxn.SenderAddress(); err == nil </span><span class="cov0" title="0">{
                                        valsToRemove[addr] = struct{}{}
                                }</span> else<span class="cov0" title="0"> {
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">block := bc.GetBlock((*head).ParentHash(), (*head).NumberU64()-1)
                if block == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing block %d [%x]", (*head).NumberU64()-1, (*head).ParentHash())
                }</span>
                <span class="cov0" title="0">*head = block</span>
        }
}

// This func is used to remove the validator addresses from the validator list.
func (bc *BlockChain) removeInValidatorList(toRemove map[common.Address]struct{}) error <span class="cov0" title="0">{
        if len(toRemove) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">utils.Logger().Info().
                Interface("validators", toRemove).
                Msg("Removing validators from validator list")

        existingVals, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">newVals := []common.Address{}
        for _, addr := range existingVals </span><span class="cov0" title="0">{
                if _, ok := toRemove[addr]; !ok </span><span class="cov0" title="0">{
                        newVals = append(newVals, addr)
                }</span>
        }
        <span class="cov0" title="0">return bc.WriteValidatorList(bc.db, newVals)</span>
}

// Export writes the active chain to the given writer.
func (bc *BlockChain) Export(w io.Writer) error <span class="cov0" title="0">{
        return bc.ExportN(w, uint64(0), bc.CurrentBlock().NumberU64())
}</span>

// ExportN writes a subset of the active chain to the given writer.
func (bc *BlockChain) ExportN(w io.Writer, first uint64, last uint64) error <span class="cov0" title="0">{
        bc.mu.RLock()
        defer bc.mu.RUnlock()

        if first &gt; last </span><span class="cov0" title="0">{
                return fmt.Errorf("export failed: first (%d) is greater than last (%d)", first, last)
        }</span>
        <span class="cov0" title="0">utils.Logger().Info().Uint64("count", last-first+1).Msg("Exporting batch of blocks")

        start, reported := time.Now(), time.Now()
        for nr := first; nr &lt;= last; nr++ </span><span class="cov0" title="0">{
                block := bc.GetBlockByNumber(nr)
                if block == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("export failed on #%d: not found", nr)
                }</span>
                <span class="cov0" title="0">if err := block.EncodeRLP(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if time.Since(reported) &gt;= statsReportLimit </span><span class="cov0" title="0">{
                        utils.Logger().Info().
                                Uint64("exported", block.NumberU64()-first).
                                Str("elapsed", common.PrettyDuration(time.Since(start)).String()).
                                Msg("Exporting blocks")
                        reported = time.Now()
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// writeHeadBlock writes a new head block
func (bc *BlockChain) writeHeadBlock(block *types.Block) error <span class="cov8" title="1">{
        // If the block is on a side chain or an unknown one, force other heads onto it too
        updateHeads := rawdb.ReadCanonicalHash(bc.db, block.NumberU64()) != block.Hash()

        // Add the block to the canonical chain number scheme and mark as the head
        batch := bc.ChainDb().NewBatch()
        if err := rawdb.WriteCanonicalHash(batch, block.Hash(), block.NumberU64()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WriteHeadBlockHash(batch, block.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bc.currentBlock.Store(block)

        // If the block is better than our head or is on a different chain, force update heads
        if updateHeads </span><span class="cov8" title="1">{
                if err := bc.hc.SetCurrentHeader(block.Header()); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "HeaderChain SetCurrentHeader")
                }</span>
                <span class="cov8" title="1">if err := rawdb.WriteHeadFastBlockHash(bc.db, block.Hash()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">bc.currentFastBlock.Store(block)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// insert injects a new head block into the current block chain. This method
// assumes that the block is indeed a true head. It will also reset the head
// header and the head fast sync block to this very same block if they are older
// or if they are on a different side chain.
//
// Note, this function assumes that the `mu` mutex is held!
func (bc *BlockChain) insert(block *types.Block) error <span class="cov0" title="0">{
        return bc.writeHeadBlock(block)
}</span>

// Genesis retrieves the chain's genesis block.
func (bc *BlockChain) Genesis() *types.Block <span class="cov0" title="0">{
        return bc.genesisBlock
}</span>

// GetBody retrieves a block body (transactions and uncles) from the database by
// hash, caching it if found.
func (bc *BlockChain) GetBody(hash common.Hash) *types.Body <span class="cov0" title="0">{
        // Short circuit if the body's already in the cache, retrieve otherwise
        if cached, ok := bc.bodyCache.Get(hash); ok </span><span class="cov0" title="0">{
                body := cached.(*types.Body)
                return body
        }</span>
        <span class="cov0" title="0">number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">body := rawdb.ReadBody(bc.db, hash, *number)
        if body == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Cache the found body for next time and return
        <span class="cov0" title="0">bc.bodyCache.Add(hash, body)
        return body</span>
}

// GetBodyRLP retrieves a block body in RLP encoding from the database by hash,
// caching it if found.
func (bc *BlockChain) GetBodyRLP(hash common.Hash) rlp.RawValue <span class="cov0" title="0">{
        // Short circuit if the body's already in the cache, retrieve otherwise
        if cached, ok := bc.bodyRLPCache.Get(hash); ok </span><span class="cov0" title="0">{
                return cached.(rlp.RawValue)
        }</span>
        <span class="cov0" title="0">number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">body := rawdb.ReadBodyRLP(bc.db, hash, *number)
        if len(body) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Cache the found body for next time and return
        <span class="cov0" title="0">bc.bodyRLPCache.Add(hash, body)
        return body</span>
}

// HasBlock checks if a block is fully present in the database or not.
func (bc *BlockChain) HasBlock(hash common.Hash, number uint64) bool <span class="cov0" title="0">{
        if bc.blockCache.Contains(hash) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return rawdb.HasBody(bc.db, hash, number)</span>
}

// HasState checks if state trie is fully present in the database or not.
func (bc *BlockChain) HasState(hash common.Hash) bool <span class="cov8" title="1">{
        _, err := bc.stateCache.OpenTrie(hash)
        return err == nil
}</span>

// HasBlockAndState checks if a block and associated state trie is fully present
// in the database or not, caching it if present.
func (bc *BlockChain) HasBlockAndState(hash common.Hash, number uint64) bool <span class="cov8" title="1">{
        // Check first that the block itself is known
        block := bc.GetBlock(hash, number)
        if block == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return bc.HasState(block.Root())</span>
}

// GetBlock retrieves a block from the database by hash and number,
// caching it if found.
func (bc *BlockChain) GetBlock(hash common.Hash, number uint64) *types.Block <span class="cov8" title="1">{
        // Short circuit if the block's already in the cache, retrieve otherwise
        if block, ok := bc.blockCache.Get(hash); ok </span><span class="cov8" title="1">{
                return block.(*types.Block)
        }</span>
        <span class="cov8" title="1">block := rawdb.ReadBlock(bc.db, hash, number)
        if block == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Cache the found block for next time and return
        <span class="cov8" title="1">bc.blockCache.Add(block.Hash(), block)
        return block</span>
}

// GetBlockByHash retrieves a block from the database by hash, caching it if found.
func (bc *BlockChain) GetBlockByHash(hash common.Hash) *types.Block <span class="cov8" title="1">{
        number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return bc.GetBlock(hash, *number)</span>
}

// GetBlockByNumber retrieves a block from the database by number, caching it
// (associated with its hash) if found.
func (bc *BlockChain) GetBlockByNumber(number uint64) *types.Block <span class="cov8" title="1">{
        hash := rawdb.ReadCanonicalHash(bc.db, number)
        if hash == (common.Hash{}) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return bc.GetBlock(hash, number)</span>
}

// GetReceiptsByHash retrieves the receipts for all transactions in a given block.
func (bc *BlockChain) GetReceiptsByHash(hash common.Hash) types.Receipts <span class="cov0" title="0">{
        if receipts, ok := bc.receiptsCache.Get(hash); ok </span><span class="cov0" title="0">{
                return receipts.(types.Receipts)
        }</span>

        <span class="cov0" title="0">number := rawdb.ReadHeaderNumber(bc.db, hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">receipts := rawdb.ReadReceipts(bc.db, hash, *number)
        bc.receiptsCache.Add(hash, receipts)
        return receipts</span>
}

// GetBlocksFromHash returns the block corresponding to hash and up to n-1 ancestors.
// [deprecated by eth/62]
func (bc *BlockChain) GetBlocksFromHash(hash common.Hash, n int) (blocks []*types.Block) <span class="cov0" title="0">{
        number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                block := bc.GetBlock(hash, *number)
                if block == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">blocks = append(blocks, block)
                hash = block.ParentHash()
                *number--</span>
        }
        <span class="cov0" title="0">return</span>
}

// GetUnclesInChain retrieves all the uncles from a given block backwards until
// a specific distance is reached.
func (bc *BlockChain) GetUnclesInChain(b *types.Block, length int) []*block.Header <span class="cov0" title="0">{
        uncles := []*block.Header{}
        for i := 0; b != nil &amp;&amp; i &lt; length; i++ </span><span class="cov0" title="0">{
                uncles = append(uncles, b.Uncles()...)
                b = bc.GetBlock(b.ParentHash(), b.NumberU64()-1)
        }</span>
        <span class="cov0" title="0">return uncles</span>
}

// TrieNode retrieves a blob of data associated with a trie node (or code hash)
// either from ephemeral in-memory cache, or from persistent storage.
func (bc *BlockChain) TrieNode(hash common.Hash) ([]byte, error) <span class="cov0" title="0">{
        return bc.stateCache.TrieDB().Node(hash)
}</span>

// Stop stops the blockchain service. If any imports are currently in progress
// it will abort them using the procInterrupt.
func (bc *BlockChain) Stop() <span class="cov0" title="0">{
        if !atomic.CompareAndSwapInt32(&amp;bc.running, 0, 1) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := bc.SavePendingCrossLinks(); err != nil </span><span class="cov0" title="0">{
                utils.Logger().Error().Err(err).Msg("Failed to save pending cross links")
        }</span>

        // Unsubscribe all subscriptions registered from blockchain
        <span class="cov0" title="0">bc.scope.Close()
        close(bc.quit)
        atomic.StoreInt32(&amp;bc.procInterrupt, 1)

        bc.wg.Wait()

        // Ensure the state of a recent block is also stored to disk before exiting.
        // We're writing three different states to catch different restart scenarios:
        //  - HEAD:     So we don't need to reprocess any blocks in the general case
        //  - HEAD-1:   So we don't do large reorgs if our HEAD becomes an uncle
        //  - HEAD-127: So we have a hard limit on the number of blocks reexecuted
        if !bc.cacheConfig.Disabled </span><span class="cov0" title="0">{
                triedb := bc.stateCache.TrieDB()

                for _, offset := range []uint64{0, 1, triesInMemory - 1} </span><span class="cov0" title="0">{
                        if number := bc.CurrentBlock().NumberU64(); number &gt; offset </span><span class="cov0" title="0">{
                                recent := bc.GetHeaderByNumber(number - offset)
                                if recent != nil </span><span class="cov0" title="0">{
                                        utils.Logger().Info().
                                                Str("block", recent.Number().String()).
                                                Str("hash", recent.Hash().Hex()).
                                                Str("root", recent.Root().Hex()).
                                                Msg("Writing cached state to disk")
                                        if err := triedb.Commit(recent.Root(), true); err != nil </span><span class="cov0" title="0">{
                                                utils.Logger().Error().Err(err).Msg("Failed to commit recent state trie")
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">for !bc.triegc.Empty() </span><span class="cov0" title="0">{
                        triedb.Dereference(bc.triegc.PopItem().(common.Hash))
                }</span>
                <span class="cov0" title="0">if size, _ := triedb.Size(); size != 0 </span><span class="cov0" title="0">{
                        utils.Logger().Error().Msg("Dangling trie nodes after full cleanup")
                }</span>
        }
        <span class="cov0" title="0">utils.Logger().Info().Msg("Blockchain manager stopped")</span>
}

func (bc *BlockChain) procFutureBlocks() <span class="cov8" title="1">{
        blocks := make([]*types.Block, 0, bc.futureBlocks.Len())
        for _, hash := range bc.futureBlocks.Keys() </span><span class="cov0" title="0">{
                if block, exist := bc.futureBlocks.Peek(hash); exist </span><span class="cov0" title="0">{
                        blocks = append(blocks, block.(*types.Block))
                }</span>
        }
        <span class="cov8" title="1">if len(blocks) &gt; 0 </span><span class="cov0" title="0">{
                types.BlockBy(types.Number).Sort(blocks)

                // Insert one by one as chain insertion needs contiguous ancestry between blocks
                for i := range blocks </span><span class="cov0" title="0">{
                        bc.InsertChain(blocks[i:i+1], true /* verifyHeaders */)
                }</span>
        }
}

// WriteStatus status of write
type WriteStatus byte

// Constants for WriteStatus
const (
        NonStatTy WriteStatus = iota
        CanonStatTy
        SideStatTy
)

// Rollback is designed to remove a chain of links from the database that aren't
// certain enough to be valid.
func (bc *BlockChain) Rollback(chain []common.Hash) error <span class="cov0" title="0">{
        bc.mu.Lock()
        defer bc.mu.Unlock()

        valsToRemove := map[common.Address]struct{}{}
        for i := len(chain) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                hash := chain[i]

                currentHeader := bc.hc.CurrentHeader()
                if currentHeader != nil &amp;&amp; currentHeader.Hash() == hash </span><span class="cov0" title="0">{
                        parentHeader := bc.GetHeader(currentHeader.ParentHash(), currentHeader.Number().Uint64()-1)
                        if parentHeader != nil </span><span class="cov0" title="0">{
                                if err := bc.hc.SetCurrentHeader(parentHeader); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "HeaderChain SetCurrentHeader")
                                }</span>
                        }
                }
                <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock != nil &amp;&amp; currentFastBlock.Hash() == hash </span><span class="cov0" title="0">{
                        newFastBlock := bc.GetBlock(currentFastBlock.ParentHash(), currentFastBlock.NumberU64()-1)
                        if newFastBlock != nil </span><span class="cov0" title="0">{
                                bc.currentFastBlock.Store(newFastBlock)
                                rawdb.WriteHeadFastBlockHash(bc.db, newFastBlock.Hash())
                        }</span>
                }
                <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock != nil &amp;&amp; currentBlock.Hash() == hash </span><span class="cov0" title="0">{
                        newBlock := bc.GetBlock(currentBlock.ParentHash(), currentBlock.NumberU64()-1)
                        if newBlock != nil </span><span class="cov0" title="0">{
                                bc.currentBlock.Store(newBlock)
                                if err := rawdb.WriteHeadBlockHash(bc.db, newBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">for _, stkTxn := range currentBlock.StakingTransactions() </span><span class="cov0" title="0">{
                                        if stkTxn.StakingType() == staking.DirectiveCreateValidator </span><span class="cov0" title="0">{
                                                if addr, err := stkTxn.SenderAddress(); err == nil </span><span class="cov0" title="0">{
                                                        valsToRemove[addr] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">return bc.removeInValidatorList(valsToRemove)</span>
}

// SetReceiptsData computes all the non-consensus fields of the receipts
func SetReceiptsData(config *params.ChainConfig, block *types.Block, receipts types.Receipts) error <span class="cov0" title="0">{
        signer := types.MakeSigner(config, block.Epoch())
        ethSigner := types.NewEIP155Signer(config.EthCompatibleChainID)

        transactions, stakingTransactions, logIndex := block.Transactions(), block.StakingTransactions(), uint(0)
        if len(transactions)+len(stakingTransactions) != len(receipts) </span><span class="cov0" title="0">{
                return errors.New("transaction+stakingTransactions and receipt count mismatch")
        }</span>

        // The used gas can be calculated based on previous receipts
        <span class="cov0" title="0">if len(receipts) &gt; 0 &amp;&amp; len(transactions) &gt; 0 </span><span class="cov0" title="0">{
                receipts[0].GasUsed = receipts[0].CumulativeGasUsed
        }</span>
        <span class="cov0" title="0">for j := 1; j &lt; len(transactions); j++ </span><span class="cov0" title="0">{
                // The transaction hash can be retrieved from the transaction itself
                receipts[j].TxHash = transactions[j].Hash()
                receipts[j].GasUsed = receipts[j].CumulativeGasUsed - receipts[j-1].CumulativeGasUsed
                // The contract address can be derived from the transaction itself
                if transactions[j].To() == nil </span><span class="cov0" title="0">{
                        // Deriving the signer is expensive, only do if it's actually needed
                        var from common.Address
                        if transactions[j].IsEthCompatible() </span><span class="cov0" title="0">{
                                from, _ = types.Sender(ethSigner, transactions[j])
                        }</span> else<span class="cov0" title="0"> {
                                from, _ = types.Sender(signer, transactions[j])
                        }</span>
                        <span class="cov0" title="0">receipts[j].ContractAddress = crypto.CreateAddress(from, transactions[j].Nonce())</span>
                }
                // The derived log fields can simply be set from the block and transaction
                <span class="cov0" title="0">for k := 0; k &lt; len(receipts[j].Logs); k++ </span><span class="cov0" title="0">{
                        receipts[j].Logs[k].BlockNumber = block.NumberU64()
                        receipts[j].Logs[k].BlockHash = block.Hash()
                        receipts[j].Logs[k].TxHash = receipts[j].TxHash
                        receipts[j].Logs[k].TxIndex = uint(j)
                        receipts[j].Logs[k].Index = logIndex
                        logIndex++
                }</span>
        }

        // The used gas can be calculated based on previous receipts
        <span class="cov0" title="0">if len(receipts) &gt; len(transactions) &amp;&amp; len(stakingTransactions) &gt; 0 </span><span class="cov0" title="0">{
                receipts[len(transactions)].GasUsed = receipts[len(transactions)].CumulativeGasUsed
        }</span>
        // in a block, txns are processed before staking txns
        <span class="cov0" title="0">for j := len(transactions) + 1; j &lt; len(transactions)+len(stakingTransactions); j++ </span><span class="cov0" title="0">{
                // The transaction hash can be retrieved from the staking transaction itself
                receipts[j].TxHash = stakingTransactions[j].Hash()
                receipts[j].GasUsed = receipts[j].CumulativeGasUsed - receipts[j-1].CumulativeGasUsed
                // The derived log fields can simply be set from the block and transaction
                for k := 0; k &lt; len(receipts[j].Logs); k++ </span><span class="cov0" title="0">{
                        receipts[j].Logs[k].BlockNumber = block.NumberU64()
                        receipts[j].Logs[k].BlockHash = block.Hash()
                        receipts[j].Logs[k].TxHash = receipts[j].TxHash
                        receipts[j].Logs[k].TxIndex = uint(j) + uint(len(transactions))
                        receipts[j].Logs[k].Index = logIndex
                        logIndex++
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// InsertReceiptChain attempts to complete an already existing header chain with
// transaction and receipt data.
func (bc *BlockChain) InsertReceiptChain(blockChain types.Blocks, receiptChain []types.Receipts) (int, error) <span class="cov0" title="0">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        // Do a sanity check that the provided chain is actually ordered and linked
        for i := 1; i &lt; len(blockChain); i++ </span><span class="cov0" title="0">{
                if blockChain[i].NumberU64() != blockChain[i-1].NumberU64()+1 || blockChain[i].ParentHash() != blockChain[i-1].Hash() </span><span class="cov0" title="0">{
                        utils.Logger().Error().
                                Str("number", blockChain[i].Number().String()).
                                Str("hash", blockChain[i].Hash().Hex()).
                                Str("parent", blockChain[i].ParentHash().Hex()).
                                Str("prevnumber", blockChain[i-1].Number().String()).
                                Str("prevhash", blockChain[i-1].Hash().Hex()).
                                Msg("Non contiguous receipt insert")
                        return 0, fmt.Errorf("non contiguous insert: item %d is #%d [%xâ€¦], item %d is #%d [%xâ€¦] (parent [%xâ€¦])", i-1, blockChain[i-1].NumberU64(),
                                blockChain[i-1].Hash().Bytes()[:4], i, blockChain[i].NumberU64(), blockChain[i].Hash().Bytes()[:4], blockChain[i].ParentHash().Bytes()[:4])
                }</span>
        }

        <span class="cov0" title="0">var (
                stats = struct{ processed, ignored int32 }{}
                start = time.Now()
                bytes = 0
                batch = bc.db.NewBatch()
        )
        for i, block := range blockChain </span><span class="cov0" title="0">{
                receipts := receiptChain[i]
                // Short circuit insertion if shutting down or processing failed
                if atomic.LoadInt32(&amp;bc.procInterrupt) == 1 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                // Short circuit if the owner header is unknown
                <span class="cov0" title="0">if !bc.HasHeader(block.Hash(), block.NumberU64()) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("containing header #%d [%xâ€¦] unknown", block.Number(), block.Hash().Bytes()[:4])
                }</span>
                // Skip if the entire data is already known
                <span class="cov0" title="0">if bc.HasBlock(block.Hash(), block.NumberU64()) </span><span class="cov0" title="0">{
                        stats.ignored++
                        continue</span>
                }
                // Compute all the non-consensus fields of the receipts
                <span class="cov0" title="0">if err := SetReceiptsData(bc.chainConfig, block, receipts); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to set receipts data: %v", err)
                }</span>
                // Write all the data out into the database
                <span class="cov0" title="0">if err := rawdb.WriteBody(batch, block.Hash(), block.NumberU64(), block.Body()); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteReceipts(batch, block.Hash(), block.NumberU64(), receipts); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteBlockTxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteBlockStxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">stats.processed++

                if batch.ValueSize() &gt;= ethdb.IdealBatchSize </span><span class="cov0" title="0">{
                        if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">bytes += batch.ValueSize()
                        batch.Reset()</span>
                }
        }
        <span class="cov0" title="0">if batch.ValueSize() &gt; 0 </span><span class="cov0" title="0">{
                bytes += batch.ValueSize()
                if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        // Update the head fast sync block if better
        <span class="cov0" title="0">bc.mu.Lock()
        head := blockChain[len(blockChain)-1]
        if td := bc.GetTd(head.Hash(), head.NumberU64()); td != nil </span><span class="cov0" title="0">{ // Rewind may have occurred, skip in that case
                currentFastBlock := bc.CurrentFastBlock()
                if bc.GetTd(currentFastBlock.Hash(), currentFastBlock.NumberU64()).Cmp(td) &lt; 0 </span><span class="cov0" title="0">{
                        rawdb.WriteHeadFastBlockHash(bc.db, head.Hash())
                        bc.currentFastBlock.Store(head)
                }</span>
        }
        <span class="cov0" title="0">bc.mu.Unlock()

        utils.Logger().Info().
                Int32("count", stats.processed).
                Str("elapsed", common.PrettyDuration(time.Since(start)).String()).
                Str("age", common.PrettyAge(time.Unix(head.Time().Int64(), 0)).String()).
                Str("head", head.Number().String()).
                Str("hash", head.Hash().Hex()).
                Str("size", common.StorageSize(bytes).String()).
                Int32("ignored", stats.ignored).
                Msg("Imported new block receipts")

        return 0, nil</span>
}

var lastWrite uint64

// WriteBlockWithoutState writes only the block and its metadata to the database,
// but does not write any state. This is used to construct competing side forks
// up to the point where they exceed the canonical total difficulty.
func (bc *BlockChain) WriteBlockWithoutState(block *types.Block, td *big.Int) (err error) <span class="cov0" title="0">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        if err := bc.hc.WriteTd(block.Hash(), block.NumberU64(), td); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WriteBlock(bc.db, block); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WriteBlockWithState writes the block and all associated state to the database.
func (bc *BlockChain) WriteBlockWithState(
        block *types.Block, receipts []*types.Receipt,
        cxReceipts []*types.CXReceipt,
        stakeMsgs []staking.StakeMsg,
        paid reward.Reader,
        state *state.DB,
) (status WriteStatus, err error) <span class="cov8" title="1">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        // Make sure no inconsistent state is leaked during insertion
        bc.mu.Lock()
        defer bc.mu.Unlock()

        currentBlock := bc.CurrentBlock()
        if currentBlock == nil || block.ParentHash() != currentBlock.Hash() </span><span class="cov0" title="0">{
                return NonStatTy, errors.New("Hash of parent block doesn't match the current block hash")
        }</span>

        // Commit state object changes to in-memory trie
        <span class="cov8" title="1">root, err := state.Commit(bc.chainConfig.IsS3(block.Epoch()))
        if err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>

        // Flush trie state into disk if it's archival node or the block is epoch block
        <span class="cov8" title="1">triedb := bc.stateCache.TrieDB()
        if bc.cacheConfig.Disabled || block.IsLastBlockInEpoch() </span><span class="cov0" title="0">{
                if err := triedb.Commit(root, false); err != nil </span><span class="cov0" title="0">{
                        if isUnrecoverableErr(err) </span><span class="cov0" title="0">{
                                fmt.Printf("Unrecoverable error when committing triedb: %v\nExitting\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">return NonStatTy, err</span>
                }
        } else<span class="cov8" title="1"> {
                // Full but not archive node, do proper garbage collection
                triedb.Reference(root, common.Hash{}) // metadata reference to keep trie alive
                bc.triegc.Push(root, -int64(block.NumberU64()))

                if current := block.NumberU64(); current &gt; triesInMemory </span><span class="cov0" title="0">{
                        // If we exceeded our memory allowance, flush matured singleton nodes to disk
                        var (
                                nodes, imgs = triedb.Size()
                                limit       = common.StorageSize(bc.cacheConfig.TrieNodeLimit) * 1024 * 1024
                        )
                        if nodes &gt; limit || imgs &gt; 4*1024*1024 </span><span class="cov0" title="0">{
                                triedb.Cap(limit - ethdb.IdealBatchSize)
                        }</span>
                        // Find the next state trie we need to commit
                        <span class="cov0" title="0">header := bc.GetHeaderByNumber(current - triesInMemory)
                        if header != nil </span><span class="cov0" title="0">{
                                chosen := header.Number().Uint64()

                                // If we exceeded out time allowance, flush an entire trie to disk
                                if bc.gcproc &gt; bc.cacheConfig.TrieTimeLimit </span><span class="cov0" title="0">{
                                        // If we're exceeding limits but haven't reached a large enough memory gap,
                                        // warn the user that the system is becoming unstable.
                                        if chosen &lt; lastWrite+triesInMemory &amp;&amp; bc.gcproc &gt;= 2*bc.cacheConfig.TrieTimeLimit </span><span class="cov0" title="0">{
                                                utils.Logger().Info().
                                                        Dur("time", bc.gcproc).
                                                        Dur("allowance", bc.cacheConfig.TrieTimeLimit).
                                                        Float64("optimum", float64(chosen-lastWrite)/triesInMemory).
                                                        Msg("State in memory for too long, committing")
                                        }</span>
                                        // Flush an entire trie and restart the counters
                                        <span class="cov0" title="0">triedb.Commit(header.Root(), true)
                                        lastWrite = chosen
                                        bc.gcproc = 0</span>
                                }
                                // Garbage collect anything below our required write retention
                                <span class="cov0" title="0">for !bc.triegc.Empty() </span><span class="cov0" title="0">{
                                        root, number := bc.triegc.Pop()
                                        if uint64(-number) &gt; chosen </span><span class="cov0" title="0">{
                                                bc.triegc.Push(root, number)
                                                break</span>
                                        }
                                        <span class="cov0" title="0">if -number &gt; bc.maxGarbCollectedBlkNum </span><span class="cov0" title="0">{
                                                bc.maxGarbCollectedBlkNum = -number
                                        }</span>
                                        <span class="cov0" title="0">triedb.Dereference(root.(common.Hash))</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">batch := bc.db.NewBatch()
        // Write the raw block
        if err := rawdb.WriteBlock(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>

        // Write offchain data
        <span class="cov8" title="1">if status, err := bc.CommitOffChainData(
                batch, block, receipts,
                cxReceipts, stakeMsgs,
                paid, state,
        ); err != nil </span><span class="cov0" title="0">{
                return status, err
        }</span>

        // Write the positional metadata for transaction/receipt lookups and preimages
        <span class="cov8" title="1">if err := rawdb.WriteBlockTxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WriteBlockStxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WriteCxLookupEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WritePreimages(batch, block.NumberU64(), state.Preimages()); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>

        <span class="cov8" title="1">if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                if isUnrecoverableErr(err) </span><span class="cov0" title="0">{
                        fmt.Printf("Unrecoverable error when writing leveldb: %v\nExitting\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return NonStatTy, err</span>
        }

        // Update current block
        <span class="cov8" title="1">if err := bc.writeHeadBlock(block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, errors.Wrap(err, "writeHeadBlock")
        }</span>

        <span class="cov8" title="1">bc.futureBlocks.Remove(block.Hash())
        return CanonStatTy, nil</span>
}

// GetMaxGarbageCollectedBlockNumber ..
func (bc *BlockChain) GetMaxGarbageCollectedBlockNumber() int64 <span class="cov0" title="0">{
        return bc.maxGarbCollectedBlkNum
}</span>

// InsertChain attempts to insert the given batch of blocks in to the canonical
// chain or, otherwise, create a fork. If an error is returned it will return
// the index number of the failing block as well an error describing what went
// wrong.
//
// After insertion is done, all accumulated events will be fired.
func (bc *BlockChain) InsertChain(chain types.Blocks, verifyHeaders bool) (int, error) <span class="cov8" title="1">{
        n, events, logs, err := bc.insertChain(chain, verifyHeaders)
        bc.PostChainEvents(events, logs)
        return n, err
}</span>

// insertChain will execute the actual chain insertion and event aggregation. The
// only reason this method exists as a separate one is to make locking cleaner
// with deferred statements.
func (bc *BlockChain) insertChain(chain types.Blocks, verifyHeaders bool) (int, []interface{}, []*types.Log, error) <span class="cov8" title="1">{
        // Sanity check that we have something meaningful to import
        if len(chain) == 0 </span><span class="cov0" title="0">{
                return 0, nil, nil, nil
        }</span>
        // Do a sanity check that the provided chain is actually ordered and linked
        <span class="cov8" title="1">for i := 1; i &lt; len(chain); i++ </span><span class="cov0" title="0">{
                if chain[i].NumberU64() != chain[i-1].NumberU64()+1 || chain[i].ParentHash() != chain[i-1].Hash() </span><span class="cov0" title="0">{
                        // Chain broke ancestry, log a message (programming error) and skip insertion
                        utils.Logger().Error().
                                Str("number", chain[i].Number().String()).
                                Str("hash", chain[i].Hash().Hex()).
                                Str("parent", chain[i].ParentHash().Hex()).
                                Str("prevnumber", chain[i-1].Number().String()).
                                Str("prevhash", chain[i-1].Hash().Hex()).
                                Msg("insertChain: non contiguous block insert")

                        return 0, nil, nil, fmt.Errorf("non contiguous insert: item %d is #%d [%xâ€¦], item %d is #%d [%xâ€¦] (parent [%xâ€¦])", i-1, chain[i-1].NumberU64(),
                                chain[i-1].Hash().Bytes()[:4], i, chain[i].NumberU64(), chain[i].Hash().Bytes()[:4], chain[i].ParentHash().Bytes()[:4])
                }</span>
        }
        // Pre-checks passed, start the full block imports
        <span class="cov8" title="1">bc.wg.Add(1)
        defer bc.wg.Done()

        bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        // A queued approach to delivering events. This is generally
        // faster than direct delivery and requires much less mutex
        // acquiring.
        var (
                stats         = insertStats{startTime: mclock.Now()}
                events        = make([]interface{}, 0, len(chain))
                lastCanon     *types.Block
                coalescedLogs []*types.Log
        )

        var verifyHeadersResults &lt;-chan error

        // If the block header chain has not been verified, conduct header verification here.
        if verifyHeaders </span><span class="cov8" title="1">{
                headers := make([]*block.Header, len(chain))
                seals := make([]bool, len(chain))

                for i, block := range chain </span><span class="cov8" title="1">{
                        headers[i] = block.Header()
                        seals[i] = true
                }</span>
                // Note that VerifyHeaders verifies headers in the chain in parallel
                <span class="cov8" title="1">abort, results := bc.Engine().VerifyHeaders(bc, headers, seals)
                verifyHeadersResults = results
                defer close(abort)</span>
        }

        // Start a parallel signature recovery (signer will fluke on fork transition, minimal perf loss)
        //senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[0].Number()), chain)

        // Iterate over the blocks and insert when the verifier permits
        <span class="cov8" title="1">for i, block := range chain </span><span class="cov8" title="1">{
                // If the chain is terminating, stop processing blocks
                if atomic.LoadInt32(&amp;bc.procInterrupt) == 1 </span><span class="cov0" title="0">{
                        utils.Logger().Debug().Msg("Premature abort during blocks processing")
                        break</span>
                }
                // Wait for the block's verification to complete
                <span class="cov8" title="1">bstart := time.Now()

                var err error
                if verifyHeaders </span><span class="cov8" title="1">{
                        err = &lt;-verifyHeadersResults
                }</span>
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        err = bc.Validator().ValidateBody(block)
                }</span>
                <span class="cov8" title="1">switch </span>{
                case err == ErrKnownBlock:<span class="cov0" title="0">
                        // Block and state both already known. However if the current block is below
                        // this number we did a rollback and we should reimport it nonetheless.
                        if bc.CurrentBlock().NumberU64() &gt;= block.NumberU64() </span><span class="cov0" title="0">{
                                stats.ignored++
                                continue</span>
                        }

                case err == consensus_engine.ErrFutureBlock:<span class="cov0" title="0">
                        // Allow up to MaxFuture second in the future blocks. If this limit is exceeded
                        // the chain is discarded and processed at a later time if given.
                        max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)
                        if block.Time().Cmp(max) &gt; 0 </span><span class="cov0" title="0">{
                                return i, events, coalescedLogs, fmt.Errorf("future block: %v &gt; %v", block.Time(), max)
                        }</span>
                        <span class="cov0" title="0">bc.futureBlocks.Add(block.Hash(), block)
                        stats.queued++
                        continue</span>

                case err == consensus_engine.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()):<span class="cov0" title="0">
                        bc.futureBlocks.Add(block.Hash(), block)
                        stats.queued++
                        continue</span>

                case err == consensus_engine.ErrPrunedAncestor:<span class="cov0" title="0">
                        // TODO: add fork choice mechanism
                        // Block competing with the canonical chain, store in the db, but don't process
                        // until the competitor TD goes above the canonical TD
                        //currentBlock := bc.CurrentBlock()
                        //localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
                        //externTd := new(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()-1), block.Difficulty())
                        //if localTd.Cmp(externTd) &gt; 0 {
                        //        if err = bc.WriteBlockWithoutState(block, externTd); err != nil {
                        //                return i, events, coalescedLogs, err
                        //        }
                        //        continue
                        //}
                        // Competitor chain beat canonical, gather all blocks from the common ancestor
                        var winner []*types.Block

                        parent := bc.GetBlock(block.ParentHash(), block.NumberU64()-1)
                        for parent != nil &amp;&amp; !bc.HasState(parent.Root()) </span><span class="cov0" title="0">{
                                winner = append(winner, parent)
                                parent = bc.GetBlock(parent.ParentHash(), parent.NumberU64()-1)
                        }</span>
                        <span class="cov0" title="0">for j := 0; j &lt; len(winner)/2; j++ </span><span class="cov0" title="0">{
                                winner[j], winner[len(winner)-1-j] = winner[len(winner)-1-j], winner[j]
                        }</span>
                        // Prune in case non-empty winner chain
                        <span class="cov0" title="0">if len(winner) &gt; 0 </span><span class="cov0" title="0">{
                                // Import all the pruned blocks to make the state available
                                bc.chainmu.Unlock()
                                _, evs, logs, err := bc.insertChain(winner, true /* verifyHeaders */)
                                bc.chainmu.Lock()
                                events, coalescedLogs = evs, logs

                                if err != nil </span><span class="cov0" title="0">{
                                        return i, events, coalescedLogs, err
                                }</span>
                        }

                case err != nil:<span class="cov0" title="0">
                        bc.reportBlock(block, nil, err)
                        return i, events, coalescedLogs, err</span>
                }

                // Create a new statedb using the parent block and report an
                // error if it fails.
                <span class="cov8" title="1">var parent *types.Block
                if i == 0 </span><span class="cov8" title="1">{
                        parent = bc.GetBlock(block.ParentHash(), block.NumberU64()-1)
                }</span> else<span class="cov0" title="0"> {
                        parent = chain[i-1]
                }</span>
                <span class="cov8" title="1">state, err := state.New(parent.Root(), bc.stateCache)
                if err != nil </span><span class="cov0" title="0">{
                        return i, events, coalescedLogs, err
                }</span>

                // Process block using the parent state as reference point.
                <span class="cov8" title="1">receipts, cxReceipts, stakeMsgs, logs, usedGas, payout, newState, err := bc.processor.Process(
                        block, state, bc.vmConfig, true,
                )
                state = newState // update state in case the new state is cached.
                if err != nil </span><span class="cov0" title="0">{
                        bc.reportBlock(block, receipts, err)
                        return i, events, coalescedLogs, err
                }</span>

                // Validate the state using the default validator
                <span class="cov8" title="1">if err := bc.Validator().ValidateState(
                        block, state, receipts, cxReceipts, usedGas,
                ); err != nil </span><span class="cov0" title="0">{
                        bc.reportBlock(block, receipts, err)
                        return i, events, coalescedLogs, err
                }</span>
                <span class="cov8" title="1">proctime := time.Since(bstart)

                // Write the block to the chain and get the status.
                status, err := bc.WriteBlockWithState(
                        block, receipts, cxReceipts, stakeMsgs, payout, state,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return i, events, coalescedLogs, err
                }</span>
                <span class="cov8" title="1">logger := utils.Logger().With().
                        Str("number", block.Number().String()).
                        Str("hash", block.Hash().Hex()).
                        Int("uncles", len(block.Uncles())).
                        Int("txs", len(block.Transactions())).
                        Int("stakingTxs", len(block.StakingTransactions())).
                        Uint64("gas", block.GasUsed()).
                        Str("elapsed", common.PrettyDuration(time.Since(bstart)).String()).
                        Logger()

                switch status </span>{
                case CanonStatTy:<span class="cov8" title="1">
                        logger.Info().Msg("Inserted new block")
                        coalescedLogs = append(coalescedLogs, logs...)
                        blockInsertTimer.UpdateSince(bstart)
                        events = append(events, ChainEvent{block, block.Hash(), logs})
                        lastCanon = block

                        // Only count canonical blocks for GC processing time
                        bc.gcproc += proctime</span>
                }

                <span class="cov8" title="1">stats.processed++
                stats.usedGas += usedGas
                cache, _ := bc.stateCache.TrieDB().Size()
                stats.report(chain, i, cache)</span>
        }
        // Append a single chain head event if we've progressed the chain
        <span class="cov8" title="1">if lastCanon != nil &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() </span><span class="cov8" title="1">{
                events = append(events, ChainHeadEvent{lastCanon})
        }</span>

        <span class="cov8" title="1">return 0, events, coalescedLogs, nil</span>
}

// insertStats tracks and reports on block insertion.
type insertStats struct {
        queued, processed, ignored int
        usedGas                    uint64
        lastIndex                  int
        startTime                  mclock.AbsTime
}

// statsReportLimit is the time limit during import and export after which we
// always print out progress. This avoids the user wondering what's going on.
const statsReportLimit = 8 * time.Second

// report prints statistics if some number of blocks have been processed
// or more than a few seconds have passed since the last message.
func (st *insertStats) report(chain []*types.Block, index int, cache common.StorageSize) <span class="cov8" title="1">{
        // Fetch the timings for the batch
        var (
                now     = mclock.Now()
                elapsed = time.Duration(now) - time.Duration(st.startTime)
        )
        // If we're at the last block of the batch or report period reached, log
        if index == len(chain)-1 || elapsed &gt;= statsReportLimit </span><span class="cov8" title="1">{
                var (
                        end = chain[index]
                        txs = countTransactions(chain[st.lastIndex : index+1])
                )

                context := utils.Logger().With().
                        Int("blocks", st.processed).
                        Int("txs", txs).
                        Float64("mgas", float64(st.usedGas)/1000000).
                        Str("elapsed", common.PrettyDuration(elapsed).String()).
                        Float64("mgasps", float64(st.usedGas)*1000/float64(elapsed)).
                        Str("number", end.Number().String()).
                        Str("hash", end.Hash().Hex()).
                        Str("cache", cache.String())

                if timestamp := time.Unix(end.Time().Int64(), 0); time.Since(timestamp) &gt; time.Minute </span><span class="cov0" title="0">{
                        context = context.Str("age", common.PrettyAge(timestamp).String())
                }</span>

                <span class="cov8" title="1">if st.queued &gt; 0 </span><span class="cov0" title="0">{
                        context = context.Int("queued", st.queued)
                }</span>
                <span class="cov8" title="1">if st.ignored &gt; 0 </span><span class="cov0" title="0">{
                        context = context.Int("ignored", st.ignored)
                }</span>

                <span class="cov8" title="1">logger := context.Logger()
                logger.Info().Msg("Imported new chain segment")

                *st = insertStats{startTime: now, lastIndex: index + 1}</span>
        }
}

func countTransactions(chain []*types.Block) (c int) <span class="cov8" title="1">{
        for _, b := range chain </span><span class="cov8" title="1">{
                c += len(b.Transactions())
        }</span>
        <span class="cov8" title="1">return c</span>
}

// PostChainEvents iterates over the events generated by a chain insertion and
// posts them into the event feed.
// TODO: Should not expose PostChainEvents. The chain events should be posted in WriteBlock.
func (bc *BlockChain) PostChainEvents(events []interface{}, logs []*types.Log) <span class="cov8" title="1">{
        // post event logs for further processing
        if logs != nil </span><span class="cov0" title="0">{
                bc.logsFeed.Send(logs)
        }</span>
        <span class="cov8" title="1">for _, event := range events </span><span class="cov8" title="1">{
                switch ev := event.(type) </span>{
                case ChainEvent:<span class="cov8" title="1">
                        bc.chainFeed.Send(ev)</span>

                case ChainHeadEvent:<span class="cov8" title="1">
                        bc.chainHeadFeed.Send(ev)</span>

                case ChainSideEvent:<span class="cov0" title="0">
                        bc.chainSideFeed.Send(ev)</span>
                }
        }
}

func (bc *BlockChain) update() <span class="cov8" title="1">{
        futureTimer := time.NewTicker(5 * time.Second)
        defer futureTimer.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-futureTimer.C:<span class="cov8" title="1">
                        bc.procFutureBlocks()</span>
                case &lt;-bc.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// BadBlock ..
type BadBlock struct {
        Block  *types.Block
        Reason error
}

// MarshalJSON ..
func (b BadBlock) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(struct {
                Block  *block.Header `json:"header"`
                Reason string        `json:"error-cause"`
        }{
                b.Block.Header(),
                b.Reason.Error(),
        })
}</span>

// BadBlocks returns a list of the last 'bad blocks' that
// the client has seen on the network
func (bc *BlockChain) BadBlocks() []BadBlock <span class="cov0" title="0">{
        blocks := make([]BadBlock, bc.badBlocks.Len())
        for _, hash := range bc.badBlocks.Keys() </span><span class="cov0" title="0">{
                if blk, exist := bc.badBlocks.Peek(hash); exist </span><span class="cov0" title="0">{
                        blocks = append(blocks, blk.(BadBlock))
                }</span>
        }
        <span class="cov0" title="0">return blocks</span>
}

// addBadBlock adds a bad block to the bad-block LRU cache
func (bc *BlockChain) addBadBlock(block *types.Block, reason error) <span class="cov0" title="0">{
        bc.badBlocks.Add(block.Hash(), BadBlock{block, reason})
}</span>

// reportBlock logs a bad block error.
func (bc *BlockChain) reportBlock(
        block *types.Block, receipts types.Receipts, err error,
) <span class="cov0" title="0">{
        bc.addBadBlock(block, err)
        var receiptString string
        for _, receipt := range receipts </span><span class="cov0" title="0">{
                receiptString += fmt.Sprintf("\t%v\n", receipt)
        }</span>
        <span class="cov0" title="0">utils.Logger().Error().Msgf(`
########## BAD BLOCK #########
Chain config: %v

Number: %v
Epoch: %v
NumTxn: %v
NumStkTxn: %v
Hash: 0x%x
%v

Error: %v
##############################
`, bc.chainConfig,
                block.Number(),
                block.Epoch(),
                len(block.Transactions()),
                len(block.StakingTransactions()),
                block.Hash(),
                receiptString,
                err,
        )
        for i, tx := range block.StakingTransactions() </span><span class="cov0" title="0">{
                utils.Logger().Error().
                        Msgf("StakingTxn %d: %s, %v", i, tx.StakingType().String(), tx.StakingMessage())
        }</span>
}

// InsertHeaderChain attempts to insert the given header chain in to the local
// chain, possibly creating a reorg. If an error is returned, it will return the
// index number of the failing header as well an error describing what went wrong.
//
// The verify parameter can be used to fine tune whether nonce verification
// should be done or not. The reason behind the optional check is because some
// of the header retrieval mechanisms already need to verify nonces, as well as
// because nonces can be verified sparsely, not needing to check each.
func (bc *BlockChain) InsertHeaderChain(chain []*block.Header, checkFreq int) (int, error) <span class="cov0" title="0">{
        start := time.Now()
        if i, err := bc.hc.ValidateHeaderChain(chain, checkFreq); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>

        // Make sure only one thread manipulates the chain at once
        <span class="cov0" title="0">bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        bc.wg.Add(1)
        defer bc.wg.Done()

        whFunc := func(header *block.Header) error </span><span class="cov0" title="0">{
                bc.mu.Lock()
                defer bc.mu.Unlock()

                _, err := bc.hc.WriteHeader(header)
                return err
        }</span>

        <span class="cov0" title="0">return bc.hc.InsertHeaderChain(chain, whFunc, start)</span>
}

// CurrentHeader retrieves the current head header of the canonical chain. The
// header is retrieved from the HeaderChain's internal cache.
func (bc *BlockChain) CurrentHeader() *block.Header <span class="cov8" title="1">{
        return bc.hc.CurrentHeader()
}</span>

// GetTd retrieves a block's total difficulty in the canonical chain from the
// database by hash and number, caching it if found.
func (bc *BlockChain) GetTd(hash common.Hash, number uint64) *big.Int <span class="cov8" title="1">{
        return bc.hc.GetTd(hash, number)
}</span>

// GetTdByHash retrieves a block's total difficulty in the canonical chain from the
// database by hash, caching it if found.
func (bc *BlockChain) GetTdByHash(hash common.Hash) *big.Int <span class="cov0" title="0">{
        return bc.hc.GetTdByHash(hash)
}</span>

// GetHeader retrieves a block header from the database by hash and number,
// caching it if found.
func (bc *BlockChain) GetHeader(hash common.Hash, number uint64) *block.Header <span class="cov8" title="1">{
        return bc.hc.GetHeader(hash, number)
}</span>

// GetHeaderByHash retrieves a block header from the database by hash, caching it if
// found.
func (bc *BlockChain) GetHeaderByHash(hash common.Hash) *block.Header <span class="cov8" title="1">{
        return bc.hc.GetHeaderByHash(hash)
}</span>

// HasHeader checks if a block header is present in the database or not, caching
// it if present.
func (bc *BlockChain) HasHeader(hash common.Hash, number uint64) bool <span class="cov0" title="0">{
        return bc.hc.HasHeader(hash, number)
}</span>

// GetBlockHashesFromHash retrieves a number of block hashes starting at a given
// hash, fetching towards the genesis block.
func (bc *BlockChain) GetBlockHashesFromHash(hash common.Hash, max uint64) []common.Hash <span class="cov0" title="0">{
        return bc.hc.GetBlockHashesFromHash(hash, max)
}</span>

// GetAncestor retrieves the Nth ancestor of a given block. It assumes that either the given block or
// a close ancestor of it is canonical. maxNonCanonical points to a downwards counter limiting the
// number of blocks to be individually checked before we reach the canonical chain.
//
// Note: ancestor == 0 returns the same block, 1 returns its parent and so on.
func (bc *BlockChain) GetAncestor(hash common.Hash, number, ancestor uint64, maxNonCanonical *uint64) (common.Hash, uint64) <span class="cov0" title="0">{
        bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        return bc.hc.GetAncestor(hash, number, ancestor, maxNonCanonical)
}</span>

// GetHeaderByNumber retrieves a block header from the database by number,
// caching it (associated with its hash) if found.
func (bc *BlockChain) GetHeaderByNumber(number uint64) *block.Header <span class="cov8" title="1">{
        return bc.hc.GetHeaderByNumber(number)
}</span>

// Config retrieves the blockchain's chain configuration.
func (bc *BlockChain) Config() *params.ChainConfig <span class="cov8" title="1">{ return bc.chainConfig }</span>

// Engine retrieves the blockchain's consensus engine.
func (bc *BlockChain) Engine() consensus_engine.Engine <span class="cov8" title="1">{ return bc.engine }</span>

// SubscribeRemovedLogsEvent registers a subscription of RemovedLogsEvent.
func (bc *BlockChain) SubscribeRemovedLogsEvent(ch chan&lt;- RemovedLogsEvent) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.rmLogsFeed.Subscribe(ch))
}</span>

// SubscribeChainEvent registers a subscription of ChainEvent.
func (bc *BlockChain) SubscribeChainEvent(ch chan&lt;- ChainEvent) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.chainFeed.Subscribe(ch))
}</span>

// SubscribeChainHeadEvent registers a subscription of ChainHeadEvent.
func (bc *BlockChain) SubscribeChainHeadEvent(ch chan&lt;- ChainHeadEvent) event.Subscription <span class="cov8" title="1">{
        return bc.scope.Track(bc.chainHeadFeed.Subscribe(ch))
}</span>

// SubscribeChainSideEvent registers a subscription of ChainSideEvent.
func (bc *BlockChain) SubscribeChainSideEvent(ch chan&lt;- ChainSideEvent) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.chainSideFeed.Subscribe(ch))
}</span>

// SubscribeLogsEvent registers a subscription of []*types.Log.
func (bc *BlockChain) SubscribeLogsEvent(ch chan&lt;- []*types.Log) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.logsFeed.Subscribe(ch))
}</span>

// ReadShardState retrieves sharding state given the epoch number.
func (bc *BlockChain) ReadShardState(epoch *big.Int) (*shard.State, error) <span class="cov8" title="1">{
        cacheKey := string(epoch.Bytes())
        if cached, ok := bc.shardStateCache.Get(cacheKey); ok </span><span class="cov8" title="1">{
                shardState := cached.(*shard.State)
                return shardState, nil
        }</span>
        <span class="cov8" title="1">shardState, err := rawdb.ReadShardState(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), rawdb.MsgNoShardStateFromDB) &amp;&amp;
                        shard.Schedule.IsSkippedEpoch(bc.ShardID(), epoch) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("epoch skipped on chain: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">bc.shardStateCache.Add(cacheKey, shardState)
        return shardState, nil</span>
}

// WriteShardStateBytes saves the given sharding state under the given epoch number.
func (bc *BlockChain) WriteShardStateBytes(db rawdb.DatabaseWriter,
        epoch *big.Int, shardState []byte,
) (*shard.State, error) <span class="cov8" title="1">{
        decodeShardState, err := shard.DecodeWrapper(shardState)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = rawdb.WriteShardStateBytes(db, epoch, shardState)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cacheKey := string(epoch.Bytes())
        bc.shardStateCache.Add(cacheKey, decodeShardState)
        return decodeShardState, nil</span>
}

// ReadCommitSig retrieves the commit signature on a block.
func (bc *BlockChain) ReadCommitSig(blockNum uint64) ([]byte, error) <span class="cov0" title="0">{
        if cached, ok := bc.lastCommitsCache.Get(blockNum); ok </span><span class="cov0" title="0">{
                lastCommits := cached.([]byte)
                return lastCommits, nil
        }</span>
        <span class="cov0" title="0">lastCommits, err := rawdb.ReadBlockCommitSig(bc.db, blockNum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return lastCommits, nil</span>
}

// WriteCommitSig saves the commits signatures signed on a block.
func (bc *BlockChain) WriteCommitSig(blockNum uint64, lastCommits []byte) error <span class="cov0" title="0">{
        err := rawdb.WriteBlockCommitSig(bc.db, blockNum, lastCommits)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.lastCommitsCache.Add(blockNum, lastCommits)
        return nil</span>
}

// GetVdfByNumber retrieves the rand seed given the block number, return 0 if not exist
func (bc *BlockChain) GetVdfByNumber(number uint64) []byte <span class="cov0" title="0">{
        header := bc.GetHeaderByNumber(number)
        if header == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>

        <span class="cov0" title="0">return header.Vdf()</span>
}

// GetVrfByNumber retrieves the randomness preimage given the block number, return 0 if not exist
func (bc *BlockChain) GetVrfByNumber(number uint64) []byte <span class="cov0" title="0">{
        header := bc.GetHeaderByNumber(number)
        if header == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return header.Vrf()</span>
}

// ChainDb returns the database
func (bc *BlockChain) ChainDb() ethdb.Database <span class="cov8" title="1">{ return bc.db }</span>

// GetEpochBlockNumber returns the first block number of the given epoch.
func (bc *BlockChain) GetEpochBlockNumber(epoch *big.Int) (*big.Int, error) <span class="cov0" title="0">{
        // Try cache first
        cacheKey := string(epoch.Bytes())
        if cachedValue, ok := bc.epochCache.Get(cacheKey); ok </span><span class="cov0" title="0">{
                return (&amp;big.Int{}).SetBytes([]byte(cachedValue.(string))), nil
        }</span>
        <span class="cov0" title="0">blockNum, err := rawdb.ReadEpochBlockNumber(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(
                        err, "cannot read epoch block number from database",
                )
        }</span>
        <span class="cov0" title="0">cachedValue := []byte(blockNum.Bytes())
        bc.epochCache.Add(cacheKey, cachedValue)
        return blockNum, nil</span>
}

// StoreEpochBlockNumber stores the given epoch-first block number.
func (bc *BlockChain) StoreEpochBlockNumber(
        epoch *big.Int, blockNum *big.Int,
) error <span class="cov0" title="0">{
        cacheKey := string(epoch.Bytes())
        cachedValue := []byte(blockNum.Bytes())
        bc.epochCache.Add(cacheKey, cachedValue)
        if err := rawdb.WriteEpochBlockNumber(bc.db, epoch, blockNum); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        err, "cannot write epoch block number to database",
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadEpochVrfBlockNums retrieves block numbers with valid VRF for the specified epoch
func (bc *BlockChain) ReadEpochVrfBlockNums(epoch *big.Int) ([]uint64, error) <span class="cov0" title="0">{
        vrfNumbers := []uint64{}
        if cached, ok := bc.randomnessCache.Get("vrf-" + string(epoch.Bytes())); ok </span><span class="cov0" title="0">{
                encodedVrfNumbers := cached.([]byte)
                if err := rlp.DecodeBytes(encodedVrfNumbers, &amp;vrfNumbers); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return vrfNumbers, nil</span>
        }

        <span class="cov0" title="0">encodedVrfNumbers, err := rawdb.ReadEpochVrfBlockNums(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := rlp.DecodeBytes(encodedVrfNumbers, &amp;vrfNumbers); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return vrfNumbers, nil</span>
}

// WriteEpochVrfBlockNums saves block numbers with valid VRF for the specified epoch
func (bc *BlockChain) WriteEpochVrfBlockNums(epoch *big.Int, vrfNumbers []uint64) error <span class="cov0" title="0">{
        encodedVrfNumbers, err := rlp.EncodeToBytes(vrfNumbers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = rawdb.WriteEpochVrfBlockNums(bc.db, epoch, encodedVrfNumbers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.randomnessCache.Add("vrf-"+string(epoch.Bytes()), encodedVrfNumbers)
        return nil</span>
}

// ReadEpochVdfBlockNum retrieves block number with valid VDF for the specified epoch
func (bc *BlockChain) ReadEpochVdfBlockNum(epoch *big.Int) (*big.Int, error) <span class="cov0" title="0">{
        if cached, ok := bc.randomnessCache.Get("vdf-" + string(epoch.Bytes())); ok </span><span class="cov0" title="0">{
                encodedVdfNumber := cached.([]byte)
                return new(big.Int).SetBytes(encodedVdfNumber), nil
        }</span>

        <span class="cov0" title="0">encodedVdfNumber, err := rawdb.ReadEpochVdfBlockNum(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return new(big.Int).SetBytes(encodedVdfNumber), nil</span>
}

// WriteEpochVdfBlockNum saves block number with valid VDF for the specified epoch
func (bc *BlockChain) WriteEpochVdfBlockNum(epoch *big.Int, blockNum *big.Int) error <span class="cov0" title="0">{
        err := rawdb.WriteEpochVdfBlockNum(bc.db, epoch, blockNum.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bc.randomnessCache.Add("vdf-"+string(epoch.Bytes()), blockNum.Bytes())
        return nil</span>
}

// WriteCrossLinks saves the hashes of crosslinks by shardID and blockNum combination key
func (bc *BlockChain) WriteCrossLinks(batch rawdb.DatabaseWriter, cls []types.CrossLink) error <span class="cov0" title="0">{
        var err error
        for i := 0; i &lt; len(cls); i++ </span><span class="cov0" title="0">{
                cl := cls[i]
                err = rawdb.WriteCrossLinkShardBlock(batch, cl.ShardID(), cl.BlockNum(), cl.Serialize())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// DeleteCrossLinks removes the hashes of crosslinks by shardID and blockNum combination key
func (bc *BlockChain) DeleteCrossLinks(cls []types.CrossLink) error <span class="cov0" title="0">{
        var err error
        for i := 0; i &lt; len(cls); i++ </span><span class="cov0" title="0">{
                cl := cls[i]
                err = rawdb.DeleteCrossLinkShardBlock(bc.db, cl.ShardID(), cl.BlockNum())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// ReadCrossLink retrieves crosslink given shardID and blockNum.
func (bc *BlockChain) ReadCrossLink(shardID uint32, blockNum uint64) (*types.CrossLink, error) <span class="cov0" title="0">{
        bytes, err := rawdb.ReadCrossLinkShardBlock(bc.db, shardID, blockNum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">crossLink, err := types.DeserializeCrossLink(bytes)

        return crossLink, err</span>
}

// LastContinuousCrossLink saves the last crosslink of a shard
// This function will update the latest crosslink in the sense that
// any previous block's crosslink is received up to this point
// there is no missing hole between genesis to this crosslink of given shardID
func (bc *BlockChain) LastContinuousCrossLink(batch rawdb.DatabaseWriter, shardID uint32) error <span class="cov0" title="0">{
        oldLink, err := bc.ReadShardLastCrossLink(shardID)
        if oldLink == nil || err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">newLink := oldLink
        // Starting from last checkpoint, keeping reading immediate next crosslink until there is a gap
        for i := oldLink.BlockNum() + 1; ; i++ </span><span class="cov0" title="0">{
                tmp, err := bc.ReadCrossLink(shardID, i)
                if err == nil &amp;&amp; tmp != nil &amp;&amp; tmp.BlockNum() == i </span><span class="cov0" title="0">{
                        newLink = tmp
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">if newLink.BlockNum() &gt; oldLink.BlockNum() </span><span class="cov0" title="0">{
                utils.Logger().Debug().Msgf("LastContinuousCrossLink: latest checkpoint blockNum %d", newLink.BlockNum())
                return rawdb.WriteShardLastCrossLink(batch, shardID, newLink.Serialize())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadShardLastCrossLink retrieves the last crosslink of a shard.
func (bc *BlockChain) ReadShardLastCrossLink(shardID uint32) (*types.CrossLink, error) <span class="cov0" title="0">{
        bytes, err := rawdb.ReadShardLastCrossLink(bc.db, shardID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return types.DeserializeCrossLink(bytes)</span>
}

func (bc *BlockChain) writeSlashes(processed slash.Records) error <span class="cov0" title="0">{
        bytes, err := rlp.EncodeToBytes(processed)
        if err != nil </span><span class="cov0" title="0">{
                const msg = "failed to encode slashing candidates"
                utils.Logger().Error().Msg(msg)
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WritePendingSlashingCandidates(bc.db, bytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFromPendingSlashingCandidates ..
func (bc *BlockChain) DeleteFromPendingSlashingCandidates(
        processed slash.Records,
) error <span class="cov0" title="0">{
        bc.pendingSlashingCandidatesMU.Lock()
        defer bc.pendingSlashingCandidatesMU.Unlock()
        current := bc.ReadPendingSlashingCandidates()
        bc.pendingSlashes = processed.SetDifference(current)
        return bc.writeSlashes(bc.pendingSlashes)
}</span>

// ReadPendingSlashingCandidates retrieves pending slashing candidates
func (bc *BlockChain) ReadPendingSlashingCandidates() slash.Records <span class="cov0" title="0">{
        if !bc.Config().IsStaking(bc.CurrentHeader().Epoch()) </span><span class="cov0" title="0">{
                return slash.Records{}
        }</span>
        <span class="cov0" title="0">return append(bc.pendingSlashes[0:0], bc.pendingSlashes...)</span>
}

// ReadPendingCrossLinks retrieves pending crosslinks
func (bc *BlockChain) ReadPendingCrossLinks() ([]types.CrossLink, error) <span class="cov0" title="0">{
        cls := []types.CrossLink{}
        bytes := []byte{}
        if cached, ok := bc.pendingCrossLinksCache.Get(pendingCLCacheKey); ok </span><span class="cov0" title="0">{
                cls = cached.([]types.CrossLink)
                return cls, nil
        }</span> else<span class="cov0" title="0"> {
                by, err := rawdb.ReadPendingCrossLinks(bc.db)
                if err != nil || len(by) == 0 </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">bytes = by</span>
        }
        <span class="cov0" title="0">if err := rlp.DecodeBytes(bytes, &amp;cls); err != nil </span><span class="cov0" title="0">{
                utils.Logger().Error().Err(err).Msg("Invalid pending crosslink RLP decoding")
                return nil, err
        }</span>

        <span class="cov0" title="0">bc.pendingCrossLinksCache.Add(pendingCLCacheKey, cls)
        return cls, nil</span>
}

// CachePendingCrossLinks caches the pending crosslinks in memory
func (bc *BlockChain) CachePendingCrossLinks(crossLinks []types.CrossLink) error <span class="cov0" title="0">{
        // deduplicate crosslinks if any
        m := map[uint32]map[uint64]types.CrossLink{}
        for _, cl := range crossLinks </span><span class="cov0" title="0">{
                if _, ok := m[cl.ShardID()]; !ok </span><span class="cov0" title="0">{
                        m[cl.ShardID()] = map[uint64]types.CrossLink{}
                }</span>
                <span class="cov0" title="0">m[cl.ShardID()][cl.BlockNum()] = cl</span>
        }

        <span class="cov0" title="0">cls := []types.CrossLink{}
        for _, m1 := range m </span><span class="cov0" title="0">{
                for _, cl := range m1 </span><span class="cov0" title="0">{
                        cls = append(cls, cl)
                }</span>
        }
        <span class="cov0" title="0">utils.Logger().Debug().Msgf("[CachePendingCrossLinks] Before Dedup has %d cls, after Dedup has %d cls", len(crossLinks), len(cls))

        bc.pendingCrossLinksCache.Add(pendingCLCacheKey, cls)
        return nil</span>
}

// SavePendingCrossLinks saves the pending crosslinks in db
func (bc *BlockChain) SavePendingCrossLinks() error <span class="cov0" title="0">{
        if cached, ok := bc.pendingCrossLinksCache.Get(pendingCLCacheKey); ok </span><span class="cov0" title="0">{
                cls := cached.([]types.CrossLink)
                bytes, err := rlp.EncodeToBytes(cls)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WritePendingCrossLinks(bc.db, bytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// AddPendingSlashingCandidates appends pending slashing candidates
func (bc *BlockChain) AddPendingSlashingCandidates(
        candidates slash.Records,
) error <span class="cov0" title="0">{
        bc.pendingSlashingCandidatesMU.Lock()
        defer bc.pendingSlashingCandidatesMU.Unlock()
        current := bc.ReadPendingSlashingCandidates()

        state, err := bc.State()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">valid := slash.Records{}
        for i := range candidates </span><span class="cov0" title="0">{
                if err := slash.Verify(bc, state, &amp;candidates[i]); err == nil </span><span class="cov0" title="0">{
                        valid = append(valid, candidates[i])
                }</span>
        }

        <span class="cov0" title="0">pendingSlashes := append(
                bc.pendingSlashes, current.SetDifference(valid)...,
        )

        if l, c := len(pendingSlashes), len(current); l &gt; maxPendingSlashes </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        errExceedMaxPendingSlashes, "current %d with-additional %d", c, l,
                )
        }</span>
        <span class="cov0" title="0">bc.pendingSlashes = pendingSlashes
        return bc.writeSlashes(bc.pendingSlashes)</span>
}

// AddPendingCrossLinks appends pending crosslinks
func (bc *BlockChain) AddPendingCrossLinks(pendingCLs []types.CrossLink) (int, error) <span class="cov0" title="0">{
        bc.pendingCrossLinksMutex.Lock()
        defer bc.pendingCrossLinksMutex.Unlock()

        cls, err := bc.ReadPendingCrossLinks()
        if err != nil || len(cls) == 0 </span><span class="cov0" title="0">{
                err := bc.CachePendingCrossLinks(pendingCLs)
                return len(pendingCLs), err
        }</span>
        <span class="cov0" title="0">cls = append(cls, pendingCLs...)
        err = bc.CachePendingCrossLinks(cls)
        return len(cls), err</span>
}

// DeleteFromPendingCrossLinks delete pending crosslinks that already committed (i.e. passed in the params)
func (bc *BlockChain) DeleteFromPendingCrossLinks(crossLinks []types.CrossLink) (int, error) <span class="cov0" title="0">{
        bc.pendingCrossLinksMutex.Lock()
        defer bc.pendingCrossLinksMutex.Unlock()

        cls, err := bc.ReadPendingCrossLinks()
        if err != nil || len(cls) == 0 </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">m := map[uint32]map[uint64]struct{}{}
        for _, cl := range crossLinks </span><span class="cov0" title="0">{
                if _, ok := m[cl.ShardID()]; !ok </span><span class="cov0" title="0">{
                        m[cl.ShardID()] = map[uint64]struct{}{}
                }</span>
                <span class="cov0" title="0">m[cl.ShardID()][cl.BlockNum()] = struct{}{}</span>
        }

        <span class="cov0" title="0">pendingCLs := []types.CrossLink{}

        for _, cl := range cls </span><span class="cov0" title="0">{
                if _, ok := m[cl.ShardID()]; ok </span><span class="cov0" title="0">{
                        if _, ok1 := m[cl.ShardID()][cl.BlockNum()]; ok1 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">pendingCLs = append(pendingCLs, cl)</span>
        }
        <span class="cov0" title="0">err = bc.CachePendingCrossLinks(pendingCLs)
        return len(pendingCLs), err</span>
}

// IsSameLeaderAsPreviousBlock retrieves a block from the database by number, caching it
func (bc *BlockChain) IsSameLeaderAsPreviousBlock(block *types.Block) bool <span class="cov0" title="0">{
        if IsEpochBlock(block) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">previousHeader := bc.GetHeaderByNumber(block.NumberU64() - 1)
        if previousHeader == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return block.Coinbase() == previousHeader.Coinbase()</span>
}

// GetVMConfig returns the block chain VM config.
func (bc *BlockChain) GetVMConfig() *vm.Config <span class="cov0" title="0">{
        return &amp;bc.vmConfig
}</span>

// ReadCXReceipts retrieves the cross shard transaction receipts of a given shard
func (bc *BlockChain) ReadCXReceipts(shardID uint32, blockNum uint64, blockHash common.Hash) (types.CXReceipts, error) <span class="cov0" title="0">{
        cxs, err := rawdb.ReadCXReceipts(bc.db, shardID, blockNum, blockHash)
        if err != nil || len(cxs) == 0 </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cxs, nil</span>
}

// CXMerkleProof calculates the cross shard transaction merkle proof of a given destination shard
func (bc *BlockChain) CXMerkleProof(toShardID uint32, block *types.Block) (*types.CXMerkleProof, error) <span class="cov0" title="0">{
        proof := &amp;types.CXMerkleProof{BlockNum: block.Number(), BlockHash: block.Hash(), ShardID: block.ShardID(), CXReceiptHash: block.Header().OutgoingReceiptHash(), CXShardHashes: []common.Hash{}, ShardIDs: []uint32{}}

        epoch := block.Header().Epoch()
        shardingConfig := shard.Schedule.InstanceForEpoch(epoch)
        shardNum := int(shardingConfig.NumShards())

        for i := 0; i &lt; shardNum; i++ </span><span class="cov0" title="0">{
                receipts, err := bc.ReadCXReceipts(uint32(i), block.NumberU64(), block.Hash())
                if err != nil || len(receipts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        hash := types.DeriveSha(receipts)
                        proof.CXShardHashes = append(proof.CXShardHashes, hash)
                        proof.ShardIDs = append(proof.ShardIDs, uint32(i))
                }</span>
        }
        <span class="cov0" title="0">if len(proof.ShardIDs) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return proof, nil</span>
}

// WriteCXReceiptsProofSpent mark the CXReceiptsProof list with given unspent status
// true: unspent, false: spent
func (bc *BlockChain) WriteCXReceiptsProofSpent(db rawdb.DatabaseWriter, cxps []*types.CXReceiptsProof) error <span class="cov8" title="1">{
        for _, cxp := range cxps </span><span class="cov0" title="0">{
                if err := rawdb.WriteCXReceiptsProofSpent(db, cxp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// IsSpent checks whether a CXReceiptsProof is unspent
func (bc *BlockChain) IsSpent(cxp *types.CXReceiptsProof) bool <span class="cov0" title="0">{
        shardID := cxp.MerkleProof.ShardID
        blockNum := cxp.MerkleProof.BlockNum.Uint64()
        by, _ := rawdb.ReadCXReceiptsProofSpent(bc.db, shardID, blockNum)
        return by == rawdb.SpentByte
}</span>

// ReadTxLookupEntry returns where the given transaction resides in the chain,
// as a (block hash, block number, index in transaction list) triple.
// returns 0, 0 if not found
func (bc *BlockChain) ReadTxLookupEntry(txID common.Hash) (common.Hash, uint64, uint64) <span class="cov0" title="0">{
        return rawdb.ReadTxLookupEntry(bc.db, txID)
}</span>

// ReadValidatorInformationAtRoot reads staking
// information of given validatorWrapper at a specific state root
func (bc *BlockChain) ReadValidatorInformationAtRoot(
        addr common.Address, root common.Hash,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        state, err := bc.StateAt(root)
        if err != nil || state == nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "at root: %s", root.Hex())
        }</span>
        <span class="cov0" title="0">return bc.ReadValidatorInformationAtState(addr, state)</span>
}

// ReadValidatorInformationAtState reads staking
// information of given validatorWrapper at a specific state root
func (bc *BlockChain) ReadValidatorInformationAtState(
        addr common.Address, state *state.DB,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        if state == nil </span><span class="cov0" title="0">{
                return nil, errors.New("empty state")
        }</span>
        <span class="cov0" title="0">wrapper, err := state.ValidatorWrapper(addr, true, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return wrapper, nil</span>
}

// ReadValidatorInformation reads staking information of given validator address
func (bc *BlockChain) ReadValidatorInformation(
        addr common.Address,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        return bc.ReadValidatorInformationAtRoot(addr, bc.CurrentBlock().Root())
}</span>

// ReadValidatorSnapshotAtEpoch reads the snapshot
// staking validator information of given validator address
func (bc *BlockChain) ReadValidatorSnapshotAtEpoch(
        epoch *big.Int,
        addr common.Address,
) (*staking.ValidatorSnapshot, error) <span class="cov0" title="0">{
        return rawdb.ReadValidatorSnapshot(bc.db, addr, epoch)
}</span>

// ReadValidatorSnapshot reads the snapshot staking information of given validator address
func (bc *BlockChain) ReadValidatorSnapshot(
        addr common.Address,
) (*staking.ValidatorSnapshot, error) <span class="cov8" title="1">{
        epoch := bc.CurrentBlock().Epoch()
        key := addr.Hex() + epoch.String()
        if cached, ok := bc.validatorSnapshotCache.Get(key); ok </span><span class="cov8" title="1">{
                return cached.(*staking.ValidatorSnapshot), nil
        }</span>
        <span class="cov0" title="0">vs, err := rawdb.ReadValidatorSnapshot(bc.db, addr, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bc.validatorSnapshotCache.Add(key, vs)
        return vs, nil</span>
}

// WriteValidatorSnapshot writes the snapshot of provided validator
func (bc *BlockChain) WriteValidatorSnapshot(
        batch rawdb.DatabaseWriter, snapshot *staking.ValidatorSnapshot,
) error <span class="cov8" title="1">{
        // Batch write the current data as snapshot
        if err := rawdb.WriteValidatorSnapshot(batch, snapshot.Validator, snapshot.Epoch); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update cache
        <span class="cov8" title="1">key := snapshot.Validator.Address.Hex() + snapshot.Epoch.String()
        bc.validatorSnapshotCache.Add(key, snapshot)
        return nil</span>
}

// ReadValidatorStats reads the stats of a validator
func (bc *BlockChain) ReadValidatorStats(
        addr common.Address,
) (*staking.ValidatorStats, error) <span class="cov0" title="0">{
        return rawdb.ReadValidatorStats(bc.db, addr)
}</span>

// UpdateValidatorVotingPower writes the voting power for the committees
func (bc *BlockChain) UpdateValidatorVotingPower(
        batch rawdb.DatabaseWriter,
        block *types.Block,
        newEpochSuperCommittee, currentEpochSuperCommittee *shard.State,
        state *state.DB,
) (map[common.Address]*staking.ValidatorStats, error) <span class="cov0" title="0">{
        if newEpochSuperCommittee == nil </span><span class="cov0" title="0">{
                return nil, shard.ErrSuperCommitteeNil
        }</span>

        <span class="cov0" title="0">validatorStats := map[common.Address]*staking.ValidatorStats{}

        existing, replacing :=
                currentEpochSuperCommittee.StakedValidators(),
                newEpochSuperCommittee.StakedValidators()

        // TODO could also keep track of the BLS keys which
        // lost a slot because just losing slots doesn't mean that the
        // validator was booted, just that some of their keys lost slots
        for currentValidator := range existing.LookupSet </span><span class="cov0" title="0">{
                if _, keptSlot := replacing.LookupSet[currentValidator]; !keptSlot </span><span class="cov0" title="0">{
                        // NOTE Think carefully about when time comes to delete offchain things
                        // TODO Someone: collect and then delete every 30 epochs
                        // rawdb.DeleteValidatorSnapshot(
                        //         bc.db, currentValidator, currentEpochSuperCommittee.Epoch,
                        // )
                        // rawdb.DeleteValidatorStats(bc.db, currentValidator)
                        stats, err := rawdb.ReadValidatorStats(bc.db, currentValidator)
                        if err != nil </span><span class="cov0" title="0">{
                                stats = staking.NewEmptyStats()
                        }</span>
                        // This means it's already in staking epoch
                        <span class="cov0" title="0">if currentEpochSuperCommittee.Epoch != nil </span><span class="cov0" title="0">{
                                wrapper, err := state.ValidatorWrapper(currentValidator, true, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">if slash.IsBanned(wrapper) </span><span class="cov0" title="0">{
                                        stats.BootedStatus = effective.BannedForDoubleSigning
                                }</span> else<span class="cov0" title="0"> if wrapper.Status == effective.Inactive </span><span class="cov0" title="0">{
                                        stats.BootedStatus = effective.TurnedInactiveOrInsufficientUptime
                                }</span> else<span class="cov0" title="0"> {
                                        stats.BootedStatus = effective.LostEPoSAuction
                                }</span>

                                // compute APR for the exiting validators
                                <span class="cov0" title="0">if err := bc.ComputeAndUpdateAPR(
                                        block, currentEpochSuperCommittee.Epoch, wrapper, stats,
                                ); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">validatorStats[currentValidator] = stats</span>
                }
        }

        <span class="cov0" title="0">rosters := make([]*votepower.Roster, len(newEpochSuperCommittee.Shards))
        for i := range newEpochSuperCommittee.Shards </span><span class="cov0" title="0">{
                subCommittee := &amp;newEpochSuperCommittee.Shards[i]
                if newEpochSuperCommittee.Epoch == nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(
                                errNilEpoch,
                                "block epoch %v current-committee-epoch %v",
                                block.Epoch(),
                                currentEpochSuperCommittee.Epoch,
                        )
                }</span>
                <span class="cov0" title="0">roster, err := votepower.Compute(subCommittee, newEpochSuperCommittee.Epoch)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rosters[i] = roster</span>
        }

        <span class="cov0" title="0">networkWide := votepower.AggregateRosters(rosters)
        for key, value := range networkWide </span><span class="cov0" title="0">{
                stats, err := rawdb.ReadValidatorStats(bc.db, key)
                if err != nil </span><span class="cov0" title="0">{
                        stats = staking.NewEmptyStats()
                }</span>
                <span class="cov0" title="0">total := numeric.ZeroDec()
                for i := range value </span><span class="cov0" title="0">{
                        total = total.Add(value[i].EffectiveStake)
                }</span>
                <span class="cov0" title="0">stats.TotalEffectiveStake = total
                earningWrapping := make([]staking.VoteWithCurrentEpochEarning, len(value))
                for i := range value </span><span class="cov0" title="0">{
                        earningWrapping[i] = staking.VoteWithCurrentEpochEarning{
                                Vote:   value[i],
                                Earned: big.NewInt(0),
                        }
                }</span>
                <span class="cov0" title="0">stats.MetricsPerShard = earningWrapping

                // fetch raw-stake from snapshot and update per-key metrics
                if snapshot, err := bc.ReadValidatorSnapshotAtEpoch(
                        newEpochSuperCommittee.Epoch, key,
                ); err == nil </span><span class="cov0" title="0">{
                        wrapper := snapshot.Validator
                        spread := numeric.ZeroDec()
                        if len(wrapper.SlotPubKeys) &gt; 0 </span><span class="cov0" title="0">{
                                spread = numeric.NewDecFromBigInt(wrapper.TotalDelegation()).
                                        QuoInt64(int64(len(wrapper.SlotPubKeys)))
                        }</span>
                        <span class="cov0" title="0">for i := range stats.MetricsPerShard </span><span class="cov0" title="0">{
                                stats.MetricsPerShard[i].Vote.RawStake = spread
                        }</span>
                }

                // This means it's already in staking epoch, and
                // compute APR for validators in current committee only
                <span class="cov0" title="0">if currentEpochSuperCommittee.Epoch != nil </span><span class="cov0" title="0">{
                        if _, ok := existing.LookupSet[key]; ok </span><span class="cov0" title="0">{
                                wrapper, err := state.ValidatorWrapper(key, true, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">if err := bc.ComputeAndUpdateAPR(
                                        block, currentEpochSuperCommittee.Epoch, wrapper, stats,
                                ); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                }
                <span class="cov0" title="0">validatorStats[key] = stats</span>
        }

        <span class="cov0" title="0">return validatorStats, nil</span>
}

// ComputeAndUpdateAPR ...
func (bc *BlockChain) ComputeAndUpdateAPR(
        block *types.Block, now *big.Int,
        wrapper *staking.ValidatorWrapper, stats *staking.ValidatorStats,
) error <span class="cov0" title="0">{
        if aprComputed, err := apr.ComputeForValidator(
                bc, block, wrapper,
        ); err != nil </span><span class="cov0" title="0">{
                if errors.Cause(err) == apr.ErrInsufficientEpoch </span><span class="cov0" title="0">{
                        utils.Logger().Info().Err(err).Msg("apr could not be computed")
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // only insert if APR for current epoch does not exists
                aprEntry := staking.APREntry{now, *aprComputed}
                l := len(stats.APRs)
                // first time inserting apr for validator or
                // apr for current epoch does not exists
                // check the last entry's epoch, if not same, insert
                if l == 0 || stats.APRs[l-1].Epoch.Cmp(now) != 0 </span><span class="cov0" title="0">{
                        stats.APRs = append(stats.APRs, aprEntry)
                }</span>
                // if history is more than staking.APRHistoryLength, pop front
                <span class="cov0" title="0">if l &gt; staking.APRHistoryLength </span><span class="cov0" title="0">{
                        stats.APRs = stats.APRs[1:]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// UpdateValidatorSnapshots updates the content snapshot of all validators
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateValidatorSnapshots(
        batch rawdb.DatabaseWriter, epoch *big.Int, state *state.DB, newValidators []common.Address,
) error <span class="cov0" title="0">{
        // Note this is reading the validator list from last block.
        // It's fine since the new validators from this block is already snapshot when created.
        allValidators, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allValidators = append(allValidators, newValidators...)

        // Read all validator's current data and snapshot them
        for i := range allValidators </span><span class="cov0" title="0">{
                // The snapshot will be captured in the state after the last epoch block is finalized
                validator, err := state.ValidatorWrapper(allValidators[i], true, false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">snapshot := &amp;staking.ValidatorSnapshot{validator, epoch}
                if err := bc.WriteValidatorSnapshot(batch, snapshot); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ReadValidatorList reads the addresses of current all validators
func (bc *BlockChain) ReadValidatorList() ([]common.Address, error) <span class="cov8" title="1">{
        if cached, ok := bc.validatorListCache.Get("validatorList"); ok </span><span class="cov0" title="0">{
                by := cached.([]byte)
                m := []common.Address{}
                if err := rlp.DecodeBytes(by, &amp;m); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        }
        <span class="cov8" title="1">return rawdb.ReadValidatorList(bc.db)</span>
}

// WriteValidatorList writes the list of validator addresses to database
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) WriteValidatorList(
        db rawdb.DatabaseWriter, addrs []common.Address,
) error <span class="cov0" title="0">{
        if err := rawdb.WriteValidatorList(db, addrs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bytes, err := rlp.EncodeToBytes(addrs)
        if err == nil </span><span class="cov0" title="0">{
                bc.validatorListCache.Add("validatorList", bytes)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadDelegationsByDelegator reads the addresses of validators delegated by a delegator
func (bc *BlockChain) ReadDelegationsByDelegator(
        delegator common.Address,
) (m staking.DelegationIndexes, err error) <span class="cov8" title="1">{
        rawResult := staking.DelegationIndexes{}
        if cached, ok := bc.validatorListByDelegatorCache.Get(string(delegator.Bytes())); ok </span><span class="cov8" title="1">{
                by := cached.([]byte)
                if err := rlp.DecodeBytes(by, &amp;rawResult); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                if rawResult, err = rawdb.ReadDelegationsByDelegator(bc.db, delegator); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">blockNum := bc.CurrentBlock().Number()
        for _, index := range rawResult </span><span class="cov8" title="1">{
                if index.BlockNum.Cmp(blockNum) &lt;= 0 </span><span class="cov8" title="1">{
                        m = append(m, index)
                }</span> else<span class="cov0" title="0"> {
                        // Filter out index that's created beyond current height of chain.
                        // This only happens when there is a chain rollback.
                        utils.Logger().Warn().Msgf("Future delegation index encountered. Skip: %+v", index)
                }</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

// ReadDelegationsByDelegatorAt reads the addresses of validators delegated by a delegator at a given block
func (bc *BlockChain) ReadDelegationsByDelegatorAt(
        delegator common.Address, blockNum *big.Int,
) (m staking.DelegationIndexes, err error) <span class="cov0" title="0">{
        rawResult := staking.DelegationIndexes{}
        if cached, ok := bc.validatorListByDelegatorCache.Get(string(delegator.Bytes())); ok </span><span class="cov0" title="0">{
                by := cached.([]byte)
                if err := rlp.DecodeBytes(by, &amp;rawResult); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                if rawResult, err = rawdb.ReadDelegationsByDelegator(bc.db, delegator); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">for _, index := range rawResult </span><span class="cov0" title="0">{
                if index.BlockNum.Cmp(blockNum) &lt;= 0 </span><span class="cov0" title="0">{
                        m = append(m, index)
                }</span> else<span class="cov0" title="0"> {
                        // Filter out index that's created beyond current height of chain.
                        // This only happens when there is a chain rollback.
                        utils.Logger().Warn().Msgf("Future delegation index encountered. Skip: %+v", index)
                }</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

// writeDelegationsByDelegator writes the list of validator addresses to database
func (bc *BlockChain) writeDelegationsByDelegator(
        batch rawdb.DatabaseWriter,
        delegator common.Address,
        indices []staking.DelegationIndex,
) error <span class="cov8" title="1">{
        if err := rawdb.WriteDelegationsByDelegator(
                batch, delegator, indices,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">bytes, err := rlp.EncodeToBytes(indices)
        if err == nil </span><span class="cov8" title="1">{
                bc.validatorListByDelegatorCache.Add(string(delegator.Bytes()), bytes)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateStakingMetaData updates the metadata of validators and delegations,
// including the full validator list and delegation indexes.
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateStakingMetaData(
        batch rawdb.DatabaseWriter, block *types.Block,
        stakeMsgs []staking.StakeMsg,
        state *state.DB, epoch, newEpoch *big.Int,
) (newValidators []common.Address, err error) <span class="cov8" title="1">{
        newValidators, newDelegations, err := bc.prepareStakingMetaData(block, stakeMsgs, state)
        if err != nil </span><span class="cov0" title="0">{
                utils.Logger().Warn().Msgf("oops, prepareStakingMetaData failed, err: %+v", err)
                return newValidators, err
        }</span>

        <span class="cov8" title="1">if len(newValidators) &gt; 0 </span><span class="cov0" title="0">{
                list, err := bc.ReadValidatorList()
                if err != nil </span><span class="cov0" title="0">{
                        return newValidators, err
                }</span>

                <span class="cov0" title="0">valMap := map[common.Address]struct{}{}
                for _, addr := range list </span><span class="cov0" title="0">{
                        valMap[addr] = struct{}{}
                }</span>

                <span class="cov0" title="0">newAddrs := []common.Address{}
                for _, addr := range newValidators </span><span class="cov0" title="0">{
                        if _, ok := valMap[addr]; !ok </span><span class="cov0" title="0">{
                                newAddrs = append(newAddrs, addr)
                        }</span>

                        // Update validator snapshot for the new validator
                        <span class="cov0" title="0">validator, err := state.ValidatorWrapper(addr, true, false)
                        if err != nil </span><span class="cov0" title="0">{
                                return newValidators, err
                        }</span>

                        <span class="cov0" title="0">if err := bc.WriteValidatorSnapshot(batch, &amp;staking.ValidatorSnapshot{validator, epoch}); err != nil </span><span class="cov0" title="0">{
                                return newValidators, err
                        }</span>
                        // For validator created at exactly the last block of an epoch, we should create the snapshot
                        // for next epoch too.
                        <span class="cov0" title="0">if newEpoch.Cmp(epoch) &gt; 0 </span><span class="cov0" title="0">{
                                if err := bc.WriteValidatorSnapshot(batch, &amp;staking.ValidatorSnapshot{validator, newEpoch}); err != nil </span><span class="cov0" title="0">{
                                        return newValidators, err
                                }</span>
                        }
                }

                // Update validator list
                <span class="cov0" title="0">list = append(list, newAddrs...)
                if err = bc.WriteValidatorList(batch, list); err != nil </span><span class="cov0" title="0">{
                        return newValidators, err
                }</span>
        }

        <span class="cov8" title="1">for addr, delegations := range newDelegations </span><span class="cov0" title="0">{
                if err := bc.writeDelegationsByDelegator(batch, addr, delegations); err != nil </span><span class="cov0" title="0">{
                        return newValidators, err
                }</span>
        }
        <span class="cov8" title="1">return newValidators, nil</span>
}

// prepareStakingMetaData prepare the updates of validator's
// and the delegator's meta data according to staking transaction.
// The following return values are cached end state to be written to DB.
// The reason for the cached state is to solve the issue that batch DB changes
// won't be reflected immediately so the intermediary state can't be read from DB.
// newValidators - the addresses of the newly created validators
// newDelegations - the map of delegator address and their updated delegation indexes
func (bc *BlockChain) prepareStakingMetaData(
        block *types.Block, stakeMsgs []staking.StakeMsg, state *state.DB,
) ([]common.Address,
        map[common.Address]staking.DelegationIndexes,
        error,
) <span class="cov8" title="1">{
        var newValidators []common.Address
        newDelegations := map[common.Address]staking.DelegationIndexes{}
        blockNum := block.Number()
        for _, stakeMsg := range stakeMsgs </span><span class="cov8" title="1">{
                if delegate, ok := stakeMsg.(*staking.Delegate); ok </span><span class="cov8" title="1">{
                        if err := processDelegateMetadata(delegate,
                                newDelegations,
                                state,
                                bc,
                                blockNum); err != nil </span><span class="cov8" title="1">{
                                return nil, nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        panic("Only *staking.Delegate stakeMsgs are supported at the moment")</span>
                }
        }
        <span class="cov8" title="1">for _, txn := range block.StakingTransactions() </span><span class="cov0" title="0">{
                payload, err := txn.RLPEncodeStakeMsg()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">decodePayload, err := staking.RLPDecodeStakeMsg(payload, txn.StakingType())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">switch txn.StakingType() </span>{
                case staking.DirectiveCreateValidator:<span class="cov0" title="0">
                        createValidator := decodePayload.(*staking.CreateValidator)
                        newList, appended := utils.AppendIfMissing(
                                newValidators, createValidator.ValidatorAddress,
                        )
                        if !appended </span><span class="cov0" title="0">{
                                return nil, nil, errValidatorExist
                        }</span>
                        <span class="cov0" title="0">newValidators = newList

                        // Add self delegation into the index
                        selfIndex := staking.DelegationIndex{
                                createValidator.ValidatorAddress,
                                uint64(0),
                                blockNum,
                        }
                        delegations, ok := newDelegations[createValidator.ValidatorAddress]
                        if !ok </span><span class="cov0" title="0">{
                                // If the cache doesn't have it, load it from DB for the first time.
                                delegations, err = bc.ReadDelegationsByDelegator(createValidator.ValidatorAddress)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">delegations = append(delegations, selfIndex)
                        newDelegations[createValidator.ValidatorAddress] = delegations</span>
                case staking.DirectiveEditValidator:<span class="cov0" title="0"></span>
                case staking.DirectiveDelegate:<span class="cov0" title="0">
                        delegate := decodePayload.(*staking.Delegate)
                        if err := processDelegateMetadata(delegate,
                                newDelegations,
                                state,
                                bc,
                                blockNum); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>

                case staking.DirectiveUndelegate:<span class="cov0" title="0"></span>
                case staking.DirectiveCollectRewards:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov8" title="1">return newValidators, newDelegations, nil</span>
}

func processDelegateMetadata(delegate *staking.Delegate,
        newDelegations map[common.Address]staking.DelegationIndexes,
        state *state.DB, bc *BlockChain, blockNum *big.Int,
) (err error) <span class="cov8" title="1">{
        delegations, ok := newDelegations[delegate.DelegatorAddress]
        if !ok </span><span class="cov8" title="1">{
                // If the cache doesn't have it, load it from DB for the first time.
                delegations, err = bc.ReadDelegationsByDelegator(delegate.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if delegations, err = bc.addDelegationIndex(
                delegations, delegate.DelegatorAddress, delegate.ValidatorAddress, state, blockNum,
        ); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">newDelegations[delegate.DelegatorAddress] = delegations
        return nil</span>
}

// ReadBlockRewardAccumulator must only be called on beaconchain
// Note that block rewards are only for staking era.
func (bc *BlockChain) ReadBlockRewardAccumulator(number uint64) (*big.Int, error) <span class="cov0" title="0">{
        if !bc.chainConfig.IsStaking(shard.Schedule.CalcEpochNumber(number)) </span><span class="cov0" title="0">{
                return big.NewInt(0), nil
        }</span>
        <span class="cov0" title="0">if cached, ok := bc.blockAccumulatorCache.Get(number); ok </span><span class="cov0" title="0">{
                return cached.(*big.Int), nil
        }</span>
        <span class="cov0" title="0">return rawdb.ReadBlockRewardAccumulator(bc.db, number)</span>
}

// WriteBlockRewardAccumulator directly writes the BlockRewardAccumulator value
// Note: this should only be called once during staking launch.
func (bc *BlockChain) WriteBlockRewardAccumulator(
        batch rawdb.DatabaseWriter, reward *big.Int, number uint64,
) error <span class="cov8" title="1">{
        if err := rawdb.WriteBlockRewardAccumulator(
                batch, reward, number,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">bc.blockAccumulatorCache.Add(number, reward)
        return nil</span>
}

// UpdateBlockRewardAccumulator ..
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateBlockRewardAccumulator(
        batch rawdb.DatabaseWriter, diff *big.Int, number uint64,
) error <span class="cov0" title="0">{
        current, err := bc.ReadBlockRewardAccumulator(number - 1)
        if err != nil </span><span class="cov0" title="0">{
                // one-off fix for pangaea, return after pangaea enter staking.
                current = big.NewInt(0)
                bc.WriteBlockRewardAccumulator(batch, current, number)
        }</span>
        <span class="cov0" title="0">return bc.WriteBlockRewardAccumulator(batch, new(big.Int).Add(current, diff), number)</span>
}

// Note this should read from the state of current block in concern (root == newBlock.root)
func (bc *BlockChain) addDelegationIndex(
        delegations staking.DelegationIndexes,
        delegatorAddress, validatorAddress common.Address, state *state.DB, blockNum *big.Int,
) (staking.DelegationIndexes, error) <span class="cov8" title="1">{
        // If there is an existing delegation, just return
        validatorAddressBytes := validatorAddress.Bytes()
        for _, delegation := range delegations </span><span class="cov0" title="0">{
                if bytes.Equal(delegation.ValidatorAddress[:], validatorAddressBytes[:]) </span><span class="cov0" title="0">{
                        return delegations, nil
                }</span>
        }

        // Found the delegation from state and add the delegation index
        // Note this should read from the state of current block in concern
        <span class="cov8" title="1">wrapper, err := state.ValidatorWrapper(validatorAddress, true, false)
        if err != nil </span><span class="cov8" title="1">{
                return delegations, err
        }</span>
        <span class="cov0" title="0">for i := range wrapper.Delegations </span><span class="cov0" title="0">{
                if bytes.Equal(
                        wrapper.Delegations[i].DelegatorAddress[:], delegatorAddress[:],
                ) </span><span class="cov0" title="0">{
                        // TODO(audit): change the way of indexing if we allow delegation deletion.
                        delegations = append(delegations, staking.DelegationIndex{
                                validatorAddress,
                                uint64(i),
                                blockNum,
                        })
                }</span>
        }
        <span class="cov0" title="0">return delegations, nil</span>
}

// ValidatorCandidates returns the up to date validator candidates for next epoch
func (bc *BlockChain) ValidatorCandidates() []common.Address <span class="cov0" title="0">{
        list, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov0" title="0">{
                return make([]common.Address, 0)
        }</span>
        <span class="cov0" title="0">return list</span>
}

// DelegatorsInformation returns up to date information of delegators of a given validator address
func (bc *BlockChain) DelegatorsInformation(addr common.Address) []*staking.Delegation <span class="cov0" title="0">{
        return make([]*staking.Delegation, 0)
}</span>

// GetECDSAFromCoinbase retrieve corresponding ecdsa address from Coinbase Address
// TODO: optimize this func by adding cache etc.
func (bc *BlockChain) GetECDSAFromCoinbase(header *block.Header) (common.Address, error) <span class="cov8" title="1">{
        // backward compatibility: before isStaking epoch, coinbase address is the ecdsa address
        coinbase := header.Coinbase()
        isStaking := bc.Config().IsStaking(header.Epoch())
        if !isStaking </span><span class="cov8" title="1">{
                return coinbase, nil
        }</span>

        <span class="cov0" title="0">shardState, err := bc.ReadShardState(header.Epoch())
        if err != nil </span><span class="cov0" title="0">{
                return common.Address{}, errors.Wrapf(
                        err, "cannot read shard state",
                )
        }</span>

        <span class="cov0" title="0">committee, err := shardState.FindCommitteeByID(header.ShardID())
        if err != nil </span><span class="cov0" title="0">{
                return common.Address{}, errors.Wrapf(
                        err, "cannot find shard in the shard state",
                )
        }</span>
        <span class="cov0" title="0">for _, member := range committee.Slots </span><span class="cov0" title="0">{
                // After staking the coinbase address will be the address of bls public key
                if bytes.Equal(member.EcdsaAddress[:], coinbase[:]) </span><span class="cov0" title="0">{
                        return member.EcdsaAddress, nil
                }</span>

                <span class="cov0" title="0">if utils.GetAddressFromBLSPubKeyBytes(member.BLSPublicKey[:]) == coinbase </span><span class="cov0" title="0">{
                        return member.EcdsaAddress, nil
                }</span>
        }
        <span class="cov0" title="0">return common.Address{}, errors.Errorf(
                "cannot find corresponding ECDSA Address for coinbase %s",
                header.Coinbase().Hash().Hex(),
        )</span>
}

// SuperCommitteeForNextEpoch ...
// isVerify=true means validators use it to verify
// isVerify=false means leader is to propose
func (bc *BlockChain) SuperCommitteeForNextEpoch(
        beacon consensus_engine.ChainReader,
        header *block.Header,
        isVerify bool,
) (*shard.State, error) <span class="cov0" title="0">{
        var (
                nextCommittee = new(shard.State)
                err           error
                beaconEpoch   = new(big.Int)
                shardState    = shard.State{}
        )
        switch header.ShardID() </span>{
        case shard.BeaconChainShardID:<span class="cov0" title="0">
                if shard.Schedule.IsLastBlock(header.Number().Uint64()) </span><span class="cov0" title="0">{
                        nextCommittee, err = committee.WithStakingEnabled.Compute(
                                new(big.Int).Add(header.Epoch(), common.Big1),
                                beacon,
                        )
                }</span>
        default:<span class="cov0" title="0">
                // TODO: needs to make sure beacon chain sync works.
                if isVerify </span><span class="cov0" title="0">{
                        //verify
                        shardState, err = header.GetShardState()
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;shard.State{}, err
                        }</span>
                        // before staking epoch
                        <span class="cov0" title="0">if shardState.Epoch == nil </span><span class="cov0" title="0">{
                                beaconEpoch = new(big.Int).Add(header.Epoch(), common.Big1)
                        }</span> else<span class="cov0" title="0"> { // after staking epoch
                                beaconEpoch = shardState.Epoch
                        }</span>
                } else<span class="cov0" title="0"> {
                        //propose
                        beaconEpoch = beacon.CurrentHeader().Epoch()
                }</span>
                <span class="cov0" title="0">utils.Logger().Debug().Msgf("[SuperCommitteeCalculation] isVerify: %+v, realBeaconEpoch:%+v, beaconEpoch: %+v, headerEpoch:%+v, shardStateEpoch:%+v",
                        isVerify, beacon.CurrentHeader().Epoch(), beaconEpoch, header.Epoch(), shardState.Epoch)
                nextEpoch := new(big.Int).Add(header.Epoch(), common.Big1)
                if bc.Config().IsStaking(nextEpoch) </span><span class="cov0" title="0">{
                        // If next epoch is staking epoch, I should wait and listen for beacon chain for epoch changes
                        switch beaconEpoch.Cmp(header.Epoch()) </span>{
                        case 1:<span class="cov0" title="0">
                                // If beacon chain is bigger than shard chain in epoch, it means I should catch up with beacon chain now
                                nextCommittee, err = committee.WithStakingEnabled.ReadFromDB(
                                        beaconEpoch, beacon,
                                )

                                utils.Logger().Debug().
                                        Uint64("blockNum", header.Number().Uint64()).
                                        Uint64("myCurEpoch", header.Epoch().Uint64()).
                                        Uint64("beaconEpoch", beaconEpoch.Uint64()).
                                        Msg("Propose new epoch as beacon chain's epoch")</span>
                        case 0:<span class="cov0" title="0"></span>
                                // If it's same epoch, no need to propose new shard state (new epoch change)
                        case -1:<span class="cov0" title="0"></span>
                                // If beacon chain is behind, shard chain should wait for the beacon chain by not changing epochs.
                        }
                } else<span class="cov0" title="0"> {
                        if bc.Config().IsStaking(beaconEpoch) </span><span class="cov0" title="0">{
                                // If I am not even in the last epoch before staking epoch and beacon chain is already in staking epoch,
                                // I should just catch up with beacon chain's epoch
                                nextCommittee, err = committee.WithStakingEnabled.ReadFromDB(
                                        beaconEpoch, beacon,
                                )

                                utils.Logger().Debug().
                                        Uint64("blockNum", header.Number().Uint64()).
                                        Uint64("myCurEpoch", header.Epoch().Uint64()).
                                        Uint64("beaconEpoch", beaconEpoch.Uint64()).
                                        Msg("Propose entering staking along with beacon chain's epoch")
                        }</span> else<span class="cov0" title="0"> {
                                // If I are not in staking nor has beacon chain proposed a staking-based shard state,
                                // do pre-staking committee calculation
                                if shard.Schedule.IsLastBlock(header.Number().Uint64()) </span><span class="cov0" title="0">{
                                        nextCommittee, err = committee.WithStakingEnabled.Compute(
                                                nextEpoch,
                                                bc,
                                        )
                                }</span>
                        }
                }

        }
        <span class="cov0" title="0">return nextCommittee, err</span>
}

var (
        leveldbErrSpec         = "leveldb"
        tooManyOpenFilesErrStr = "Too many open files"
)

// isUnrecoverableErr check whether the input error is not recoverable.
// When writing db, there could be some possible errors from storage level (leveldb).
// Known possible leveldb errors are:
//  1. Leveldb is already closed. (leveldb.ErrClosed)
//  2. ldb file missing from disk. (leveldb.ErrNotFound)
//  3. Corrupted db data. (leveldb.errors.ErrCorrupted)
//  4. OS error when open file (too many open files, ...)
//  5. OS error when write file (read-only, not enough disk space, ...)
// Among all the above leveldb errors, only `too many open files` error is known to be recoverable,
// thus the unrecoverable errors refers to error that is
//  1. The error is from the lower storage level (from module leveldb)
//  2. The error is not too many files error.
func isUnrecoverableErr(err error) bool <span class="cov0" title="0">{
        isLeveldbErr := strings.Contains(err.Error(), leveldbErrSpec)
        isTooManyOpenFiles := strings.Contains(err.Error(), tooManyOpenFilesErrStr)
        return isLeveldbErr &amp;&amp; !isTooManyOpenFiles
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "fmt"
        "math/big"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethdb"

        "github.com/harmony-one/harmony/block"
        blockfactory "github.com/harmony-one/harmony/block/factory"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/shard"
        staking "github.com/harmony-one/harmony/staking/types"
)

// BlockGen creates blocks for testing.
// See GenerateChain for a detailed explanation.
type BlockGen struct {
        i        int
        parent   *types.Block
        chain    []*types.Block
        factory  blockfactory.Factory
        header   *block.Header
        statedb  *state.DB
        gasPool  *GasPool
        txs      []*types.Transaction
        receipts []*types.Receipt
        uncles   []*block.Header
        config   *params.ChainConfig
        engine   consensus_engine.Engine
}

// SetCoinbase sets the coinbase of the generated block.
// It can be called at most once.
func (b *BlockGen) SetCoinbase(addr common.Address) <span class="cov0" title="0">{
        if b.gasPool != nil </span><span class="cov0" title="0">{
                if len(b.txs) &gt; 0 </span><span class="cov0" title="0">{
                        panic("coinbase must be set before adding transactions")</span>
                }
                <span class="cov0" title="0">panic("coinbase can only be set once")</span>
        }
        <span class="cov0" title="0">b.header.SetCoinbase(addr)
        b.gasPool = new(GasPool).AddGas(b.header.GasLimit())</span>
}

// SetExtra sets the extra data field of the generated block.
func (b *BlockGen) SetExtra(data []byte) <span class="cov0" title="0">{
        b.header.SetExtra(data)
}</span>

// SetShardID sets the shardID field of the generated block.
func (b *BlockGen) SetShardID(shardID uint32) <span class="cov0" title="0">{
        b.header.SetShardID(shardID)
}</span>

// AddTx adds a transaction to the generated block. If no coinbase has
// been set, the block's coinbase is set to the zero address.
//
// AddTx panics if the transaction cannot be executed. In addition to
// the protocol-imposed limitations (gas limit, etc.), there are some
// further limitations on the content of transactions that can be
// added. Notably, contract code relying on the BLOCKHASH instruction
// will panic during execution.
func (b *BlockGen) AddTx(tx *types.Transaction) <span class="cov0" title="0">{
        b.AddTxWithChain(nil, tx)
}</span>

// AddTxWithChain adds a transaction to the generated block. If no coinbase has
// been set, the block's coinbase is set to the zero address.
//
// AddTxWithChain panics if the transaction cannot be executed. In addition to
// the protocol-imposed limitations (gas limit, etc.), there are some
// further limitations on the content of transactions that can be
// added. If contract code relies on the BLOCKHASH instruction,
// the block in chain will be returned.
func (b *BlockGen) AddTxWithChain(bc *BlockChain, tx *types.Transaction) <span class="cov0" title="0">{
        if b.gasPool == nil </span><span class="cov0" title="0">{
                b.SetCoinbase(common.Address{})
        }</span>
        <span class="cov0" title="0">b.statedb.Prepare(tx.Hash(), common.Hash{}, len(b.txs))
        coinbase := b.header.Coinbase()
        gasUsed := b.header.GasUsed()
        receipt, _, _, _, err := ApplyTransaction(b.config, bc, &amp;coinbase, b.gasPool, b.statedb, b.header, tx, &amp;gasUsed, vm.Config{})
        b.header.SetGasUsed(gasUsed)
        b.header.SetCoinbase(coinbase)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">b.txs = append(b.txs, tx)
        b.receipts = append(b.receipts, receipt)</span>
}

// Number returns the block number of the block being generated.
func (b *BlockGen) Number() *big.Int <span class="cov0" title="0">{
        return b.header.Number()
}</span>

// AddUncheckedReceipt forcefully adds a receipts to the block without a
// backing transaction.
//
// AddUncheckedReceipt will cause consensus failures when used during real
// chain processing. This is best used in conjunction with raw block insertion.
func (b *BlockGen) AddUncheckedReceipt(receipt *types.Receipt) <span class="cov0" title="0">{
        b.receipts = append(b.receipts, receipt)
}</span>

// TxNonce returns the next valid transaction nonce for the
// account at addr. It panics if the account does not exist.
func (b *BlockGen) TxNonce(addr common.Address) uint64 <span class="cov0" title="0">{
        if !b.statedb.Exist(addr) </span><span class="cov0" title="0">{
                panic("account does not exist")</span>
        }
        <span class="cov0" title="0">return b.statedb.GetNonce(addr)</span>
}

// AddUncle adds an uncle header to the generated block.
func (b *BlockGen) AddUncle(h *block.Header) <span class="cov0" title="0">{
        b.uncles = append(b.uncles, h)
}</span>

// PrevBlock returns a previously generated block by number. It panics if
// num is greater or equal to the number of the block being generated.
// For index -1, PrevBlock returns the parent block given to GenerateChain.
func (b *BlockGen) PrevBlock(index int) *types.Block <span class="cov0" title="0">{
        if index &gt;= b.i </span><span class="cov0" title="0">{
                panic(fmt.Errorf("block index %d out of range (%d,%d)", index, -1, b.i))</span>
        }
        <span class="cov0" title="0">if index == -1 </span><span class="cov0" title="0">{
                return b.parent
        }</span>
        <span class="cov0" title="0">return b.chain[index]</span>
}

// GenerateChain creates a chain of n blocks. The first block's
// parent will be the provided parent. db is used to store
// intermediate states and should contain the parent's state trie.
//
// The generator function is called with a new block generator for
// every block. Any transactions and uncles added to the generator
// become part of the block. If gen is nil, the blocks will be empty
// and their coinbase will be the zero address.
//
// Blocks created by GenerateChain do not contain valid proof of work
// values. Inserting them into BlockChain requires use of FakePow or
// a similar non-validating proof of work implementation.
func GenerateChain(
        config *params.ChainConfig, parent *types.Block,
        engine consensus_engine.Engine, db ethdb.Database,
        n int,
        gen func(int, *BlockGen),
) ([]*types.Block, []types.Receipts) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = params.TestChainConfig
        }</span>
        <span class="cov0" title="0">factory := blockfactory.NewFactory(config)
        blocks, receipts := make(types.Blocks, n), make([]types.Receipts, n)
        chainreader := &amp;fakeChainReader{config: config}
        genblock := func(i int, parent *types.Block, statedb *state.DB) (*types.Block, types.Receipts) </span><span class="cov0" title="0">{
                b := &amp;BlockGen{
                        i:       i,
                        chain:   blocks,
                        parent:  parent,
                        statedb: statedb,
                        config:  config,
                        factory: factory,
                        engine:  engine,
                }
                b.header = makeHeader(chainreader, parent, statedb, b.engine, factory)

                // Execute any user modifications to the block
                if gen != nil </span><span class="cov0" title="0">{
                        gen(i, b)
                }</span>

                <span class="cov0" title="0">if b.engine != nil </span><span class="cov0" title="0">{
                        // Finalize and seal the block
                        block, _, err := b.engine.Finalize(
                                chainreader, b.header, statedb, b.txs, b.receipts, nil, nil, nil, nil, nil, func() uint64 </span><span class="cov0" title="0">{ return 0 }</span>,
                        )
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }

                        // Write state changes to db
                        <span class="cov0" title="0">root, err := statedb.Commit(config.IsS3(b.header.Epoch()))
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("state write error: %v", err))</span>
                        }
                        <span class="cov0" title="0">if err := statedb.Database().TrieDB().Commit(root, false); err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("trie write error: %v", err))</span>
                        }
                        <span class="cov0" title="0">return block, b.receipts</span>
                }
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                statedb, err := state.New(parent.Root(), state.NewDatabase(db))
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">block, receipt := genblock(i, parent, statedb)
                blocks[i] = block
                receipts[i] = receipt
                parent = block</span>
        }
        <span class="cov0" title="0">return blocks, receipts</span>
}

func makeHeader(chain consensus_engine.ChainReader, parent *types.Block, state *state.DB, engine consensus_engine.Engine, factory blockfactory.Factory) *block.Header <span class="cov0" title="0">{
        var time *big.Int
        if parent.Time() == nil </span><span class="cov0" title="0">{
                time = big.NewInt(10)
        }</span> else<span class="cov0" title="0"> {
                time = new(big.Int).Add(parent.Time(), big.NewInt(10)) // block time is fixed at 10 seconds
        }</span>

        <span class="cov0" title="0">return factory.NewHeader(parent.Epoch()).With().
                Root(state.IntermediateRoot(chain.Config().IsS3(parent.Epoch()))).
                ParentHash(parent.Hash()).
                Coinbase(parent.Coinbase()).
                GasLimit(CalcGasLimit(parent, parent.GasLimit(), parent.GasLimit())).
                Number(new(big.Int).Add(parent.Number(), common.Big1)).
                Time(time).
                Header()</span>
}

type fakeChainReader struct {
        config *params.ChainConfig
}

// Config returns the chain configuration.
func (cr *fakeChainReader) Config() *params.ChainConfig <span class="cov0" title="0">{
        return cr.config
}</span>

func (cr *fakeChainReader) CurrentHeader() *block.Header                            <span class="cov0" title="0">{ return nil }</span>
func (cr *fakeChainReader) ShardID() uint32                                         <span class="cov0" title="0">{ return 0 }</span>
func (cr *fakeChainReader) GetHeaderByNumber(number uint64) *block.Header           <span class="cov0" title="0">{ return nil }</span>
func (cr *fakeChainReader) GetHeaderByHash(hash common.Hash) *block.Header          <span class="cov0" title="0">{ return nil }</span>
func (cr *fakeChainReader) GetHeader(hash common.Hash, number uint64) *block.Header <span class="cov0" title="0">{ return nil }</span>
func (cr *fakeChainReader) GetBlock(hash common.Hash, number uint64) *types.Block   <span class="cov0" title="0">{ return nil }</span>
func (cr *fakeChainReader) ReadShardState(epoch *big.Int) (*shard.State, error)     <span class="cov0" title="0">{ return nil, nil }</span>
func (cr *fakeChainReader) ReadValidatorList() ([]common.Address, error)            <span class="cov0" title="0">{ return nil, nil }</span>
func (cr *fakeChainReader) ValidatorCandidates() []common.Address                   <span class="cov0" title="0">{ return nil }</span>
func (cr *fakeChainReader) SuperCommitteeForNextEpoch(
        beacon consensus_engine.ChainReader, header *block.Header, isVerify bool,
) (*shard.State, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (cr *fakeChainReader) ReadValidatorInformation(
        addr common.Address,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (cr *fakeChainReader) ReadValidatorInformationAtState(
        addr common.Address, state *state.DB,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (cr *fakeChainReader) StateAt(root common.Hash) (*state.DB, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (cr *fakeChainReader) ReadValidatorSnapshot(
        addr common.Address,
) (*staking.ValidatorSnapshot, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (cr *fakeChainReader) ReadValidatorSnapshotAtEpoch(
        epoch *big.Int, addr common.Address,
) (*staking.ValidatorSnapshot, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (cr *fakeChainReader) ReadBlockRewardAccumulator(
        uint64,
) (*big.Int, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (cr *fakeChainReader) CurrentBlock() *types.Block <span class="cov0" title="0">{
        return nil
}</span>

func (cr *fakeChainReader) ValidatorStakingWithDelegation(
        addr common.Address,
) *big.Int <span class="cov0" title="0">{
        return nil
}</span>

func (cr *fakeChainReader) ReadValidatorStats(
        addr common.Address,
) (*staking.ValidatorStats, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (cr *fakeChainReader) ReadCommitSig(blockNum uint64) ([]byte, error) <span class="cov0" title="0">{ return nil, nil }</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "bytes"
        "errors"
        "math/big"
        "sort"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        staking "github.com/harmony-one/harmony/staking"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
)

// ChainContext supports retrieving headers and consensus parameters from the
// current blockchain to be used during transaction processing.
type ChainContext interface {
        // Engine retrieves the chain's consensus engine.
        Engine() consensus_engine.Engine

        // GetHeader returns the hash corresponding to their hash.
        GetHeader(common.Hash, uint64) *block.Header

        // ReadDelegationsByDelegator returns the validators list of a delegator
        ReadDelegationsByDelegator(common.Address) (stakingTypes.DelegationIndexes, error)

        // ReadValidatorSnapshot returns the snapshot of validator at the beginning of current epoch.
        ReadValidatorSnapshot(common.Address) (*stakingTypes.ValidatorSnapshot, error)

        // ReadValidatorList returns the list of all validators
        ReadValidatorList() ([]common.Address, error)

        // Config returns chain config
        Config() *params.ChainConfig

        ShardID() uint32 // this is implemented by blockchain.go already
}

// NewEVMContext creates a new context for use in the EVM.
func NewEVMContext(msg Message, header *block.Header, chain ChainContext, author *common.Address) vm.Context <span class="cov8" title="1">{
        // If we don't have an explicit author (i.e. not mining), extract from the header
        var beneficiary common.Address
        if author == nil </span><span class="cov8" title="1">{
                beneficiary = common.Address{} // Ignore error, we're past header validation
        }</span> else<span class="cov8" title="1"> {
                beneficiary = *author
        }</span>
        <span class="cov8" title="1">vrf := common.Hash{}
        if len(header.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                vrfAndProof := header.Vrf()
                copy(vrf[:], vrfAndProof[:32])
        }</span>
        <span class="cov8" title="1">return vm.Context{
                CanTransfer:        CanTransfer,
                Transfer:           Transfer,
                IsValidator:        IsValidator,
                GetHash:            GetHashFn(header, chain),
                GetVRF:             GetVRFFn(header, chain),
                CreateValidator:    CreateValidatorFn(header, chain),
                EditValidator:      EditValidatorFn(header, chain),
                Delegate:           DelegateFn(header, chain),
                Undelegate:         UndelegateFn(header, chain),
                CollectRewards:     CollectRewardsFn(header, chain),
                MigrateDelegations: MigrateDelegationsFn(header, chain),
                Origin:             msg.From(),
                Coinbase:           beneficiary,
                BlockNumber:        header.Number(),
                EpochNumber:        header.Epoch(),
                VRF:                vrf,
                Time:               header.Time(),
                GasLimit:           header.GasLimit(),
                GasPrice:           new(big.Int).Set(msg.GasPrice()),
                ShardID:            chain.ShardID(),
        }</span>
}

// HandleStakeMsgFn returns a function which accepts
// (1) the chain state database
// (2) the processed staking parameters
// the function can then be called through the EVM context
func CreateValidatorFn(ref *block.Header, chain ChainContext) vm.CreateValidatorFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, createValidator *stakingTypes.CreateValidator) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndCreateValidatorFromMsg(
                        db, chain, ref.Epoch(), ref.Number(), createValidator,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := db.UpdateValidatorWrapper(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">db.SetValidatorFlag(createValidator.ValidatorAddress)
                db.SubBalance(createValidator.ValidatorAddress, createValidator.Amount)
                return nil</span>
        }
}

func EditValidatorFn(ref *block.Header, chain ChainContext) vm.EditValidatorFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, editValidator *stakingTypes.EditValidator) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndEditValidatorFromMsg(
                        db, chain, ref.Epoch(), ref.Number(), editValidator,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return db.UpdateValidatorWrapper(wrapper.Address, wrapper)</span>
        }
}

func DelegateFn(ref *block.Header, chain ChainContext) vm.DelegateFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, delegate *stakingTypes.Delegate) error </span><span class="cov8" title="1">{
                delegations, err := chain.ReadDelegationsByDelegator(delegate.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers, balanceToBeDeducted, fromLockedTokens, err := VerifyAndDelegateFromMsg(
                        db, ref.Epoch(), delegate, delegations, chain.Config())
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, wrapper := range updatedValidatorWrappers </span><span class="cov8" title="1">{
                        if err := db.UpdateValidatorWrapperWithRevert(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">db.SubBalance(delegate.DelegatorAddress, balanceToBeDeducted)

                if len(fromLockedTokens) &gt; 0 </span><span class="cov8" title="1">{
                        sortedKeys := []common.Address{}
                        for key := range fromLockedTokens </span><span class="cov8" title="1">{
                                sortedKeys = append(sortedKeys, key)
                        }</span>
                        <span class="cov8" title="1">sort.SliceStable(sortedKeys, func(i, j int) bool </span><span class="cov0" title="0">{
                                return bytes.Compare(sortedKeys[i][:], sortedKeys[j][:]) &lt; 0
                        }</span>)
                        // Add log if everything is good
                        <span class="cov8" title="1">for _, key := range sortedKeys </span><span class="cov8" title="1">{
                                redelegatedToken, ok := fromLockedTokens[key]
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.New("Key missing for delegation receipt")
                                }</span>
                                <span class="cov8" title="1">encodedRedelegationData := []byte{}
                                addrBytes := key.Bytes()
                                encodedRedelegationData = append(encodedRedelegationData, addrBytes...)
                                encodedRedelegationData = append(encodedRedelegationData, redelegatedToken.Bytes()...)
                                // The data field format is:
                                // [first 20 bytes]: Validator address from which the locked token is used for redelegation.
                                // [rest of the bytes]: the bigInt serialized bytes for the token amount.
                                db.AddLog(&amp;types.Log{
                                        Address:     delegate.DelegatorAddress,
                                        Topics:      []common.Hash{staking.DelegateTopic},
                                        Data:        encodedRedelegationData,
                                        BlockNumber: ref.Number().Uint64(),
                                })</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }
}

func UndelegateFn(ref *block.Header, chain ChainContext) vm.UndelegateFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, undelegate *stakingTypes.Undelegate) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndUndelegateFromMsg(db, ref.Epoch(), undelegate)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return db.UpdateValidatorWrapperWithRevert(wrapper.Address, wrapper)</span>
        }
}

func CollectRewardsFn(ref *block.Header, chain ChainContext) vm.CollectRewardsFunc <span class="cov8" title="1">{
        return func(db vm.StateDB, collectRewards *stakingTypes.CollectRewards) error </span><span class="cov8" title="1">{
                if chain == nil </span><span class="cov0" title="0">{
                        return errors.New("[CollectRewards] No chain context provided")
                }</span>
                <span class="cov8" title="1">delegations, err := chain.ReadDelegationsByDelegator(collectRewards.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers, totalRewards, err := VerifyAndCollectRewardsFromDelegation(
                        db, delegations,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, wrapper := range updatedValidatorWrappers </span><span class="cov8" title="1">{
                        if err := db.UpdateValidatorWrapperWithRevert(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">db.AddBalance(collectRewards.DelegatorAddress, totalRewards)

                // Add log if everything is good
                db.AddLog(&amp;types.Log{
                        Address:     collectRewards.DelegatorAddress,
                        Topics:      []common.Hash{staking.CollectRewardsTopic},
                        Data:        totalRewards.Bytes(),
                        BlockNumber: ref.Number().Uint64(),
                })

                return nil</span>
        }
}

func MigrateDelegationsFn(ref *block.Header, chain ChainContext) vm.MigrateDelegationsFunc <span class="cov8" title="1">{
        return func(db vm.StateDB, migrationMsg *stakingTypes.MigrationMsg) ([]interface{}, error) </span><span class="cov8" title="1">{
                // get existing delegations
                fromDelegations, err := chain.ReadDelegationsByDelegator(migrationMsg.From)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // get list of modified wrappers
                <span class="cov8" title="1">wrappers, delegates, err := VerifyAndMigrateFromMsg(db, migrationMsg, fromDelegations)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // add to state db
                <span class="cov8" title="1">for _, wrapper := range wrappers </span><span class="cov8" title="1">{
                        if err := db.UpdateValidatorWrapperWithRevert(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">return delegates, nil</span>
        }
}

// GetHashFn returns a GetHashFunc which retrieves header hashes by number
func GetHashFn(ref *block.Header, chain ChainContext) func(n uint64) common.Hash <span class="cov8" title="1">{
        var cache map[uint64]common.Hash

        return func(n uint64) common.Hash </span><span class="cov0" title="0">{
                // If there's no hash cache yet, make one
                if cache == nil </span><span class="cov0" title="0">{
                        cache = map[uint64]common.Hash{
                                ref.Number().Uint64() - 1: ref.ParentHash(),
                        }
                }</span>
                // Try to fulfill the request from the cache
                <span class="cov0" title="0">if hash, ok := cache[n]; ok </span><span class="cov0" title="0">{
                        return hash
                }</span>
                // Not cached, iterate the blocks and cache the hashes
                <span class="cov0" title="0">for header := chain.GetHeader(ref.ParentHash(), ref.Number().Uint64()-1); header != nil; header = chain.GetHeader(header.ParentHash(), header.Number().Uint64()-1) </span><span class="cov0" title="0">{
                        cache[header.Number().Uint64()-1] = header.ParentHash()
                        if n == header.Number().Uint64()-1 </span><span class="cov0" title="0">{
                                return header.ParentHash()
                        }</span>
                }
                <span class="cov0" title="0">return common.Hash{}</span>
        }
}

// GetVRFFn returns a GetVRFFn which retrieves header vrf by number
func GetVRFFn(ref *block.Header, chain ChainContext) func(n uint64) common.Hash <span class="cov8" title="1">{
        var cache map[uint64]common.Hash

        return func(n uint64) common.Hash </span><span class="cov0" title="0">{
                // If there's no hash cache yet, make one
                if cache == nil </span><span class="cov0" title="0">{
                        curVRF := common.Hash{}
                        if len(ref.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                                vrfAndProof := ref.Vrf()
                                copy(curVRF[:], vrfAndProof[:32])
                        }</span>

                        <span class="cov0" title="0">cache = map[uint64]common.Hash{
                                ref.Number().Uint64(): curVRF,
                        }</span>
                }
                // Try to fulfill the request from the cache
                <span class="cov0" title="0">if hash, ok := cache[n]; ok </span><span class="cov0" title="0">{
                        return hash
                }</span>
                // Not cached, iterate the blocks and cache the hashes
                <span class="cov0" title="0">for header := chain.GetHeader(ref.ParentHash(), ref.Number().Uint64()-1); header != nil; header = chain.GetHeader(header.ParentHash(), header.Number().Uint64()-1) </span><span class="cov0" title="0">{

                        curVRF := common.Hash{}
                        if len(header.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                                vrfAndProof := header.Vrf()
                                copy(curVRF[:], vrfAndProof[:32])
                        }</span>

                        <span class="cov0" title="0">cache[header.Number().Uint64()] = curVRF

                        if n == header.Number().Uint64() </span><span class="cov0" title="0">{
                                return curVRF
                        }</span>
                }
                <span class="cov0" title="0">return common.Hash{}</span>
        }
}

// CanTransfer checks whether there are enough funds in the address' account to make a transfer.
// This does not take the necessary gas in to account to make the transfer valid.
func CanTransfer(db vm.StateDB, addr common.Address, amount *big.Int) bool <span class="cov8" title="1">{
        return db.GetBalance(addr).Cmp(amount) &gt;= 0
}</span>

// IsValidator determines whether it is a validator address or not
func IsValidator(db vm.StateDB, addr common.Address) bool <span class="cov8" title="1">{
        return db.IsValidator(addr)
}</span>

// Transfer subtracts amount from sender and adds amount to recipient using the given Db
func Transfer(db vm.StateDB, sender, recipient common.Address, amount *big.Int, txType types.TransactionType) <span class="cov8" title="1">{
        if txType == types.SameShardTx || txType == types.SubtractionOnly </span><span class="cov8" title="1">{
                db.SubBalance(sender, amount)
        }</span>
        <span class="cov8" title="1">if txType == types.SameShardTx </span><span class="cov8" title="1">{
                db.AddBalance(recipient, amount)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "bytes"
        "math/big"
        "sort"

        "github.com/harmony-one/harmony/block"

        nodeconfig "github.com/harmony-one/harmony/internal/configs/node"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/consensus/reward"
        "github.com/harmony-one/harmony/core/rawdb"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

// CommitOffChainData write off chain data of a block onto db writer.
func (bc *BlockChain) CommitOffChainData(
        batch rawdb.DatabaseWriter,
        block *types.Block,
        receipts []*types.Receipt,
        cxReceipts []*types.CXReceipt,
        stakeMsgs []staking.StakeMsg,
        payout reward.Reader,
        state *state.DB,
) (status WriteStatus, err error) <span class="cov8" title="1">{
        // Write receipts of the block
        if err := rawdb.WriteReceipts(batch, block.Hash(), block.NumberU64(), receipts); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>
        <span class="cov8" title="1">isBeaconChain := bc.CurrentHeader().ShardID() == shard.BeaconChainShardID
        isStaking := bc.chainConfig.IsStaking(block.Epoch())
        isPreStaking := bc.chainConfig.IsPreStaking(block.Epoch())
        header := block.Header()
        isNewEpoch := block.IsLastBlockInEpoch()
        // Cross-shard txns
        epoch := block.Header().Epoch()
        if bc.chainConfig.HasCrossTxFields(block.Epoch()) </span><span class="cov8" title="1">{
                shardingConfig := shard.Schedule.InstanceForEpoch(epoch)
                shardNum := int(shardingConfig.NumShards())
                for i := 0; i &lt; shardNum; i++ </span><span class="cov8" title="1">{
                        if i == int(block.ShardID()) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">shardReceipts := types.CXReceipts(cxReceipts).GetToShardReceipts(uint32(i))
                        if err := rawdb.WriteCXReceipts(
                                batch, uint32(i), block.NumberU64(), block.Hash(), shardReceipts,
                        ); err != nil </span><span class="cov0" title="0">{
                                utils.Logger().Error().Err(err).
                                        Interface("shardReceipts", shardReceipts).
                                        Int("toShardID", i).
                                        Msg("WriteCXReceipts cannot write into database")
                                return NonStatTy, err
                        }</span>
                }
                // Mark incomingReceipts in the block as spent
                <span class="cov8" title="1">if err := bc.WriteCXReceiptsProofSpent(batch, block.IncomingReceipts()); err != nil </span><span class="cov0" title="0">{
                        return NonStatTy, err
                }</span>
        }

        // VRF + VDF
        // check non zero VRF field in header and add to local db
        // if len(block.Vrf()) &gt; 0 {
        //        vrfBlockNumbers, _ := bc.ReadEpochVrfBlockNums(block.Header().Epoch())
        //        if (len(vrfBlockNumbers) &gt; 0) &amp;&amp; (vrfBlockNumbers[len(vrfBlockNumbers)-1] == block.NumberU64()) {
        //                utils.Logger().Error().
        //                        Str("number", block.Number().String()).
        //                        Str("epoch", block.Header().Epoch().String()).
        //                        Msg("VRF block number is already in local db")
        //        } else {
        //                vrfBlockNumbers = append(vrfBlockNumbers, block.NumberU64())
        //                err = bc.WriteEpochVrfBlockNums(block.Header().Epoch(), vrfBlockNumbers)
        //                if err != nil {
        //                        utils.Logger().Error().
        //                                Str("number", block.Number().String()).
        //                                Str("epoch", block.Header().Epoch().String()).
        //                                Msg("failed to write VRF block number to local db")
        //                        return NonStatTy, err
        //                }
        //        }
        //}
        //
        ////check non zero Vdf in header and add to local db
        //if len(block.Vdf()) &gt; 0 {
        //        err = bc.WriteEpochVdfBlockNum(block.Header().Epoch(), block.Number())
        //        if err != nil {
        //                utils.Logger().Error().
        //                        Str("number", block.Number().String()).
        //                        Str("epoch", block.Header().Epoch().String()).
        //                        Msg("failed to write VDF block number to local db")
        //                return NonStatTy, err
        //        }
        //}

        <span class="cov8" title="1">nextBlockEpoch, err := bc.getNextBlockEpoch(header)
        if err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>

        // Shard State and Validator Update
        <span class="cov8" title="1">if isNewEpoch </span><span class="cov0" title="0">{
                // Write shard state for the new epoch
                _, err := bc.WriteShardStateBytes(batch, nextBlockEpoch, header.ShardState())
                if err != nil </span><span class="cov0" title="0">{
                        header.Logger(utils.Logger()).Warn().Err(err).Msg("cannot store shard state")
                        return NonStatTy, err
                }</span>
        }

        // Do bookkeeping for new staking txns
        <span class="cov8" title="1">newVals, err := bc.UpdateStakingMetaData(
                batch, block, stakeMsgs, state, epoch, nextBlockEpoch,
        )
        if err != nil </span><span class="cov0" title="0">{
                utils.Logger().Err(err).Msg("UpdateStakingMetaData failed")
                return NonStatTy, err
        }</span>

        // Snapshot for all validators for new epoch at the second to last block
        // This snapshot of the state is consistent with the state used for election
        <span class="cov8" title="1">if isBeaconChain &amp;&amp; shard.Schedule.IsLastBlock(header.Number().Uint64()+1) </span><span class="cov0" title="0">{
                // Update snapshots for all validators
                // Beacon chain always snapshot for the next epoch as cur_epoch + 1
                // as beacon chain won't have gap in epochs.
                newEpoch := big.NewInt(0).Add(header.Epoch(), big.NewInt(1))
                if err := bc.UpdateValidatorSnapshots(batch, newEpoch, state, newVals); err != nil </span><span class="cov0" title="0">{
                        return NonStatTy, err
                }</span>
        }

        // Writing beacon chain cross links
        <span class="cov8" title="1">if isBeaconChain &amp;&amp;
                bc.chainConfig.IsCrossLink(block.Epoch()) &amp;&amp;
                len(header.CrossLinks()) &gt; 0 </span><span class="cov0" title="0">{
                crossLinks := &amp;types.CrossLinks{}
                if err := rlp.DecodeBytes(
                        header.CrossLinks(), crossLinks,
                ); err != nil </span><span class="cov0" title="0">{
                        header.Logger(utils.Logger()).Err(err).
                                Msg("[insertChain/crosslinks] cannot parse cross links")
                        return NonStatTy, err
                }</span>
                <span class="cov0" title="0">if !crossLinks.IsSorted() </span><span class="cov0" title="0">{
                        header.Logger(utils.Logger()).Err(err).
                                Msg("[insertChain/crosslinks] cross links are not sorted")
                        return NonStatTy, errors.New("proposed cross links are not sorted")
                }</span>
                <span class="cov0" title="0">for _, crossLink := range *crossLinks </span><span class="cov0" title="0">{
                        // Process crosslink
                        if err := bc.WriteCrossLinks(
                                batch, types.CrossLinks{crossLink},
                        ); err == nil </span><span class="cov0" title="0">{
                                utils.Logger().Info().
                                        Uint64("blockNum", crossLink.BlockNum()).
                                        Uint32("shardID", crossLink.ShardID()).
                                        Msg("[insertChain/crosslinks] Cross Link Added to Beaconchain")
                        }</span>

                        <span class="cov0" title="0">cl0, _ := bc.ReadShardLastCrossLink(crossLink.ShardID())
                        if cl0 == nil </span><span class="cov0" title="0">{
                                rawdb.WriteShardLastCrossLink(batch, crossLink.ShardID(), crossLink.Serialize())
                        }</span>
                }

                // clean/update local database cache after crosslink inserted into blockchain
                <span class="cov0" title="0">num, err := bc.DeleteFromPendingCrossLinks(*crossLinks)
                if err != nil &amp;&amp; nodeconfig.GetDefaultConfig().ShardID == shard.BeaconChainShardID </span><span class="cov0" title="0">{
                        // Only beacon chain worries about this
                        const msg = "DeleteFromPendingCrossLinks, crosslinks in header %d,  pending crosslinks: %d, problem: %+v"
                        utils.Logger().Debug().Msgf(msg, len(*crossLinks), num, err)
                }</span>
                <span class="cov0" title="0">const msg = "DeleteFromPendingCrossLinks, crosslinks in header %d,  pending crosslinks: %d"
                utils.Logger().
                        Debug().
                        Msgf(msg, len(*crossLinks), num)
                utils.Logger().Debug().Msgf(msg, len(*crossLinks), num)</span>
        }

        <span class="cov8" title="1">if isBeaconChain &amp;&amp; bc.Config().IsCrossLink(bc.CurrentBlock().Epoch()) </span><span class="cov0" title="0">{
                // Roll up latest crosslinks
                for i, c := uint32(0), shard.Schedule.InstanceForEpoch(
                        epoch,
                ).NumShards(); i &lt; c; i++ </span><span class="cov0" title="0">{
                        bc.LastContinuousCrossLink(batch, i)
                }</span>
        }

        // BELOW ARE NON-MISSION-CRITICAL COMMITS

        // Update voting power of validators for all shards
        <span class="cov8" title="1">tempValidatorStats := map[common.Address]*staking.ValidatorStats{}
        if isNewEpoch &amp;&amp; isBeaconChain </span><span class="cov0" title="0">{
                currentSuperCommittee, _ := bc.ReadShardState(bc.CurrentHeader().Epoch())
                if shardState, err := shard.DecodeWrapper(
                        header.ShardState(),
                ); err == nil </span><span class="cov0" title="0">{
                        if stats, err := bc.UpdateValidatorVotingPower(
                                batch, block, shardState, currentSuperCommittee, state,
                        ); err != nil </span><span class="cov0" title="0">{
                                utils.Logger().
                                        Err(err).
                                        Msg("[UpdateValidatorVotingPower] Failed to update voting power")
                        }</span> else<span class="cov0" title="0"> {
                                tempValidatorStats = stats
                        }</span>
                } else<span class="cov0" title="0"> {
                        utils.Logger().
                                Err(err).
                                Msg("[UpdateValidatorVotingPower] Failed to decode shard state")
                }</span>
        }

        // Update block reward accumulator and slashes
        <span class="cov8" title="1">if isBeaconChain </span><span class="cov8" title="1">{
                if isStaking </span><span class="cov0" title="0">{
                        roundResult := payout.ReadRoundResult()
                        if err := bc.UpdateBlockRewardAccumulator(
                                batch, roundResult.Total, block.Number().Uint64(),
                        ); err != nil </span><span class="cov0" title="0">{
                                return NonStatTy, err
                        }</span>
                        <span class="cov0" title="0">for _, paid := range roundResult.Payouts </span><span class="cov0" title="0">{
                                stats, ok := tempValidatorStats[paid.Addr]
                                if !ok </span><span class="cov0" title="0">{
                                        stats, err = bc.ReadValidatorStats(paid.Addr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                utils.Logger().Info().Err(err).
                                                        Str("addr", paid.Addr.Hex()).
                                                        Str("bls-earning-key", paid.EarningKey.Hex()).
                                                        Msg("could not read validator stats to update for earning per key")
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">tempValidatorStats[paid.Addr] = stats</span>
                                }
                                <span class="cov0" title="0">for j := range stats.MetricsPerShard </span><span class="cov0" title="0">{
                                        if stats.MetricsPerShard[j].Vote.Identity == paid.EarningKey </span><span class="cov0" title="0">{
                                                stats.MetricsPerShard[j].Earned.Add(
                                                        stats.MetricsPerShard[j].Earned,
                                                        paid.NewlyEarned,
                                                )
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">bc.writeValidatorStats(tempValidatorStats, batch)

                        records := slash.Records{}
                        if s := header.Slashes(); len(s) &gt; 0 </span><span class="cov0" title="0">{
                                if err := rlp.DecodeBytes(s, &amp;records); err != nil </span><span class="cov0" title="0">{
                                        utils.Logger().Debug().Err(err).Msg("could not decode slashes in header")
                                }</span>
                                <span class="cov0" title="0">if err := bc.DeleteFromPendingSlashingCandidates(records); err != nil </span><span class="cov0" title="0">{
                                        utils.Logger().Debug().Err(err).Msg("could not deleting pending slashes")
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        if isNewEpoch &amp;&amp; isPreStaking </span><span class="cov0" title="0">{
                                // if prestaking and last block, write out the validator stats
                                // so that it is available for the staking epoch
                                bc.writeValidatorStats(tempValidatorStats, batch)
                        }</span>
                        // block reward never accumulate before staking
                        <span class="cov8" title="1">bc.WriteBlockRewardAccumulator(batch, common.Big0, block.Number().Uint64())</span>
                }
        }

        <span class="cov8" title="1">return CanonStatTy, nil</span>
}

func (bc *BlockChain) writeValidatorStats(
        tempValidatorStats map[common.Address]*staking.ValidatorStats,
        batch rawdb.DatabaseWriter,
) <span class="cov0" title="0">{
        type t struct {
                addr  common.Address
                stats *staking.ValidatorStats
        }

        sortedStats, i := make([]t, len(tempValidatorStats)), 0
        for key := range tempValidatorStats </span><span class="cov0" title="0">{
                sortedStats[i] = t{key, tempValidatorStats[key]}
                i++
        }</span>

        <span class="cov0" title="0">sort.SliceStable(
                sortedStats,
                func(i, j int) bool </span><span class="cov0" title="0">{
                        return bytes.Compare(
                                sortedStats[i].addr[:], sortedStats[j].addr[:],
                        ) == -1
                }</span>,
        )
        <span class="cov0" title="0">for _, stat := range sortedStats </span><span class="cov0" title="0">{
                if err := rawdb.WriteValidatorStats(
                        batch, stat.addr, stat.stats,
                ); err != nil </span><span class="cov0" title="0">{
                        utils.Logger().Info().Err(err).
                                Str("validator address", stat.addr.Hex()).
                                Msg("could not update stats for validator")
                }</span>
        }
}

func (bc *BlockChain) getNextBlockEpoch(header *block.Header) (*big.Int, error) <span class="cov8" title="1">{
        nextBlockEpoch := header.Epoch()
        if header.IsLastBlockInEpoch() </span><span class="cov0" title="0">{
                nextBlockEpoch = new(big.Int).Add(header.Epoch(), common.Big1)
                decodeShardState, err := shard.DecodeWrapper(header.ShardState())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if decodeShardState.Epoch != nil &amp;&amp; bc.chainConfig.IsStaking(decodeShardState.Epoch) </span><span class="cov0" title="0">{
                        // After staking, the epoch will be decided by the epoch in the shard state.
                        nextBlockEpoch = new(big.Int).Set(decodeShardState.Epoch)
                }</span>
        }
        <span class="cov8" title="1">return nextBlockEpoch, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package core

import (
        "bytes"
        "fmt"
        "math/big"

        "github.com/harmony-one/harmony/staking/availability"

        "github.com/harmony-one/harmony/internal/params"

        "github.com/harmony-one/harmony/crypto/bls"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/common/denominations"
        "github.com/harmony-one/harmony/core/vm"
        common2 "github.com/harmony-one/harmony/internal/common"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/staking/effective"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var (
        errStateDBIsMissing    = errors.New("no stateDB was provided")
        errChainContextMissing = errors.New("no chain context was provided")
        errEpochMissing        = errors.New("no epoch was provided")
        errBlockNumMissing     = errors.New("no block number was provided")
)

func checkDuplicateFields(
        bc ChainContext, state vm.StateDB,
        validator common.Address, identity string, blsKeys []bls.SerializedPublicKey,
) error <span class="cov8" title="1">{
        addrs, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">checkIdentity := identity != ""
        checkBlsKeys := len(blsKeys) != 0

        blsKeyMap := map[bls.SerializedPublicKey]struct{}{}
        for _, key := range blsKeys </span><span class="cov8" title="1">{
                blsKeyMap[key] = struct{}{}
        }</span>

        <span class="cov8" title="1">for _, addr := range addrs </span><span class="cov8" title="1">{
                if !bytes.Equal(validator.Bytes(), addr.Bytes()) </span><span class="cov8" title="1">{
                        wrapper, err := state.ValidatorWrapper(addr, true, false)

                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if checkIdentity &amp;&amp; wrapper.Identity == identity </span><span class="cov8" title="1">{
                                return errors.Wrapf(errDupIdentity, "duplicate identity %s", identity)
                        }</span>
                        <span class="cov8" title="1">if checkBlsKeys </span><span class="cov8" title="1">{
                                for _, existingKey := range wrapper.SlotPubKeys </span><span class="cov8" title="1">{
                                        if _, ok := blsKeyMap[existingKey]; ok </span><span class="cov8" title="1">{
                                                return errors.Wrapf(errDupBlsKey, "duplicate bls key %x", existingKey)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// TODO: add unit tests to check staking msg verification

// VerifyAndCreateValidatorFromMsg verifies the create validator message using
// the stateDB, epoch, &amp; blocknumber and returns the validatorWrapper created
// in the process.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndCreateValidatorFromMsg(
        stateDB vm.StateDB, chainContext ChainContext, epoch *big.Int, blockNum *big.Int, msg *staking.CreateValidator,
) (*staking.ValidatorWrapper, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if chainContext == nil </span><span class="cov8" title="1">{
                return nil, errChainContextMissing
        }</span>
        <span class="cov8" title="1">if epoch == nil </span><span class="cov8" title="1">{
                return nil, errEpochMissing
        }</span>
        <span class="cov8" title="1">if blockNum == nil </span><span class="cov8" title="1">{
                return nil, errBlockNumMissing
        }</span>
        <span class="cov8" title="1">if msg.Amount.Sign() == -1 </span><span class="cov8" title="1">{
                return nil, errNegativeAmount
        }</span>
        <span class="cov8" title="1">if stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, errors.Wrapf(
                        errValidatorExist, common2.MustAddressToBech32(msg.ValidatorAddress),
                )
        }</span>
        <span class="cov8" title="1">if err := checkDuplicateFields(
                chainContext, stateDB,
                msg.ValidatorAddress,
                msg.Identity,
                msg.SlotPubKeys); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !CanTransfer(stateDB, msg.ValidatorAddress, msg.Amount) </span><span class="cov8" title="1">{
                return nil, errInsufficientBalanceForStake
        }</span>
        <span class="cov8" title="1">v, err := staking.CreateValidatorFromNewMsg(msg, blockNum, epoch)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wrapper := &amp;staking.ValidatorWrapper{}
        wrapper.Validator = *v
        wrapper.Delegations = []staking.Delegation{
                staking.NewDelegation(v.Address, msg.Amount),
        }
        wrapper.Counters.NumBlocksSigned = big.NewInt(0)
        wrapper.Counters.NumBlocksToSign = big.NewInt(0)
        wrapper.BlockReward = big.NewInt(0)
        if err := wrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return wrapper, nil</span>
}

// VerifyAndEditValidatorFromMsg verifies the edit validator message using
// the stateDB, chainContext and returns the edited validatorWrapper.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndEditValidatorFromMsg(
        stateDB vm.StateDB, chainContext ChainContext,
        epoch, blockNum *big.Int, msg *staking.EditValidator,
) (*staking.ValidatorWrapper, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if chainContext == nil </span><span class="cov8" title="1">{
                return nil, errChainContextMissing
        }</span>
        <span class="cov8" title="1">if blockNum == nil </span><span class="cov8" title="1">{
                return nil, errBlockNumMissing
        }</span>
        <span class="cov8" title="1">if !stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, errValidatorNotExist
        }</span>
        <span class="cov8" title="1">newBlsKeys := []bls.SerializedPublicKey{}
        if msg.SlotKeyToAdd != nil </span><span class="cov8" title="1">{
                newBlsKeys = append(newBlsKeys, *msg.SlotKeyToAdd)
        }</span>
        <span class="cov8" title="1">if err := checkDuplicateFields(
                chainContext, stateDB,
                msg.ValidatorAddress,
                msg.Identity,
                newBlsKeys); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // request a copy, but delegations are not being changed so do not deep copy them
        <span class="cov8" title="1">wrapper, err := stateDB.ValidatorWrapper(msg.ValidatorAddress, false, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := staking.UpdateValidatorFromEditMsg(&amp;wrapper.Validator, msg, epoch); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">newRate := wrapper.Validator.Rate
        if newRate.GT(wrapper.Validator.MaxRate) </span><span class="cov8" title="1">{
                return nil, errCommissionRateChangeTooHigh
        }</span>

        <span class="cov8" title="1">if chainContext.Config().IsMinCommissionRate(epoch) &amp;&amp; newRate.LT(availability.MinCommissionRate) </span><span class="cov8" title="1">{
                firstEpoch := stateDB.GetValidatorFirstElectionEpoch(msg.ValidatorAddress)
                promoPeriod := chainContext.Config().MinCommissionPromoPeriod.Int64()
                if firstEpoch.Uint64() != 0 &amp;&amp; big.NewInt(0).Sub(epoch, firstEpoch).Int64() &gt;= promoPeriod </span><span class="cov8" title="1">{
                        return nil, errCommissionRateChangeTooLow
                }</span>
        }

        <span class="cov8" title="1">snapshotValidator, err := chainContext.ReadValidatorSnapshot(wrapper.Address)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.WithMessage(err, "validator snapshot not found.")
        }</span>
        <span class="cov8" title="1">rateAtBeginningOfEpoch := snapshotValidator.Validator.Rate

        if rateAtBeginningOfEpoch.IsNil() ||
                (!newRate.IsNil() &amp;&amp; !rateAtBeginningOfEpoch.Equal(newRate)) </span><span class="cov8" title="1">{
                wrapper.Validator.UpdateHeight = blockNum
        }</span>

        <span class="cov8" title="1">if newRate.Sub(rateAtBeginningOfEpoch).Abs().GT(
                wrapper.Validator.MaxChangeRate,
        ) </span><span class="cov8" title="1">{
                return nil, errCommissionRateChangeTooFast
        }</span>
        <span class="cov8" title="1">if err := wrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return wrapper, nil</span>
}

const oneThousand = 1000
const oneHundred = 100

var (
        oneAsBigInt             = big.NewInt(denominations.One)
        minimumDelegation       = new(big.Int).Mul(oneAsBigInt, big.NewInt(oneThousand))
        minimumDelegationV2     = new(big.Int).Mul(oneAsBigInt, big.NewInt(oneHundred))
        errDelegationTooSmall   = errors.New("minimum delegation amount for a delegator has to be greater than or equal to 1000 ONE")
        errDelegationTooSmallV2 = errors.New("minimum delegation amount for a delegator has to be greater than or equal to 100 ONE")
)

// VerifyAndDelegateFromMsg verifies the delegate message using the stateDB
// and returns the balance to be deducted by the delegator as well as the
// validatorWrapper with the delegation applied to it.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndDelegateFromMsg(
        stateDB vm.StateDB, epoch *big.Int, msg *staking.Delegate, delegations []staking.DelegationIndex, chainConfig *params.ChainConfig,
) ([]*staking.ValidatorWrapper, *big.Int, map[common.Address]*big.Int, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, nil, nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if !stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, nil, nil, errValidatorNotExist
        }</span>
        <span class="cov8" title="1">if msg.Amount.Sign() == -1 </span><span class="cov8" title="1">{
                return nil, nil, nil, errNegativeAmount
        }</span>
        <span class="cov8" title="1">if msg.Amount.Cmp(minimumDelegation) &lt; 0 </span><span class="cov8" title="1">{
                if chainConfig.IsMinDelegation100(epoch) </span><span class="cov8" title="1">{
                        if msg.Amount.Cmp(minimumDelegationV2) &lt; 0 </span><span class="cov8" title="1">{
                                return nil, nil, nil, errDelegationTooSmallV2
                        }</span>
                } else<span class="cov8" title="1"> {
                        return nil, nil, nil, errDelegationTooSmall
                }</span>
        }

        <span class="cov8" title="1">updatedValidatorWrappers := []*staking.ValidatorWrapper{}
        delegateBalance := big.NewInt(0).Set(msg.Amount)
        fromLockedTokens := map[common.Address]*big.Int{}

        var delegateeWrapper *staking.ValidatorWrapper
        if chainConfig.IsRedelegation(epoch) </span><span class="cov8" title="1">{
                // Check if we can use tokens in undelegation to delegate (redelegate)
                for i := range delegations </span><span class="cov8" title="1">{
                        delegationIndex := &amp;delegations[i]
                        // request a copy, and since delegations will be changed, copy them too
                        wrapper, err := stateDB.ValidatorWrapper(delegationIndex.ValidatorAddress, false, true)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, err
                        }</span>
                        <span class="cov8" title="1">if uint64(len(wrapper.Delegations)) &lt;= delegationIndex.Index </span><span class="cov8" title="1">{
                                utils.Logger().Warn().
                                        Str("validator", delegationIndex.ValidatorAddress.String()).
                                        Uint64("delegation index", delegationIndex.Index).
                                        Int("delegations length", len(wrapper.Delegations)).
                                        Msg("Delegation index out of bound")
                                return nil, nil, nil, errors.New("Delegation index out of bound")
                        }</span>

                        <span class="cov8" title="1">delegation := &amp;wrapper.Delegations[delegationIndex.Index]

                        startBalance := big.NewInt(0).Set(delegateBalance)
                        // Start from the oldest undelegated tokens
                        curIndex := 0
                        for ; curIndex &lt; len(delegation.Undelegations); curIndex++ </span><span class="cov8" title="1">{
                                if delegation.Undelegations[curIndex].Epoch.Cmp(epoch) &gt;= 0 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">if delegation.Undelegations[curIndex].Amount.Cmp(delegateBalance) &lt;= 0 </span><span class="cov8" title="1">{
                                        delegateBalance.Sub(delegateBalance, delegation.Undelegations[curIndex].Amount)
                                }</span> else<span class="cov8" title="1"> {
                                        delegation.Undelegations[curIndex].Amount.Sub(
                                                delegation.Undelegations[curIndex].Amount, delegateBalance,
                                        )
                                        delegateBalance = big.NewInt(0)
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if startBalance.Cmp(delegateBalance) &gt; 0 </span><span class="cov8" title="1">{
                                // Used undelegated token for redelegation
                                delegation.Undelegations = delegation.Undelegations[curIndex:]
                                if err := wrapper.SanityCheck(); err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, nil, err
                                }</span>

                                <span class="cov8" title="1">if bytes.Equal(delegationIndex.ValidatorAddress[:], msg.ValidatorAddress[:]) </span><span class="cov8" title="1">{
                                        delegateeWrapper = wrapper
                                }</span>
                                <span class="cov8" title="1">updatedValidatorWrappers = append(updatedValidatorWrappers, wrapper)
                                fromLockedTokens[delegationIndex.ValidatorAddress] = big.NewInt(0).Sub(startBalance, delegateBalance)</span>
                        }
                }
        }

        <span class="cov8" title="1">if delegateeWrapper == nil </span><span class="cov8" title="1">{
                var err error
                // request a copy, and since delegations will be changed, copy them too
                delegateeWrapper, err = stateDB.ValidatorWrapper(msg.ValidatorAddress, false, true)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, nil, err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers = append(updatedValidatorWrappers, delegateeWrapper)</span>
        }

        // Add to existing delegation if any
        <span class="cov8" title="1">found := false
        for i := range delegateeWrapper.Delegations </span><span class="cov8" title="1">{
                delegation := &amp;delegateeWrapper.Delegations[i]
                if bytes.Equal(delegation.DelegatorAddress.Bytes(), msg.DelegatorAddress.Bytes()) </span><span class="cov8" title="1">{
                        delegation.Amount.Add(delegation.Amount, msg.Amount)
                        if err := delegateeWrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                                return nil, nil, nil, err
                        }</span>
                        <span class="cov8" title="1">found = true</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                // Add new delegation
                delegateeWrapper.Delegations = append(
                        delegateeWrapper.Delegations, staking.NewDelegation(
                                msg.DelegatorAddress, msg.Amount,
                        ),
                )
                if err := delegateeWrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                        return nil, nil, nil, err
                }</span>
        }

        <span class="cov8" title="1">if delegateBalance.Cmp(big.NewInt(0)) == 0 </span><span class="cov8" title="1">{
                // delegation fully from undelegated tokens, no need to deduct from balance.
                return updatedValidatorWrappers, big.NewInt(0), fromLockedTokens, nil
        }</span>

        // Still need to deduct tokens from balance for delegation
        // Check if there is enough liquid token to delegate
        <span class="cov8" title="1">if !CanTransfer(stateDB, msg.DelegatorAddress, delegateBalance) </span><span class="cov8" title="1">{
                return nil, nil, nil, errors.Wrapf(
                        errInsufficientBalanceForStake, "totalRedelegatable: %v, balance: %v; trying to stake %v",
                        big.NewInt(0).Sub(msg.Amount, delegateBalance), stateDB.GetBalance(msg.DelegatorAddress), msg.Amount)
        }</span>

        <span class="cov8" title="1">return updatedValidatorWrappers, delegateBalance, fromLockedTokens, nil</span>
}

// VerifyAndUndelegateFromMsg verifies the undelegate validator message
// using the stateDB &amp; chainContext and returns the edited validatorWrapper
// with the undelegation applied to it.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndUndelegateFromMsg(
        stateDB vm.StateDB, epoch *big.Int, msg *staking.Undelegate,
) (*staking.ValidatorWrapper, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if epoch == nil </span><span class="cov8" title="1">{
                return nil, errEpochMissing
        }</span>

        <span class="cov8" title="1">if msg.Amount.Sign() == -1 </span><span class="cov8" title="1">{
                return nil, errNegativeAmount
        }</span>

        <span class="cov8" title="1">if !stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, errValidatorNotExist
        }</span>

        <span class="cov8" title="1">wrapper, err := stateDB.ValidatorWrapper(msg.ValidatorAddress, false, true)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for i := range wrapper.Delegations </span><span class="cov8" title="1">{
                delegation := &amp;wrapper.Delegations[i]
                if bytes.Equal(delegation.DelegatorAddress.Bytes(), msg.DelegatorAddress.Bytes()) </span><span class="cov8" title="1">{
                        if err := delegation.Undelegate(epoch, msg.Amount); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if err := wrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                                // allow self delegation to go below min self delegation
                                // but set the status to inactive
                                if errors.Cause(err) == staking.ErrInvalidSelfDelegation </span><span class="cov8" title="1">{
                                        wrapper.Status = effective.Inactive
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, err
                                }</span>
                        }
                        <span class="cov8" title="1">return wrapper, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, errNoDelegationToUndelegate</span>
}

// VerifyAndMigrateFromMsg verifies and transfers all delegations of
// msg.From to msg.To. Returns all modified validator wrappers and delegate msgs
// for metadata
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndMigrateFromMsg(
        stateDB vm.StateDB,
        msg *staking.MigrationMsg,
        fromDelegations []staking.DelegationIndex,
) ([]*staking.ValidatorWrapper,
        []interface{},
        error) <span class="cov8" title="1">{
        if len(fromDelegations) == 0 </span><span class="cov8" title="1">{
                // we are already done
                return nil, nil, nil
        }</span>
        <span class="cov8" title="1">if bytes.Equal(msg.From.Bytes(), msg.To.Bytes()) </span><span class="cov0" title="0">{
                // we are already done
                return nil, nil, nil
        }</span>
        <span class="cov8" title="1">modifiedWrappers := make([]*staking.ValidatorWrapper, 0)
        stakeMsgs := make([]interface{}, 0)
        // iterate over all delegationIndexes by `From`
        for i := range fromDelegations </span><span class="cov8" title="1">{
                delegationIndex := &amp;fromDelegations[i]
                // find the wrapper for each delegationIndex
                // request a copy, and since delegations will be changed, copy them too
                wrapper, err := stateDB.ValidatorWrapper(delegationIndex.ValidatorAddress, false, true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if uint64(len(wrapper.Delegations)) &lt;= delegationIndex.Index </span><span class="cov0" title="0">{
                        utils.Logger().Warn().
                                Str("validator", delegationIndex.ValidatorAddress.String()).
                                Uint64("delegation index", delegationIndex.Index).
                                Int("delegations length", len(wrapper.Delegations)).
                                Msg("Delegation index out of bound")
                        return nil, nil, errors.New("Delegation index out of bound")
                }</span>
                // and then find matching delegation to remove from wrapper
                <span class="cov8" title="1">foundDelegation := &amp;wrapper.Delegations[delegationIndex.Index] // note: pointer
                if !bytes.Equal(foundDelegation.DelegatorAddress.Bytes(), msg.From.Bytes()) </span><span class="cov0" title="0">{
                        return nil, nil, errors.New(fmt.Sprintf("Expected %s but got %s",
                                msg.From.Hex(),
                                foundDelegation.DelegatorAddress.Hex()))
                }</span>
                // Skip delegations with zero amount and empty undelegation
                <span class="cov8" title="1">if foundDelegation.Amount.Cmp(common.Big0) == 0 &amp;&amp; len(foundDelegation.Undelegations) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">delegationAmountToMigrate := big.NewInt(0).Add(foundDelegation.Amount, big.NewInt(0))
                undelegationsToMigrate := foundDelegation.Undelegations
                // when undelegating we don't remove, just set the amount to zero
                // to be coherent, do the same thing here (effective on wrapper since pointer)
                foundDelegation.Amount = big.NewInt(0)
                foundDelegation.Undelegations = make([]staking.Undelegation, 0)
                // find `To` and give it to them
                totalAmount := big.NewInt(0)
                found := false
                for i := range wrapper.Delegations </span><span class="cov8" title="1">{
                        delegation := &amp;wrapper.Delegations[i]
                        if bytes.Equal(delegation.DelegatorAddress.Bytes(), msg.To.Bytes()) </span><span class="cov8" title="1">{
                                found = true
                                // add to existing delegation
                                totalAmount = delegation.Amount.Add(delegation.Amount, delegationAmountToMigrate)
                                // and the undelegation
                                delegation.Undelegations = append(delegation.Undelegations,
                                        undelegationsToMigrate...)
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{ // add the delegation
                        wrapper.Delegations = append(
                                wrapper.Delegations, staking.NewDelegation(
                                        msg.To, delegationAmountToMigrate,
                                ),
                        )
                        totalAmount = delegationAmountToMigrate
                }</span>
                <span class="cov8" title="1">if err := wrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                        // allow self delegation to go below min self delegation
                        // but set the status to inactive
                        if errors.Cause(err) == staking.ErrInvalidSelfDelegation </span><span class="cov8" title="1">{
                                wrapper.Status = effective.Inactive
                        }</span> else<span class="cov0" title="0"> {
                                return nil, nil, err
                        }</span>
                }
                <span class="cov8" title="1">modifiedWrappers = append(modifiedWrappers, wrapper)
                delegate := &amp;staking.Delegate{
                        ValidatorAddress: wrapper.Address,
                        DelegatorAddress: msg.To,
                        Amount:           totalAmount,
                }
                stakeMsgs = append(stakeMsgs, delegate)</span>
        }
        <span class="cov8" title="1">return modifiedWrappers, stakeMsgs, nil</span>
}

// VerifyAndCollectRewardsFromDelegation verifies and collects rewards
// from the given delegation slice using the stateDB. It returns all of the
// edited validatorWrappers and the sum total of the rewards.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndCollectRewardsFromDelegation(
        stateDB vm.StateDB, delegations []staking.DelegationIndex,
) ([]*staking.ValidatorWrapper, *big.Int, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">updatedValidatorWrappers := []*staking.ValidatorWrapper{}
        totalRewards := big.NewInt(0)
        for i := range delegations </span><span class="cov8" title="1">{
                delegation := &amp;delegations[i]
                // request a copy, and since delegations will be changed (.Reward.Set), copy them too
                wrapper, err := stateDB.ValidatorWrapper(delegation.ValidatorAddress, false, true)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if uint64(len(wrapper.Delegations)) &gt; delegation.Index </span><span class="cov8" title="1">{
                        delegation := &amp;wrapper.Delegations[delegation.Index]
                        if delegation.Reward.Cmp(common.Big0) &gt; 0 </span><span class="cov8" title="1">{
                                totalRewards.Add(totalRewards, delegation.Reward)
                                delegation.Reward.SetUint64(0)
                        }</span>
                } else<span class="cov8" title="1"> {
                        utils.Logger().Warn().
                                Str("validator", delegation.ValidatorAddress.String()).
                                Uint64("delegation index", delegation.Index).
                                Int("delegations length", len(wrapper.Delegations)).
                                Msg("Delegation index out of bound")
                        return nil, nil, errors.New("Delegation index out of bound")
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers = append(updatedValidatorWrappers, wrapper)</span>
        }
        <span class="cov8" title="1">if totalRewards.Int64() == 0 </span><span class="cov8" title="1">{
                return nil, nil, errNoRewardsToCollect
        }</span>
        <span class="cov8" title="1">return updatedValidatorWrappers, totalRewards, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "math/big"
        "time"

        lru "github.com/hashicorp/golang-lru"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/consensus/reward"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

const (
        resultCacheLimit = 64 // The number of cached results from processing blocks
)

// StateProcessor is a basic Processor, which takes care of transitioning
// state from one point to another.
//
// StateProcessor implements Processor.
type StateProcessor struct {
        config      *params.ChainConfig     // Chain configuration options
        bc          *BlockChain             // Canonical block chain
        engine      consensus_engine.Engine // Consensus engine used for block rewards
        resultCache *lru.Cache              // Cache for result after a certain block is processed
}

// this structure is cached, and each individual element is returned
type ProcessorResult struct {
        Receipts   types.Receipts
        CxReceipts types.CXReceipts
        StakeMsgs  []staking.StakeMsg
        Logs       []*types.Log
        UsedGas    uint64
        Reward     reward.Reader
        State      *state.DB
}

// NewStateProcessor initialises a new StateProcessor.
func NewStateProcessor(
        config *params.ChainConfig, bc *BlockChain, engine consensus_engine.Engine,
) *StateProcessor <span class="cov8" title="1">{
        resultCache, _ := lru.New(resultCacheLimit)
        return &amp;StateProcessor{
                config:      config,
                bc:          bc,
                engine:      engine,
                resultCache: resultCache,
        }
}</span>

// Process processes the state changes according to the Ethereum rules by running
// the transaction messages using the statedb and applying any rewards to both
// the processor (coinbase) and any included uncles.
//
// Process returns the receipts and logs accumulated during the process and
// returns the amount of gas that was used in the process. If any of the
// transactions failed to execute due to insufficient gas it will return an error.
func (p *StateProcessor) Process(
        block *types.Block, statedb *state.DB, cfg vm.Config, readCache bool,
) (
        types.Receipts, types.CXReceipts, []staking.StakeMsg,
        []*types.Log, uint64, reward.Reader, *state.DB, error,
) <span class="cov8" title="1">{
        cacheKey := block.Hash()
        if readCache </span><span class="cov8" title="1">{
                if cached, ok := p.resultCache.Get(cacheKey); ok </span><span class="cov8" title="1">{
                        // Return the cached result to avoid process the same block again.
                        // Only the successful results are cached in case for retry.
                        result := cached.(*ProcessorResult)
                        utils.Logger().Info().Str("block num", block.Number().String()).Msg("result cache hit.")
                        return result.Receipts, result.CxReceipts, result.StakeMsgs, result.Logs, result.UsedGas, result.Reward, result.State, nil
                }</span>
        }

        <span class="cov8" title="1">var (
                receipts       types.Receipts
                outcxs         types.CXReceipts
                incxs          = block.IncomingReceipts()
                usedGas        = new(uint64)
                header         = block.Header()
                allLogs        []*types.Log
                gp                                = new(GasPool).AddGas(block.GasLimit())
                blockStakeMsgs []staking.StakeMsg = make([]staking.StakeMsg, 0)
        )

        beneficiary, err := p.bc.GetECDSAFromCoinbase(header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, 0, nil, statedb, err
        }</span>

        <span class="cov8" title="1">startTime := time.Now()
        // Iterate over and process the individual transactions
        for i, tx := range block.Transactions() </span><span class="cov0" title="0">{
                statedb.Prepare(tx.Hash(), block.Hash(), i)
                receipt, cxReceipt, stakeMsgs, _, err := ApplyTransaction(
                        p.config, p.bc, &amp;beneficiary, gp, statedb, header, tx, usedGas, cfg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, 0, nil, statedb, err
                }</span>
                <span class="cov0" title="0">receipts = append(receipts, receipt)
                if cxReceipt != nil </span><span class="cov0" title="0">{
                        outcxs = append(outcxs, cxReceipt)
                }</span>
                <span class="cov0" title="0">if len(stakeMsgs) &gt; 0 </span><span class="cov0" title="0">{
                        blockStakeMsgs = append(blockStakeMsgs, stakeMsgs...)
                }</span>
                <span class="cov0" title="0">allLogs = append(allLogs, receipt.Logs...)</span>
        }
        <span class="cov8" title="1">utils.Logger().Debug().Int64("elapsed time", time.Now().Sub(startTime).Milliseconds()).Msg("Process Normal Txns")

        startTime = time.Now()
        // Iterate over and process the staking transactions
        L := len(block.Transactions())
        for i, tx := range block.StakingTransactions() </span><span class="cov0" title="0">{
                statedb.Prepare(tx.Hash(), block.Hash(), i+L)
                receipt, _, err := ApplyStakingTransaction(
                        p.config, p.bc, &amp;beneficiary, gp, statedb, header, tx, usedGas, cfg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, 0, nil, statedb, err
                }</span>
                <span class="cov0" title="0">receipts = append(receipts, receipt)
                allLogs = append(allLogs, receipt.Logs...)</span>
        }
        <span class="cov8" title="1">utils.Logger().Debug().Int64("elapsed time", time.Now().Sub(startTime).Milliseconds()).Msg("Process Staking Txns")

        // incomingReceipts should always be processed
        // after transactions (to be consistent with the block proposal)
        for _, cx := range block.IncomingReceipts() </span><span class="cov0" title="0">{
                if err := ApplyIncomingReceipt(
                        p.config, statedb, header, cx,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, nil,
                                nil, nil, 0, nil, statedb, errors.New("[Process] Cannot apply incoming receipts")
                }</span>
        }

        <span class="cov8" title="1">slashes := slash.Records{}
        if s := header.Slashes(); len(s) &gt; 0 </span><span class="cov0" title="0">{
                if err := rlp.DecodeBytes(s, &amp;slashes); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, 0, nil, statedb, errors.New(
                                "[Process] Cannot finalize block",
                        )
                }</span>
        }

        // Finalize the block, applying any consensus engine specific extras (e.g. block rewards)
        <span class="cov8" title="1">sigsReady := make(chan bool)
        go func() </span><span class="cov8" title="1">{
                // Block processing don't need to block on reward computation as in block proposal
                sigsReady &lt;- true
        }</span>()
        <span class="cov8" title="1">_, payout, err := p.engine.Finalize(
                p.bc, header, statedb, block.Transactions(),
                receipts, outcxs, incxs, block.StakingTransactions(), slashes, sigsReady, func() uint64 </span><span class="cov8" title="1">{ return header.ViewID().Uint64() }</span>,
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, 0, nil, statedb, errors.New("[Process] Cannot finalize block")
        }</span>

        <span class="cov8" title="1">result := &amp;ProcessorResult{
                Receipts:   receipts,
                CxReceipts: outcxs,
                StakeMsgs:  blockStakeMsgs,
                Logs:       allLogs,
                UsedGas:    *usedGas,
                Reward:     payout,
                State:      statedb,
        }
        p.resultCache.Add(cacheKey, result)
        return receipts, outcxs, blockStakeMsgs, allLogs, *usedGas, payout, statedb, nil</span>
}

// CacheProcessorResult caches the process result on the cache key.
func (p *StateProcessor) CacheProcessorResult(cacheKey interface{}, result *ProcessorResult) <span class="cov0" title="0">{
        p.resultCache.Add(cacheKey, result)
}</span>

// return true if it is valid
func getTransactionType(
        config *params.ChainConfig, header *block.Header, tx *types.Transaction,
) types.TransactionType <span class="cov8" title="1">{
        if header.ShardID() == tx.ShardID() &amp;&amp;
                (!config.AcceptsCrossTx(header.Epoch()) ||
                        tx.ShardID() == tx.ToShardID()) </span><span class="cov8" title="1">{
                return types.SameShardTx
        }</span>
        <span class="cov0" title="0">numShards := shard.Schedule.InstanceForEpoch(header.Epoch()).NumShards()
        // Assuming here all the shards are consecutive from 0 to n-1, n is total number of shards
        if tx.ShardID() != tx.ToShardID() &amp;&amp;
                header.ShardID() == tx.ShardID() &amp;&amp;
                tx.ToShardID() &lt; numShards </span><span class="cov0" title="0">{
                return types.SubtractionOnly
        }</span>
        <span class="cov0" title="0">return types.InvalidTx</span>
}

// ApplyTransaction attempts to apply a transaction to the given state database
// and uses the input parameters for its environment. It returns the receipt
// for the transaction, gas used and an error if the transaction failed,
// indicating the block was invalid.
func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.DB, header *block.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, *types.CXReceipt, []staking.StakeMsg, uint64, error) <span class="cov8" title="1">{
        txType := getTransactionType(config, header, tx)
        if txType == types.InvalidTx </span><span class="cov0" title="0">{
                return nil, nil, nil, 0, errors.New("Invalid Transaction Type")
        }</span>

        <span class="cov8" title="1">if txType != types.SameShardTx &amp;&amp; !config.AcceptsCrossTx(header.Epoch()) </span><span class="cov0" title="0">{
                return nil, nil, nil, 0, errors.Errorf(
                        "cannot handle cross-shard transaction until after epoch %v (now %v)",
                        config.CrossTxEpoch, header.Epoch(),
                )
        }</span>

        <span class="cov8" title="1">var signer types.Signer
        if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                if !config.IsEthCompatible(header.Epoch()) </span><span class="cov0" title="0">{
                        return nil, nil, nil, 0, errors.New("ethereum compatible transactions not supported at current epoch")
                }</span>
                <span class="cov0" title="0">signer = types.NewEIP155Signer(config.EthCompatibleChainID)</span>
        } else<span class="cov8" title="1"> {
                signer = types.MakeSigner(config, header.Epoch())
        }</span>
        <span class="cov8" title="1">msg, err := tx.AsMessage(signer)

        // skip signer err for additiononly tx
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, 0, err
        }</span>

        // Create a new context to be used in the EVM environment
        <span class="cov8" title="1">context := NewEVMContext(msg, header, bc, author)
        context.TxType = txType
        // Create a new environment which holds all relevant information
        // about the transaction and calling mechanisms.
        vmenv := vm.NewEVM(context, statedb, config, cfg)
        // Apply the transaction to the current state (included in the env)
        result, err := ApplyMessage(vmenv, msg, gp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, 0, err
        }</span>
        // Update the state with pending changes
        <span class="cov8" title="1">var root []byte
        if config.IsS3(header.Epoch()) </span><span class="cov8" title="1">{
                statedb.Finalise(true)
        }</span> else<span class="cov0" title="0"> {
                root = statedb.IntermediateRoot(config.IsS3(header.Epoch())).Bytes()
        }</span>
        <span class="cov8" title="1">*usedGas += result.UsedGas

        failedExe := result.VMErr != nil
        // Create a new receipt for the transaction, storing the intermediate root and gas used by the tx
        // based on the eip phase, we're passing whether the root touch-delete accounts.
        receipt := types.NewReceipt(root, failedExe, *usedGas)
        receipt.TxHash = tx.Hash()
        receipt.GasUsed = result.UsedGas
        // if the transaction created a contract, store the creation address in the receipt.
        if msg.To() == nil </span><span class="cov0" title="0">{
                receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())
        }</span>

        // Set the receipt logs and create a bloom for filtering
        <span class="cov8" title="1">if config.IsReceiptLog(header.Epoch()) </span><span class="cov8" title="1">{
                receipt.Logs = statedb.GetLogs(tx.Hash())
        }</span>
        <span class="cov8" title="1">receipt.Bloom = types.CreateBloom(types.Receipts{receipt})

        var cxReceipt *types.CXReceipt
        // Do not create cxReceipt if EVM call failed
        if txType == types.SubtractionOnly &amp;&amp; !failedExe </span><span class="cov0" title="0">{
                cxReceipt = &amp;types.CXReceipt{tx.Hash(), msg.From(), msg.To(), tx.ShardID(), tx.ToShardID(), msg.Value()}
        }</span> else<span class="cov8" title="1"> {
                cxReceipt = nil
        }</span>

        <span class="cov8" title="1">return receipt, cxReceipt, vmenv.StakeMsgs, result.UsedGas, err</span>
}

// ApplyStakingTransaction attempts to apply a staking transaction to the given state database
// and uses the input parameters for its environment. It returns the receipt
// for the staking transaction, gas used and an error if the transaction failed,
// indicating the block was invalid.
// staking transaction will use the code field in the account to store the staking information
func ApplyStakingTransaction(
        config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.DB,
        header *block.Header, tx *staking.StakingTransaction, usedGas *uint64, cfg vm.Config) (receipt *types.Receipt, gas uint64, err error) <span class="cov0" title="0">{

        msg, err := StakingToMessage(tx, header.Number())
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Create a new context to be used in the EVM environment
        <span class="cov0" title="0">context := NewEVMContext(msg, header, bc, author)

        // Create a new environment which holds all relevant information
        // about the transaction and calling mechanisms.
        vmenv := vm.NewEVM(context, statedb, config, cfg)

        // Apply the transaction to the current state (included in the env)
        gas, err = ApplyStakingMessage(vmenv, msg, gp, bc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Update the state with pending changes
        <span class="cov0" title="0">var root []byte
        if config.IsS3(header.Epoch()) </span><span class="cov0" title="0">{
                statedb.Finalise(true)
        }</span> else<span class="cov0" title="0"> {
                root = statedb.IntermediateRoot(config.IsS3(header.Epoch())).Bytes()
        }</span>
        <span class="cov0" title="0">*usedGas += gas
        receipt = types.NewReceipt(root, false, *usedGas)
        receipt.TxHash = tx.Hash()
        receipt.GasUsed = gas

        if config.IsReceiptLog(header.Epoch()) </span><span class="cov0" title="0">{
                receipt.Logs = statedb.GetLogs(tx.Hash())
                utils.Logger().Info().Interface("CollectReward", receipt.Logs)
        }</span>

        <span class="cov0" title="0">return receipt, gas, nil</span>
}

// ApplyIncomingReceipt will add amount into ToAddress in the receipt
func ApplyIncomingReceipt(
        config *params.ChainConfig, db *state.DB,
        header *block.Header, cxp *types.CXReceiptsProof,
) error <span class="cov0" title="0">{
        if cxp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, cx := range cxp.Receipts </span><span class="cov0" title="0">{
                if cx == nil || cx.To == nil </span><span class="cov0" title="0">{ // should not happend
                        return errors.Errorf(
                                "ApplyIncomingReceipts: Invalid incomingReceipt! %v", cx,
                        )
                }</span>
                <span class="cov0" title="0">utils.Logger().Info().Interface("receipt", cx).
                        Msgf("ApplyIncomingReceipts: ADDING BALANCE %d", cx.Amount)

                if !db.Exist(*cx.To) </span><span class="cov0" title="0">{
                        db.CreateAccount(*cx.To)
                }</span>
                <span class="cov0" title="0">db.AddBalance(*cx.To, cx.Amount)
                db.IntermediateRoot(config.IsS3(header.Epoch()))</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// StakingToMessage returns the staking transaction as a core.Message.
// requires a signer to derive the sender.
// put it here to avoid cyclic import
func StakingToMessage(
        tx *staking.StakingTransaction, blockNum *big.Int,
) (types.Message, error) <span class="cov8" title="1">{
        payload, err := tx.RLPEncodeStakeMsg()
        if err != nil </span><span class="cov0" title="0">{
                return types.Message{}, err
        }</span>
        <span class="cov8" title="1">from, err := tx.SenderAddress()
        if err != nil </span><span class="cov0" title="0">{
                return types.Message{}, err
        }</span>

        <span class="cov8" title="1">msg := types.NewStakingMessage(from, tx.Nonce(), tx.GasLimit(), tx.GasPrice(), payload, blockNum)
        stkType := tx.StakingType()
        if _, ok := types.StakingTypeMap[stkType]; !ok </span><span class="cov0" title="0">{
                return types.Message{}, staking.ErrInvalidStakingKind
        }</span>
        <span class="cov8" title="1">msg.SetType(types.StakingTypeMap[stkType])
        return msg, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "fmt"
        "math/big"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/utils"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var (
        errInvalidSigner               = errors.New("invalid signer for staking transaction")
        errInsufficientBalanceForGas   = errors.New("insufficient balance to pay for gas")
        errInsufficientBalanceForStake = errors.New("insufficient balance to stake")
        errValidatorExist              = errors.New("staking validator already exists")
        errValidatorNotExist           = errors.New("staking validator does not exist")
        errNoDelegationToUndelegate    = errors.New("no delegation to undelegate")
        errCommissionRateChangeTooFast = errors.New("change on commission rate can not be more than max change rate within the same epoch")
        errCommissionRateChangeTooHigh = errors.New("commission rate can not be higher than maximum commission rate")
        errCommissionRateChangeTooLow  = errors.New("commission rate can not be lower than min rate of 5%")
        errNoRewardsToCollect          = errors.New("no rewards to collect")
        errNegativeAmount              = errors.New("amount can not be negative")
        errDupIdentity                 = errors.New("validator identity exists")
        errDupBlsKey                   = errors.New("BLS key exists")
)

/*
StateTransition is the State Transitioning Model which is described as follows:

A state transition is a change made when a transaction is applied to the current world state
The state transitioning model does all the necessary work to work out a valid new state root.

1) Nonce handling
2) Pre pay gas
3) Create a new state object if the recipient is \0*32
4) Value transfer
== If contract creation ==
  4a) Attempt to run transaction data
  4b) If valid, use result as code for the new state object
== end ==
5) Run Script section
6) Derive new state root
*/
type StateTransition struct {
        gp         *GasPool
        msg        Message
        gas        uint64
        gasPrice   *big.Int
        initialGas uint64
        value      *big.Int
        data       []byte
        state      vm.StateDB
        evm        *vm.EVM
        bc         ChainContext
}

// Message represents a message sent to a contract.
type Message interface {
        From() common.Address
        //FromFrontier() (common.Address, error)
        To() *common.Address

        GasPrice() *big.Int
        Gas() uint64
        Value() *big.Int

        Nonce() uint64
        CheckNonce() bool
        Data() []byte
        Type() types.TransactionType
        BlockNum() *big.Int
}

// ExecutionResult is the return value from a transaction committed to the DB
type ExecutionResult struct {
        ReturnData []byte
        UsedGas    uint64
        VMErr      error
}

// Unwrap returns the internal evm error which allows us for further
// analysis outside.
func (result *ExecutionResult) Unwrap() error <span class="cov0" title="0">{
        return result.VMErr
}</span>

// Failed returns the indicator whether the execution is successful or not
func (result *ExecutionResult) Failed() bool <span class="cov0" title="0">{ return result.VMErr != nil }</span>

// Return is a helper function to help caller distinguish between revert reason
// and function return. Return returns the data after execution if no error occurs.
func (result *ExecutionResult) Return() []byte <span class="cov0" title="0">{
        if result.VMErr != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.CopyBytes(result.ReturnData)</span>
}

// Revert returns the concrete revert reason if the execution is aborted by `REVERT`
// opcode. Note the reason can be nil if no data supplied with revert opcode.
func (result *ExecutionResult) Revert() []byte <span class="cov0" title="0">{
        if result.VMErr != vm.ErrExecutionReverted </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.CopyBytes(result.ReturnData)</span>
}

// NewStateTransition initialises and returns a new state transition object.
func NewStateTransition(evm *vm.EVM, msg Message, gp *GasPool, bc ChainContext) *StateTransition <span class="cov8" title="1">{
        return &amp;StateTransition{
                gp:       gp,
                evm:      evm,
                msg:      msg,
                gasPrice: msg.GasPrice(),
                value:    msg.Value(),
                data:     msg.Data(),
                state:    evm.StateDB,
                bc:       bc,
        }
}</span>

// ApplyMessage computes the new state by applying the given message
// against the old state within the environment.
//
// ApplyMessage returns the bytes returned by any EVM execution (if it took place),
// the gas used (which includes gas refunds) and an error if it failed. An error always
// indicates a core error meaning that the message would always fail for that particular
// state and would never be accepted within a block.
func ApplyMessage(evm *vm.EVM, msg Message, gp *GasPool) (ExecutionResult, error) <span class="cov8" title="1">{
        return NewStateTransition(evm, msg, gp, nil).TransitionDb()
}</span>

// ApplyStakingMessage computes the new state for staking message
func ApplyStakingMessage(evm *vm.EVM, msg Message, gp *GasPool, bc ChainContext) (uint64, error) <span class="cov8" title="1">{
        return NewStateTransition(evm, msg, gp, bc).StakingTransitionDb()
}</span>

// to returns the recipient of the message.
func (st *StateTransition) to() common.Address <span class="cov8" title="1">{
        if st.msg == nil || st.msg.To() == nil /* contract creation */ </span><span class="cov0" title="0">{
                return common.Address{}
        }</span>
        <span class="cov8" title="1">return *st.msg.To()</span>
}

func (st *StateTransition) useGas(amount uint64) error <span class="cov8" title="1">{
        if st.gas &lt; amount </span><span class="cov0" title="0">{
                return vm.ErrOutOfGas
        }</span>
        <span class="cov8" title="1">st.gas -= amount

        return nil</span>
}

func (st *StateTransition) buyGas() error <span class="cov8" title="1">{
        mgval := new(big.Int).Mul(new(big.Int).SetUint64(st.msg.Gas()), st.gasPrice)
        if have := st.state.GetBalance(st.msg.From()); have.Cmp(mgval) &lt; 0 </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        errInsufficientBalanceForGas,
                        "had: %s but need: %s", have.String(), mgval.String(),
                )
        }</span>
        <span class="cov8" title="1">if err := st.gp.SubGas(st.msg.Gas()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">st.gas += st.msg.Gas()

        st.initialGas = st.msg.Gas()
        st.state.SubBalance(st.msg.From(), mgval)
        return nil</span>
}

func (st *StateTransition) preCheck() error <span class="cov8" title="1">{
        // Make sure this transaction's nonce is correct.
        if st.msg.CheckNonce() </span><span class="cov8" title="1">{
                nonce := st.state.GetNonce(st.msg.From())

                if nonce &lt; st.msg.Nonce() </span><span class="cov0" title="0">{
                        return ErrNonceTooHigh
                }</span> else<span class="cov8" title="1"> if nonce &gt; st.msg.Nonce() </span><span class="cov0" title="0">{
                        return ErrNonceTooLow
                }</span>
        }
        <span class="cov8" title="1">return st.buyGas()</span>
}

// TransitionDb will transition the state by applying the current message and
// returning the result including the used gas. It returns an error if failed.
// An error indicates a consensus issue.
func (st *StateTransition) TransitionDb() (ExecutionResult, error) <span class="cov8" title="1">{
        if err := st.preCheck(); err != nil </span><span class="cov0" title="0">{
                return ExecutionResult{}, err
        }</span>
        <span class="cov8" title="1">msg := st.msg
        sender := vm.AccountRef(msg.From())
        homestead := st.evm.ChainConfig().IsS3(st.evm.EpochNumber) // s3 includes homestead
        istanbul := st.evm.ChainConfig().IsIstanbul(st.evm.EpochNumber)
        contractCreation := msg.To() == nil

        // Pay intrinsic gas
        gas, err := vm.IntrinsicGas(st.data, contractCreation, homestead, istanbul, false)
        if err != nil </span><span class="cov0" title="0">{
                return ExecutionResult{}, err
        }</span>
        <span class="cov8" title="1">if err = st.useGas(gas); err != nil </span><span class="cov0" title="0">{
                return ExecutionResult{}, fmt.Errorf("%w: have %d, want %d", ErrIntrinsicGas, st.gas, gas)
        }</span>

        <span class="cov8" title="1">evm := st.evm

        var ret []byte
        // All VM errors are valid except for insufficient balance, therefore returned separately
        var vmErr error

        if contractCreation </span><span class="cov0" title="0">{
                ret, _, st.gas, vmErr = evm.Create(sender, st.data, st.gas, st.value)
        }</span> else<span class="cov8" title="1"> {
                // Increment the nonce for the next transaction
                st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)
                ret, st.gas, vmErr = evm.Call(sender, st.to(), st.data, st.gas, st.value)
        }</span>
        <span class="cov8" title="1">if vmErr != nil </span><span class="cov0" title="0">{
                utils.Logger().Debug().Err(vmErr).Msg("VM returned with error")
                // The only possible consensus-error would be if there wasn't
                // sufficient balance to make the transfer happen. The first
                // balance transfer may never fail.

                if vmErr == vm.ErrInsufficientBalance </span><span class="cov0" title="0">{
                        return ExecutionResult{}, vmErr
                }</span>
        }
        <span class="cov8" title="1">st.refundGas()

        // Burn Txn Fees after staking epoch
        if !st.evm.ChainConfig().IsStaking(st.evm.EpochNumber) </span><span class="cov0" title="0">{
                txFee := new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice)
                st.state.AddBalance(st.evm.Coinbase, txFee)
        }</span>

        <span class="cov8" title="1">return ExecutionResult{
                ReturnData: ret,
                UsedGas:    st.gasUsed(),
                VMErr:      vmErr,
        }, err</span>
}

func (st *StateTransition) refundGas() <span class="cov8" title="1">{
        // Apply refund counter, capped to half of the used gas.
        refund := st.gasUsed() / 2
        if refund &gt; st.state.GetRefund() </span><span class="cov8" title="1">{
                refund = st.state.GetRefund()
        }</span>
        <span class="cov8" title="1">st.gas += refund

        // Return ETH for remaining gas, exchanged at the original rate.
        remaining := new(big.Int).Mul(new(big.Int).SetUint64(st.gas), st.gasPrice)
        st.state.AddBalance(st.msg.From(), remaining)

        // Also return remaining gas to the block gas counter so it is
        // available for the next transaction.
        st.gp.AddGas(st.gas)</span>
}

// gasUsed returns the amount of gas used up by the state transition.
func (st *StateTransition) gasUsed() uint64 <span class="cov8" title="1">{
        return st.initialGas - st.gas
}</span>

// StakingTransitionDb will transition the state by applying the staking message and
// returning the result including the used gas. It returns an error if failed.
// It is used for staking transaction only
func (st *StateTransition) StakingTransitionDb() (usedGas uint64, err error) <span class="cov8" title="1">{
        if err = st.preCheck(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">msg := st.msg

        sender := vm.AccountRef(msg.From())
        homestead := st.evm.ChainConfig().IsS3(st.evm.EpochNumber) // s3 includes homestead
        istanbul := st.evm.ChainConfig().IsIstanbul(st.evm.EpochNumber)

        // Pay intrinsic gas
        gas, err := vm.IntrinsicGas(st.data, false, homestead, istanbul, msg.Type() == types.StakeCreateVal)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if err = st.useGas(gas); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Increment the nonce for the next transaction
        <span class="cov8" title="1">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)

        // from worker.go, we get here with shardID == BeaconChainShardID
        // from node_handler.go, via blockchain.go =&gt; it is checked that block shard == node shard
        // same via consensus
        // so only possible to reach here if shardID == BeaconChainShardID (no need to check further)
        switch msg.Type() </span>{
        case types.StakeCreateVal:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.CreateValidator{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().
                        Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.ValidatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.CreateValidator(st.evm.StateDB, stkMsg)</span>
        case types.StakeEditVal:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.EditValidator{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().
                        Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.ValidatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.EditValidator(st.evm.StateDB, stkMsg)</span>
        case types.Delegate:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.Delegate{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.Delegate(st.evm.StateDB, stkMsg)</span>
        case types.Undelegate:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.Undelegate{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.Undelegate(st.evm.StateDB, stkMsg)</span>
        case types.CollectRewards:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.CollectRewards{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.CollectRewards(st.evm.StateDB, stkMsg)</span>
        default:<span class="cov0" title="0">
                return 0, stakingTypes.ErrInvalidStakingKind</span>
        }
        <span class="cov8" title="1">st.refundGas()

        // Burn Txn Fees
        //txFee := new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice)
        //st.state.AddBalance(st.evm.Coinbase, txFee)

        return st.gasUsed(), err</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "fmt"
        "math"
        "math/big"
        "sort"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/prque"
        "github.com/ethereum/go-ethereum/event"
        "github.com/ethereum/go-ethereum/metrics"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/pkg/errors"

        "github.com/harmony-one/harmony/block"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        hmyCommon "github.com/harmony-one/harmony/internal/common"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/shard"
        staking "github.com/harmony-one/harmony/staking/types"
)

const (
        // chainHeadChanSize is the size of channel listening to ChainHeadEvent.
        chainHeadChanSize = 10
)

var (
        // ErrInvalidSender is returned if the transaction contains an invalid signature.
        ErrInvalidSender = errors.New("invalid sender")

        // ErrInvalidShard is returned if the transaction is for the wrong shard.
        ErrInvalidShard = errors.New("invalid shard")

        // ErrNonceTooLow is returned if the nonce of a transaction is lower than the
        // one present in the local chain.
        ErrNonceTooLow = errors.New("nonce too low")

        // ErrUnderpriced is returned if a transaction's gas price is below the minimum
        // configured for the transaction pool.
        ErrUnderpriced = errors.New("transaction underpriced")

        // ErrReplaceUnderpriced is returned if a transaction is attempted to be replaced
        // with a different one without the required price bump.
        ErrReplaceUnderpriced = errors.New("replacement transaction underpriced")

        // ErrInsufficientFunds is returned if the total cost of executing a transaction
        // is higher than the balance of the user's account.
        ErrInsufficientFunds = errors.New("insufficient funds for gas * price + value")

        // ErrIntrinsicGas is returned if the transaction is specified to use less gas
        // than required to start the invocation.
        ErrIntrinsicGas = errors.New("intrinsic gas too low")

        // ErrGasLimit is returned if a transaction's requested gas limit exceeds the
        // maximum allowance of the current block.
        ErrGasLimit = errors.New("exceeds block gas limit")

        // ErrNegativeValue is a sanity error to ensure noone is able to specify a
        // transaction with a negative value.
        ErrNegativeValue = errors.New("negative value")

        // ErrOversizedData is returned if the input data of a transaction is greater
        // than some meaningful limit a user might use. This is not a consensus error
        // making the transaction invalid, rather a DOS protection.
        ErrOversizedData = errors.New("oversized data")

        // ErrKnownTransaction is returned if a transaction that is already in the pool
        // attempting to be added to the pool.
        ErrKnownTransaction = errors.New("known transaction")

        // ErrInvalidMsgForStakingDirective is returned if a staking message does not
        // match the related directive
        ErrInvalidMsgForStakingDirective = errors.New("staking message does not match directive message")

        // ErrBlacklistFrom is returned if a transaction's from/source address is blacklisted
        ErrBlacklistFrom = errors.New("`from` address of transaction in blacklist")

        // ErrBlacklistTo is returned if a transaction's to/destination address is blacklisted
        ErrBlacklistTo = errors.New("`to` address of transaction in blacklist")
)

var (
        evictionInterval    = time.Minute     // Time interval to check for evictable transactions
        statsReportInterval = 8 * time.Second // Time interval to report transaction pool stats
)

var (
        // Metrics for the pending pool
        pendingDiscardCounter   = metrics.NewRegisteredCounter("txpool/pending/discard", nil)
        pendingReplaceCounter   = metrics.NewRegisteredCounter("txpool/pending/replace", nil)
        pendingRateLimitCounter = metrics.NewRegisteredCounter("txpool/pending/ratelimit", nil) // Dropped due to rate limiting
        pendingNofundsCounter   = metrics.NewRegisteredCounter("txpool/pending/nofunds", nil)   // Dropped due to out-of-funds

        // Metrics for the queued pool
        queuedDiscardCounter   = metrics.NewRegisteredCounter("txpool/queued/discard", nil)
        queuedReplaceCounter   = metrics.NewRegisteredCounter("txpool/queued/replace", nil)
        queuedRateLimitCounter = metrics.NewRegisteredCounter("txpool/queued/ratelimit", nil) // Dropped due to rate limiting
        queuedNofundsCounter   = metrics.NewRegisteredCounter("txpool/queued/nofunds", nil)   // Dropped due to out-of-funds

        // General tx metrics
        invalidTxCounter     = metrics.NewRegisteredCounter("txpool/invalid", nil)
        underpricedTxCounter = metrics.NewRegisteredCounter("txpool/underpriced", nil)
)

// TxStatus is the current status of a transaction as seen by the pool.
type TxStatus uint

// Constants for TxStatus.
const (
        TxStatusUnknown TxStatus = iota
        TxStatusQueued
        TxStatusPending
        TxStatusIncluded
)

// blockChain provides the state of blockchain and current gas limit to do
// some pre checks in tx pool and event subscribers.
type blockChain interface {
        CurrentBlock() *types.Block
        GetBlock(hash common.Hash, number uint64) *types.Block
        StateAt(root common.Hash) (*state.DB, error)

        SubscribeChainHeadEvent(ch chan&lt;- ChainHeadEvent) event.Subscription
}

// TxPoolConfig are the configuration parameters of the transaction pool.
type TxPoolConfig struct {
        Locals    []common.Address // Addresses that should be treated by default as local
        NoLocals  bool             // Whether local transaction handling should be disabled
        Journal   string           // Journal of local transactions to survive node restarts
        Rejournal time.Duration    // Time interval to regenerate the local transaction journal

        PriceLimit uint64 // Minimum gas price to enforce for acceptance into the pool
        PriceBump  uint64 // Minimum price bump to replace an already existing transaction (nonce)

        AccountSlots uint64 // Number of executable transaction slots guaranteed per account
        GlobalSlots  uint64 // Maximum number of executable transaction slots for all accounts
        AccountQueue uint64 // Maximum number of non-executable transaction slots permitted per account
        GlobalQueue  uint64 // Maximum number of non-executable transaction slots for all accounts

        Lifetime time.Duration // Maximum amount of time non-executable transaction are queued

        Blacklist map[common.Address]struct{} // Set of accounts that cannot be a part of any transaction
}

// DefaultTxPoolConfig contains the default configurations for the transaction
// pool.
var DefaultTxPoolConfig = TxPoolConfig{
        Journal:   "transactions.rlp",
        Rejournal: time.Hour,

        PriceLimit: 1e9, // 1 Gwei/Nano
        PriceBump:  10,

        AccountSlots: 16,
        GlobalSlots:  4096,
        AccountQueue: 64,
        GlobalQueue:  1024,

        Lifetime: 30 * time.Minute,

        Blacklist: map[common.Address]struct{}{},
}

// sanitize checks the provided user configurations and changes anything that's
// unreasonable or unworkable.
func (config *TxPoolConfig) sanitize() TxPoolConfig <span class="cov8" title="1">{
        conf := *config
        if conf.Rejournal &lt; time.Second </span><span class="cov0" title="0">{
                utils.Logger().Warn().
                        Dur("provided", conf.Rejournal).
                        Dur("updated", time.Second).
                        Msg("Sanitizing invalid txpool journal time")
                conf.Rejournal = time.Second
        }</span>
        <span class="cov8" title="1">if conf.PriceLimit &lt; 1 </span><span class="cov0" title="0">{
                utils.Logger().Warn().
                        Uint64("provided", conf.PriceLimit).
                        Uint64("updated", DefaultTxPoolConfig.PriceLimit).
                        Msg("Sanitizing invalid txpool price limit")
                conf.PriceLimit = DefaultTxPoolConfig.PriceLimit
        }</span>
        <span class="cov8" title="1">if conf.PriceBump &lt; 1 </span><span class="cov0" title="0">{
                utils.Logger().Warn().
                        Uint64("provided", conf.PriceBump).
                        Uint64("updated", DefaultTxPoolConfig.PriceBump).
                        Msg("Sanitizing invalid txpool price bump")
                conf.PriceBump = DefaultTxPoolConfig.PriceBump
        }</span>
        <span class="cov8" title="1">if conf.Blacklist == nil </span><span class="cov8" title="1">{
                utils.Logger().Warn().Msg("Sanitizing nil blacklist set")
                conf.Blacklist = DefaultTxPoolConfig.Blacklist
        }</span>

        <span class="cov8" title="1">return conf</span>
}

// TxPool contains all currently known transactions. Transactions
// enter the pool when they are received from the network or submitted
// locally. They exit the pool when they are included in the blockchain.
//
// The pool separates processable transactions (which can be applied to the
// current state) and future transactions. Transactions move between those
// two states over time as they are received and processed.
type TxPool struct {
        config       TxPoolConfig
        chainconfig  *params.ChainConfig
        chain        blockChain
        gasPrice     *big.Int
        txFeed       event.Feed
        scope        event.SubscriptionScope
        chainHeadCh  chan ChainHeadEvent
        chainHeadSub event.Subscription
        mu           sync.RWMutex

        currentState  *state.DB           // Current state in the blockchain head
        pendingState  *state.ManagedState // Pending state tracking virtual nonces
        currentMaxGas uint64              // Current gas limit for transaction caps

        locals  *accountSet // Set of local transaction to exempt from eviction rules
        journal *txJournal  // Journal of local transaction to back up to disk

        pending map[common.Address]*txList   // All currently processable transactions
        queue   map[common.Address]*txList   // Queued but non-processable transactions
        beats   map[common.Address]time.Time // Last heartbeat from each known account
        all     *txLookup                    // All transactions to allow lookups
        priced  *txPricedList                // All transactions sorted by price

        wg sync.WaitGroup // for shutdown sync

        txErrorSink *types.TransactionErrorSink // All failed txs gets reported here

        homestead bool
        istanbul  bool
}

// NewTxPool creates a new transaction pool to gather, sort and filter inbound
// transactions from the network.
func NewTxPool(config TxPoolConfig, chainconfig *params.ChainConfig,
        chain blockChain, txErrorSink *types.TransactionErrorSink,
) *TxPool <span class="cov8" title="1">{
        // Sanitize the input to ensure no vulnerable gas prices are set
        config = (&amp;config).sanitize()

        // Create the transaction pool with its initial settings
        pool := &amp;TxPool{
                config:      config,
                chainconfig: chainconfig,
                chain:       chain,
                pending:     make(map[common.Address]*txList),
                queue:       make(map[common.Address]*txList),
                beats:       make(map[common.Address]time.Time),
                all:         newTxLookup(),
                chainHeadCh: make(chan ChainHeadEvent, chainHeadChanSize),
                gasPrice:    new(big.Int).SetUint64(config.PriceLimit),
                txErrorSink: txErrorSink,
        }
        pool.locals = newAccountSet(chainconfig.ChainID)
        for _, addr := range config.Locals </span><span class="cov0" title="0">{
                utils.Logger().Info().Interface("address", addr).Msg("Setting new local account")
                pool.locals.add(addr)
        }</span>
        <span class="cov8" title="1">pool.priced = newTxPricedList(pool.all)
        pool.reset(nil, chain.CurrentBlock().Header())

        // If local transactions and journaling is enabled, load from disk
        if !config.NoLocals &amp;&amp; config.Journal != "" </span><span class="cov8" title="1">{
                pool.journal = newTxJournal(config.Journal)

                if err := pool.journal.load(pool.AddLocals); err != nil </span><span class="cov0" title="0">{
                        utils.Logger().Warn().Err(err).Msg("Failed to load transaction journal")
                }</span>
                <span class="cov8" title="1">if err := pool.journal.rotate(pool.local()); err != nil </span><span class="cov0" title="0">{
                        utils.Logger().Warn().Err(err).Msg("Failed to rotate transaction journal")
                }</span>
        }
        // Subscribe events from blockchain
        <span class="cov8" title="1">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)

        // Start the event loop and return
        pool.wg.Add(1)
        go pool.loop()

        return pool</span>
}

// loop is the transaction pool's main event loop, waiting for and reacting to
// outside blockchain events as well as for various reporting and transaction
// eviction events.
func (pool *TxPool) loop() <span class="cov8" title="1">{
        defer pool.wg.Done()

        // Start the stats reporting and transaction eviction tickers
        var prevPending, prevQueued, prevStales int

        report := time.NewTicker(statsReportInterval)
        defer report.Stop()

        evict := time.NewTicker(evictionInterval)
        defer evict.Stop()

        journal := time.NewTicker(pool.config.Rejournal)
        defer journal.Stop()

        // Track the previous head headers for transaction reorgs
        head := pool.chain.CurrentBlock()

        // Keep waiting for and reacting to the various events
        for </span><span class="cov8" title="1">{
                select </span>{
                // Handle ChainHeadEvent
                case ev := &lt;-pool.chainHeadCh:<span class="cov8" title="1">
                        if ev.Block != nil </span><span class="cov8" title="1">{
                                pool.mu.Lock()
                                if pool.chainconfig.IsS3(ev.Block.Epoch()) </span><span class="cov8" title="1">{
                                        pool.homestead = true
                                }</span>
                                <span class="cov8" title="1">if pool.chainconfig.IsIstanbul(ev.Block.Epoch()) </span><span class="cov0" title="0">{
                                        pool.istanbul = true
                                }</span>
                                <span class="cov8" title="1">pool.reset(head.Header(), ev.Block.Header())
                                head = ev.Block
                                pool.mu.Unlock()</span>
                        }
                // Be unsubscribed due to system stopped
                case &lt;-pool.chainHeadSub.Err():<span class="cov8" title="1">
                        return</span>

                // Handle stats reporting ticks
                case &lt;-report.C:<span class="cov8" title="1">
                        pool.mu.RLock()
                        pending, queued := pool.stats()
                        stales := pool.priced.stales
                        pool.mu.RUnlock()

                        if pending != prevPending || queued != prevQueued || stales != prevStales </span><span class="cov0" title="0">{
                                utils.Logger().Debug().
                                        Int("executable", pending).
                                        Int("queued", queued).
                                        Int("stales", stales).
                                        Msg("Transaction pool status report")
                                prevPending, prevQueued, prevStales = pending, queued, stales
                        }</span>

                // Handle inactive account transaction eviction
                case &lt;-evict.C:<span class="cov8" title="1">
                        pool.mu.Lock()
                        for addr := range pool.queue </span><span class="cov8" title="1">{
                                // Skip local transactions from the eviction mechanism
                                if pool.locals.contains(addr) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                // Any non-locals old enough should be removed
                                <span class="cov8" title="1">if time.Since(pool.beats[addr]) &gt; pool.config.Lifetime </span><span class="cov8" title="1">{
                                        b32addr, err := hmyCommon.AddressToBech32(addr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                b32addr = "unknown"
                                        }</span>
                                        <span class="cov8" title="1">for _, tx := range pool.queue[addr].Flatten() </span><span class="cov8" title="1">{
                                                pool.removeTx(tx.Hash(), true)
                                                pool.txErrorSink.Add(tx, fmt.Errorf("removed transaction for inactive account %v", b32addr))
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">pool.mu.Unlock()</span>

                // Handle local transaction journal rotation
                case &lt;-journal.C:<span class="cov8" title="1">
                        if pool.journal != nil </span><span class="cov8" title="1">{
                                pool.mu.Lock()
                                if err := pool.journal.rotate(pool.local()); err != nil </span><span class="cov0" title="0">{
                                        utils.Logger().Warn().Err(err).Msg("Failed to rotate local tx journal")
                                }</span>
                                <span class="cov8" title="1">pool.mu.Unlock()</span>
                        }
                }
        }
}

// lockedReset is a wrapper around reset to allow calling it in a thread safe
// manner. This method is only ever used in the tester!
func (pool *TxPool) lockedReset(oldHead, newHead *block.Header) <span class="cov8" title="1">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        pool.reset(oldHead, newHead)
}</span>

// reset retrieves the current state of the blockchain and ensures the content
// of the transaction pool is valid with regard to the chain state.
func (pool *TxPool) reset(oldHead, newHead *block.Header) <span class="cov8" title="1">{
        // If we're reorging an old state, reinject all dropped transactions
        var reinject types.PoolTransactions

        if oldHead != nil &amp;&amp; oldHead.Hash() != newHead.ParentHash() </span><span class="cov0" title="0">{
                // If the reorg is too deep, avoid doing it (will happen during fast sync)
                oldNum := oldHead.Number().Uint64()
                newNum := newHead.Number().Uint64()

                if depth := uint64(math.Abs(float64(oldNum) - float64(newNum))); depth &gt; 64 </span><span class="cov0" title="0">{
                        utils.Logger().Debug().Uint64("depth", depth).Msg("Skipping deep transaction reorg")
                }</span> else<span class="cov0" title="0"> {
                        // Reorg seems shallow enough to pull in all transactions into memory
                        var discarded, included types.PoolTransactions

                        var (
                                rem = pool.chain.GetBlock(oldHead.Hash(), oldHead.Number().Uint64())
                                add = pool.chain.GetBlock(newHead.Hash(), newHead.Number().Uint64())
                        )
                        for rem.NumberU64() &gt; add.NumberU64() </span><span class="cov0" title="0">{
                                for _, tx := range rem.Transactions() </span><span class="cov0" title="0">{
                                        discarded = append(discarded, tx)
                                }</span>
                                <span class="cov0" title="0">for _, tx := range rem.StakingTransactions() </span><span class="cov0" title="0">{
                                        discarded = append(discarded, tx)
                                }</span>
                                <span class="cov0" title="0">if rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()-1); rem == nil </span><span class="cov0" title="0">{
                                        utils.Logger().Error().
                                                Str("block", oldHead.Number().String()).
                                                Str("hash", oldHead.Hash().Hex()).
                                                Msg("Unrooted old chain seen by tx pool")
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">for add.NumberU64() &gt; rem.NumberU64() </span><span class="cov0" title="0">{
                                for _, tx := range add.Transactions() </span><span class="cov0" title="0">{
                                        included = append(included, tx)
                                }</span>
                                <span class="cov0" title="0">for _, tx := range add.StakingTransactions() </span><span class="cov0" title="0">{
                                        included = append(included, tx)
                                }</span>
                                <span class="cov0" title="0">if add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()-1); add == nil </span><span class="cov0" title="0">{
                                        utils.Logger().Error().
                                                Str("block", newHead.Number().String()).
                                                Str("hash", newHead.Hash().Hex()).
                                                Msg("Unrooted new chain seen by tx pool")
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">for rem.Hash() != add.Hash() </span><span class="cov0" title="0">{
                                for _, tx := range rem.Transactions() </span><span class="cov0" title="0">{
                                        discarded = append(discarded, tx)
                                }</span>
                                <span class="cov0" title="0">for _, tx := range rem.StakingTransactions() </span><span class="cov0" title="0">{
                                        discarded = append(discarded, tx)
                                }</span>
                                <span class="cov0" title="0">if rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()-1); rem == nil </span><span class="cov0" title="0">{
                                        utils.Logger().Error().
                                                Str("block", oldHead.Number().String()).
                                                Str("hash", oldHead.Hash().Hex()).
                                                Msg("Unrooted old chain seen by tx pool")
                                        return
                                }</span>
                                <span class="cov0" title="0">for _, tx := range add.Transactions() </span><span class="cov0" title="0">{
                                        included = append(included, tx)
                                }</span>
                                <span class="cov0" title="0">for _, tx := range add.StakingTransactions() </span><span class="cov0" title="0">{
                                        included = append(included, tx)
                                }</span>
                                <span class="cov0" title="0">if add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()-1); add == nil </span><span class="cov0" title="0">{
                                        utils.Logger().Error().
                                                Str("block", newHead.Number().String()).
                                                Str("hash", newHead.Hash().Hex()).
                                                Msg("Unrooted new chain seen by tx pool")
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">reinject = types.PoolTxDifference(discarded, included)</span>
                }
        }
        // Initialize the internal state to the current head
        <span class="cov8" title="1">if newHead == nil </span><span class="cov8" title="1">{
                newHead = pool.chain.CurrentBlock().Header() // Special case during testing
        }</span>
        <span class="cov8" title="1">statedb, err := pool.chain.StateAt(newHead.Root())
        if err != nil </span><span class="cov0" title="0">{
                utils.Logger().Error().Err(err).Msg("Failed to reset txpool state")
                return
        }</span>
        <span class="cov8" title="1">pool.currentState = statedb
        pool.pendingState = state.ManageState(statedb)
        pool.currentMaxGas = newHead.GasLimit()

        // Inject any transactions discarded due to reorgs
        utils.Logger().Debug().Int("count", len(reinject)).Msg("Reinjecting stale transactions")
        //senderCacher.recover(pool.signer, reinject)
        pool.addTxsLocked(reinject, false)

        // validate the pool of pending transactions, this will remove
        // any transactions that have been included in the block or
        // have been invalidated because of another transaction (e.g.
        // higher gas price)
        pool.demoteUnexecutables(newHead.Number().Uint64())

        // Update all accounts to the latest known pending nonce
        for addr, list := range pool.pending </span><span class="cov8" title="1">{
                txs := list.Flatten() // Heavy but will be cached and is needed by the miner anyway
                pool.pendingState.SetNonce(addr, txs[len(txs)-1].Nonce()+1)
        }</span>
        // Check the queue and move transactions over to the pending if possible
        // or remove those that have become invalid
        <span class="cov8" title="1">pool.promoteExecutables(nil)</span>
}

// GetTxPoolSize returns tx pool size.
func (pool *TxPool) GetTxPoolSize() uint64 <span class="cov0" title="0">{
        return uint64(len(pool.pending)) + uint64(len(pool.queue))
}</span>

// Stop terminates the transaction pool.
func (pool *TxPool) Stop() <span class="cov8" title="1">{
        // Unsubscribe all subscriptions registered from txpool
        pool.scope.Close()

        // Unsubscribe subscriptions registered from blockchain
        pool.chainHeadSub.Unsubscribe()
        pool.wg.Wait()

        if pool.journal != nil </span><span class="cov8" title="1">{
                pool.journal.close()
        }</span>
        <span class="cov8" title="1">utils.Logger().Info().Msg("Transaction pool stopped")</span>
}

// SubscribeNewTxsEvent registers a subscription of NewTxsEvent and
// starts sending event to the given channel.
func (pool *TxPool) SubscribeNewTxsEvent(ch chan&lt;- NewTxsEvent) event.Subscription <span class="cov0" title="0">{
        return pool.scope.Track(pool.txFeed.Subscribe(ch))
}</span>

// GasPrice returns the current gas price enforced by the transaction pool.
func (pool *TxPool) GasPrice() *big.Int <span class="cov0" title="0">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()

        return new(big.Int).Set(pool.gasPrice)
}</span>

// SetGasPrice updates the minimum price required by the transaction pool for a
// new transaction, and drops all transactions below this threshold.
func (pool *TxPool) SetGasPrice(price *big.Int) <span class="cov8" title="1">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        pool.gasPrice = price
        for _, tx := range pool.priced.Cap(price, pool.locals) </span><span class="cov0" title="0">{
                pool.removeTx(tx.Hash(), false)
                pool.txErrorSink.Add(tx,
                        fmt.Errorf("dropped transaction below new gas price threshold of %v", price.String()))
        }</span>
        <span class="cov8" title="1">utils.Logger().Info().Str("price", price.String()).Msg("Transaction pool price threshold updated")</span>
}

// State returns the virtual managed state of the transaction pool.
func (pool *TxPool) State() *state.ManagedState <span class="cov8" title="1">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()

        return pool.pendingState
}</span>

// Stats retrieves the current pool stats, namely the number of pending and the
// number of queued (non-executable) transactions.
func (pool *TxPool) Stats() (int, int) <span class="cov8" title="1">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()

        return pool.stats()
}</span>

// stats retrieves the current pool stats, namely the number of pending and the
// number of queued (non-executable) transactions.
func (pool *TxPool) stats() (int, int) <span class="cov8" title="1">{
        pending := 0
        for _, list := range pool.pending </span><span class="cov8" title="1">{
                pending += list.Len()
        }</span>
        <span class="cov8" title="1">queued := 0
        for _, list := range pool.queue </span><span class="cov8" title="1">{
                queued += list.Len()
        }</span>
        <span class="cov8" title="1">return pending, queued</span>
}

// Content retrieves the data content of the transaction pool, returning all the
// pending as well as queued transactions, grouped by account and sorted by nonce.
func (pool *TxPool) Content() (map[common.Address]types.PoolTransactions, map[common.Address]types.PoolTransactions) <span class="cov0" title="0">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        pending := make(map[common.Address]types.PoolTransactions)
        for addr, list := range pool.pending </span><span class="cov0" title="0">{
                pending[addr] = list.Flatten()
        }</span>
        <span class="cov0" title="0">queued := make(map[common.Address]types.PoolTransactions)
        for addr, list := range pool.queue </span><span class="cov0" title="0">{
                queued[addr] = list.Flatten()
        }</span>
        <span class="cov0" title="0">return pending, queued</span>
}

// Pending retrieves all currently executable transactions, grouped by origin
// account and sorted by nonce. The returned transaction set is a copy and can be
// freely modified by calling code.
func (pool *TxPool) Pending() (map[common.Address]types.PoolTransactions, error) <span class="cov8" title="1">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        pending := make(map[common.Address]types.PoolTransactions)
        for addr, list := range pool.pending </span><span class="cov8" title="1">{
                pending[addr] = list.Flatten()
        }</span>
        <span class="cov8" title="1">return pending, nil</span>
}

// Queued retrieves all currently non-executable transactions, grouped by origin
// account and sorted by nonce. The returned transaction set is a copy and can be
// freely modified by calling code.
func (pool *TxPool) Queued() (map[common.Address]types.PoolTransactions, error) <span class="cov0" title="0">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        queued := make(map[common.Address]types.PoolTransactions)
        for addr, list := range pool.queue </span><span class="cov0" title="0">{
                queued[addr] = list.Flatten()
        }</span>
        <span class="cov0" title="0">return queued, nil</span>
}

// Locals retrieves the accounts currently considered local by the pool.
func (pool *TxPool) Locals() []common.Address <span class="cov0" title="0">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        return pool.locals.flatten()
}</span>

// local retrieves all currently known local transactions, grouped by origin
// account and sorted by nonce. The returned transaction set is a copy and can be
// freely modified by calling code.
func (pool *TxPool) local() map[common.Address]types.PoolTransactions <span class="cov8" title="1">{
        txs := make(map[common.Address]types.PoolTransactions)
        for addr := range pool.locals.accounts </span><span class="cov8" title="1">{
                if pending := pool.pending[addr]; pending != nil </span><span class="cov8" title="1">{
                        txs[addr] = append(txs[addr], pending.Flatten()...)
                }</span>
                <span class="cov8" title="1">if queued := pool.queue[addr]; queued != nil </span><span class="cov8" title="1">{
                        txs[addr] = append(txs[addr], queued.Flatten()...)
                }</span>
        }
        <span class="cov8" title="1">return txs</span>
}

// validateTx checks whether a transaction is valid according to the consensus
// rules and adheres to some heuristic limits of the local node (price and size).
func (pool *TxPool) validateTx(tx types.PoolTransaction, local bool) error <span class="cov8" title="1">{
        if tx.ShardID() != pool.chain.CurrentBlock().ShardID() </span><span class="cov8" title="1">{
                return errors.WithMessagef(ErrInvalidShard, "transaction shard is %d", tx.ShardID())
        }</span>
        // For DOS prevention, reject excessively large transactions.
        <span class="cov8" title="1">if tx.Size() &gt;= types.MaxPoolTransactionDataSize </span><span class="cov0" title="0">{
                return errors.WithMessagef(ErrOversizedData, "transaction size is %s", tx.Size().String())
        }</span>
        // Transactions can't be negative. This may never happen using RLP decoded
        // transactions but may occur if you create a transaction using the RPC.
        <span class="cov8" title="1">if tx.Value().Sign() &lt; 0 </span><span class="cov8" title="1">{
                return errors.WithMessagef(ErrNegativeValue, "transaction value is %s", tx.Value().String())
        }</span>
        // Ensure the transaction doesn't exceed the current block limit gas.
        <span class="cov8" title="1">if pool.currentMaxGas &lt; tx.GasLimit() </span><span class="cov0" title="0">{
                return errors.WithMessagef(ErrGasLimit, "transaction gas is %d", tx.GasLimit())
        }</span>
        // Make sure the transaction is signed properly
        <span class="cov8" title="1">from, err := tx.SenderAddress()
        if err != nil </span><span class="cov0" title="0">{
                if b32, err := hmyCommon.AddressToBech32(from); err == nil </span><span class="cov0" title="0">{
                        return errors.WithMessagef(ErrInvalidSender, "transaction sender is %s", b32)
                }</span>
                <span class="cov0" title="0">return ErrInvalidSender</span>
        }
        // Make sure transaction does not have blacklisted addresses
        <span class="cov8" title="1">if _, exists := (pool.config.Blacklist)[from]; exists </span><span class="cov8" title="1">{
                if b32, err := hmyCommon.AddressToBech32(from); err == nil </span><span class="cov8" title="1">{
                        return errors.WithMessagef(ErrBlacklistFrom, "transaction sender is %s", b32)
                }</span>
                <span class="cov0" title="0">return ErrBlacklistFrom</span>
        }
        // Make sure transaction does not burn funds by sending funds to blacklisted address
        <span class="cov8" title="1">if tx.To() != nil </span><span class="cov8" title="1">{
                if _, exists := (pool.config.Blacklist)[*tx.To()]; exists </span><span class="cov8" title="1">{
                        if b32, err := hmyCommon.AddressToBech32(*tx.To()); err == nil </span><span class="cov8" title="1">{
                                return errors.WithMessagef(ErrBlacklistTo, "transaction receiver is %s", b32)
                        }</span>
                        <span class="cov0" title="0">return ErrBlacklistTo</span>
                }
        }
        // Drop non-local transactions under our own minimal accepted gas price
        <span class="cov8" title="1">local = local || pool.locals.contains(from) // account may be local even if the transaction arrived from the network
        if !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 </span><span class="cov8" title="1">{
                gasPrice := new(big.Float).SetInt64(tx.GasPrice().Int64())
                gasPrice = gasPrice.Mul(gasPrice, new(big.Float).SetFloat64(1e-9)) // Gas-price is in Nano

                minGasPrice := new(big.Float).SetInt64(pool.gasPrice.Int64())
                minGasPrice = minGasPrice.Mul(minGasPrice, new(big.Float).SetFloat64(1e-9)) // Gas-price is in Nano
                return errors.WithMessagef(ErrUnderpriced, "transaction gas-price is %.18f ONE; minimum gas price is %.18f ONE", gasPrice, minGasPrice)
        }</span>
        // Ensure the transaction adheres to nonce ordering
        <span class="cov8" title="1">if pool.currentState.GetNonce(from) &gt; tx.Nonce() </span><span class="cov8" title="1">{
                return errors.WithMessagef(ErrNonceTooLow, "transaction nonce is %d", tx.Nonce())
        }</span>
        // Transactor should have enough funds to cover the costs
        // cost == V + GP * GL
        <span class="cov8" title="1">cost, err := tx.Cost()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">stakingTx, isStakingTx := tx.(*staking.StakingTransaction)
        if !isStakingTx || (isStakingTx &amp;&amp; stakingTx.StakingType() != staking.DirectiveDelegate) </span><span class="cov8" title="1">{
                if pool.currentState.GetBalance(from).Cmp(cost) &lt; 0 </span><span class="cov8" title="1">{
                        return errors.Wrapf(
                                ErrInsufficientFunds,
                                "current shard-id: %d",
                                pool.chain.CurrentBlock().ShardID(),
                        )
                }</span>
        }
        <span class="cov8" title="1">intrGas := uint64(0)
        if isStakingTx </span><span class="cov8" title="1">{
                intrGas, err = vm.IntrinsicGas(tx.Data(), false, pool.homestead, pool.istanbul, stakingTx.StakingType() == staking.DirectiveCreateValidator)
        }</span> else<span class="cov8" title="1"> {
                intrGas, err = vm.IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead, pool.istanbul, false)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if tx.GasLimit() &lt; intrGas </span><span class="cov8" title="1">{
                return errors.WithMessagef(ErrIntrinsicGas, "transaction gas is %d", tx.GasLimit())
        }</span>
        // Do more checks if it is a staking transaction
        <span class="cov8" title="1">if isStakingTx </span><span class="cov8" title="1">{
                return pool.validateStakingTx(stakingTx)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateStakingTx checks the staking message based on the staking directive
func (pool *TxPool) validateStakingTx(tx *staking.StakingTransaction) error <span class="cov8" title="1">{
        // from address already validated
        from, _ := tx.SenderAddress()
        b32, _ := hmyCommon.AddressToBech32(from)

        switch tx.StakingType() </span>{
        case staking.DirectiveCreateValidator:<span class="cov8" title="1">
                msg, err := staking.RLPDecodeStakeMsg(tx.Data(), staking.DirectiveCreateValidator)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">stkMsg, ok := msg.(*staking.CreateValidator)
                if !ok </span><span class="cov0" title="0">{
                        return ErrInvalidMsgForStakingDirective
                }</span>
                <span class="cov8" title="1">if from != stkMsg.ValidatorAddress </span><span class="cov0" title="0">{
                        return errors.WithMessagef(ErrInvalidSender, "staking transaction sender is %s", b32)
                }</span>
                <span class="cov8" title="1">currentBlockNumber := pool.chain.CurrentBlock().Number()
                pendingBlockNumber := new(big.Int).Add(currentBlockNumber, big.NewInt(1))
                pendingEpoch := pool.chain.CurrentBlock().Epoch()
                if shard.Schedule.IsLastBlock(currentBlockNumber.Uint64()) </span><span class="cov0" title="0">{
                        pendingEpoch = new(big.Int).Add(pendingEpoch, big.NewInt(1))
                }</span>
                <span class="cov8" title="1">chainContext, ok := pool.chain.(ChainContext)
                if !ok </span><span class="cov0" title="0">{
                        chainContext = nil // might use testing blockchain, set to nil for verifier to handle.
                }</span>
                <span class="cov8" title="1">_, err = VerifyAndCreateValidatorFromMsg(pool.currentState, chainContext, pendingEpoch, pendingBlockNumber, stkMsg)
                return err</span>
        case staking.DirectiveEditValidator:<span class="cov0" title="0">
                msg, err := staking.RLPDecodeStakeMsg(tx.Data(), staking.DirectiveEditValidator)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">stkMsg, ok := msg.(*staking.EditValidator)
                if !ok </span><span class="cov0" title="0">{
                        return ErrInvalidMsgForStakingDirective
                }</span>
                <span class="cov0" title="0">if from != stkMsg.ValidatorAddress </span><span class="cov0" title="0">{
                        return errors.WithMessagef(ErrInvalidSender, "staking transaction sender is %s", b32)
                }</span>
                <span class="cov0" title="0">chainContext, ok := pool.chain.(ChainContext)
                if !ok </span><span class="cov0" title="0">{
                        chainContext = nil // might use testing blockchain, set to nil for verifier to handle.
                }</span>
                <span class="cov0" title="0">pendingBlockNumber := new(big.Int).Add(pool.chain.CurrentBlock().Number(), big.NewInt(1))

                _, err = VerifyAndEditValidatorFromMsg(
                        pool.currentState, chainContext,
                        pool.chain.CurrentBlock().Epoch(),
                        pendingBlockNumber, stkMsg,
                )
                return err</span>
        case staking.DirectiveDelegate:<span class="cov0" title="0">
                msg, err := staking.RLPDecodeStakeMsg(tx.Data(), staking.DirectiveDelegate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">stkMsg, ok := msg.(*staking.Delegate)
                if !ok </span><span class="cov0" title="0">{
                        return ErrInvalidMsgForStakingDirective
                }</span>
                <span class="cov0" title="0">if from != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return errors.WithMessagef(ErrInvalidSender, "staking transaction sender is %s", b32)
                }</span>

                <span class="cov0" title="0">chain, ok := pool.chain.(ChainContext)
                if !ok </span><span class="cov0" title="0">{
                        utils.Logger().Debug().Msg("Missing chain context in txPool")
                        return nil // for testing, chain could be testing blockchain
                }</span>
                <span class="cov0" title="0">delegations, err := chain.ReadDelegationsByDelegator(stkMsg.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">pendingEpoch := pool.pendingEpoch()
                _, delegateAmt, _, err := VerifyAndDelegateFromMsg(
                        pool.currentState, pendingEpoch, stkMsg, delegations, pool.chainconfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // We need to deduct gas price and verify balance since txn.Cost() is not accurate for delegate
                // staking transaction because of re-delegation.
                <span class="cov0" title="0">gasAmt := new(big.Int).Mul(tx.GasPrice(), new(big.Int).SetUint64(tx.GasLimit()))
                totalAmt := new(big.Int).Add(delegateAmt, gasAmt)
                if bal := pool.currentState.GetBalance(from); bal.Cmp(totalAmt) &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("not enough balance for delegation: %v &lt; %v", bal, delegateAmt)
                }</span>
                <span class="cov0" title="0">return nil</span>
        case staking.DirectiveUndelegate:<span class="cov0" title="0">
                msg, err := staking.RLPDecodeStakeMsg(tx.Data(), staking.DirectiveUndelegate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">stkMsg, ok := msg.(*staking.Undelegate)
                if !ok </span><span class="cov0" title="0">{
                        return ErrInvalidMsgForStakingDirective
                }</span>
                <span class="cov0" title="0">if from != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return errors.WithMessagef(ErrInvalidSender, "staking transaction sender is %s", b32)
                }</span>

                <span class="cov0" title="0">_, err = VerifyAndUndelegateFromMsg(pool.currentState, pool.pendingEpoch(), stkMsg)
                return err</span>
        case staking.DirectiveCollectRewards:<span class="cov0" title="0">
                msg, err := staking.RLPDecodeStakeMsg(tx.Data(), staking.DirectiveCollectRewards)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">stkMsg, ok := msg.(*staking.CollectRewards)
                if !ok </span><span class="cov0" title="0">{
                        return ErrInvalidMsgForStakingDirective
                }</span>
                <span class="cov0" title="0">if from != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return errors.WithMessagef(ErrInvalidSender, "staking transaction sender is %s", b32)
                }</span>
                <span class="cov0" title="0">chain, ok := pool.chain.(ChainContext)
                if !ok </span><span class="cov0" title="0">{
                        utils.Logger().Debug().Msg("Missing chain context in txPool")
                        return nil // for testing, chain could be testing blockchain
                }</span>
                <span class="cov0" title="0">delegations, err := chain.ReadDelegationsByDelegator(stkMsg.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, _, err = VerifyAndCollectRewardsFromDelegation(pool.currentState, delegations)
                return err</span>
        default:<span class="cov0" title="0">
                return staking.ErrInvalidStakingKind</span>
        }
}

func (pool *TxPool) pendingEpoch() *big.Int <span class="cov0" title="0">{
        currentBlock := pool.chain.CurrentBlock()
        pendingEpoch := currentBlock.Epoch()
        if shard.Schedule.IsLastBlock(currentBlock.Number().Uint64()) </span><span class="cov0" title="0">{
                pendingEpoch.Add(pendingEpoch, big.NewInt(1))
        }</span>
        <span class="cov0" title="0">return pendingEpoch</span>
}

// add validates a transaction and inserts it into the non-executable queue for
// later pending promotion and execution. If the transaction is a replacement for
// an already pending or queued one, it overwrites the previous and returns this
// so outer code doesn't uselessly call promote.
//
// If a newly added transaction is marked as local, its sending account will be
// whitelisted, preventing any associated transaction from being dropped out of
// the pool due to pricing constraints.
func (pool *TxPool) add(tx types.PoolTransaction, local bool) (bool, error) <span class="cov8" title="1">{
        logger := utils.Logger().With().Stack().Logger()
        // If the transaction is in the error sink, remove it as it may succeed
        if pool.txErrorSink.Contains(tx.Hash().String()) </span><span class="cov8" title="1">{
                pool.txErrorSink.Remove(tx)
        }</span>
        // If the transaction is already known, discard it
        <span class="cov8" title="1">hash := tx.Hash()
        if pool.all.Get(hash) != nil </span><span class="cov0" title="0">{
                logger.Info().Str("hash", hash.Hex()).Msg("Discarding already known transaction")
                return false, errors.WithMessagef(ErrKnownTransaction, "transaction hash %x", hash)
        }</span>
        // If the transaction fails basic validation, discard it
        <span class="cov8" title="1">if err := pool.validateTx(tx, local); err != nil </span><span class="cov8" title="1">{
                logger.Warn().Err(err).Str("hash", hash.Hex()).Msg("Discarding invalid transaction")
                invalidTxCounter.Inc(1)
                return false, err
        }</span>
        // If the transaction pool is full, discard underpriced transactions
        <span class="cov8" title="1">if uint64(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue </span><span class="cov0" title="0">{
                // If the new transaction is underpriced, don't accept it
                if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) </span><span class="cov0" title="0">{
                        gasPrice := new(big.Float).SetInt64(tx.GasPrice().Int64())
                        gasPrice = gasPrice.Mul(gasPrice, new(big.Float).SetFloat64(1e-9)) // Gas-price is in Nano
                        logger.Warn().
                                Str("hash", hash.Hex()).
                                Str("price", tx.GasPrice().String()).
                                Msg("Discarding underpriced transaction")
                        underpricedTxCounter.Inc(1)
                        return false, errors.WithMessagef(ErrUnderpriced, "transaction gas-price is %.18f ONE in full transaction pool", gasPrice)
                }</span>
                // New transaction is better than our worse ones, make room for it
                <span class="cov0" title="0">drop := pool.priced.Discard(pool.all.Count()-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals)
                for _, tx := range drop </span><span class="cov0" title="0">{
                        gasPrice := new(big.Float).SetInt64(tx.GasPrice().Int64())
                        gasPrice = gasPrice.Mul(gasPrice, new(big.Float).SetFloat64(1e-9)) // Gas-price is in Nano
                        pool.removeTx(tx.Hash(), false)
                        underpricedTxCounter.Inc(1)
                        pool.txErrorSink.Add(tx,
                                errors.WithMessagef(ErrUnderpriced, "transaction gas-price is %.18f ONE in full transaction pool", gasPrice))
                        logger.Warn().
                                Str("hash", tx.Hash().Hex()).
                                Str("price", tx.GasPrice().String()).
                                Msg("Discarding freshly underpriced transaction")
                }</span>
        }
        // If the transaction is replacing an already pending one, do directly
        <span class="cov8" title="1">from, _ := tx.SenderAddress() // already validated
        if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) </span><span class="cov8" title="1">{
                // Nonce already pending, check if required price bump is met
                inserted, old := list.Add(tx, pool.config.PriceBump)
                if !inserted </span><span class="cov8" title="1">{
                        pendingDiscardCounter.Inc(1)
                        return false, errors.WithMessage(ErrReplaceUnderpriced, "existing transaction price was not bumped enough")
                }</span>
                // New transaction is better, replace old one
                <span class="cov0" title="0">if old != nil </span><span class="cov0" title="0">{
                        pool.all.Remove(old.Hash())
                        pool.priced.Removed()
                        pendingReplaceCounter.Inc(1)
                        pool.txErrorSink.Add(old,
                                fmt.Errorf("replaced transaction, new transaction %v has same nonce &amp; higher price", tx.Hash().String()))
                        logger.Info().
                                Str("hash", old.Hash().String()).
                                Str("new-tx-hash", tx.Hash().String()).
                                Str("price", old.GasPrice().String()).
                                Msg("Replaced transaction")
                }</span>
                <span class="cov0" title="0">pool.all.Add(tx)
                pool.priced.Put(tx)
                pool.journalTx(from, tx)

                // Set or refresh beat for account timeout eviction
                pool.beats[from] = time.Now()

                logger.Info().
                        Str("hash", tx.Hash().Hex()).
                        Interface("from", from).
                        Interface("to", tx.To()).
                        Str("price", tx.GasPrice().String()).
                        Msg("Pooled new executable transaction")

                // We've directly injected a replacement transaction, notify subsystems
                // go pool.txFeed.Send(NewTxsEvent{types.PoolTransactions{tx}})

                return old != nil, nil</span>
        }
        // New transaction isn't replacing a pending one, push into queue
        <span class="cov8" title="1">replace, err := pool.enqueueTx(tx)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        // Mark local addresses and journal local transactions
        <span class="cov8" title="1">if local </span><span class="cov8" title="1">{
                if !pool.locals.contains(from) </span><span class="cov8" title="1">{
                        utils.Logger().Info().Interface("address", from).Msg("Setting new local account")
                        pool.locals.add(from)
                }</span>
        }
        <span class="cov8" title="1">pool.journalTx(from, tx)

        // Set or refresh beat for account timeout eviction
        pool.beats[from] = time.Now()

        logger.Info().
                Str("hash", hash.Hex()).
                Interface("from", from).
                Interface("to", tx.To()).
                Msg("Pooled new future transaction")
        return replace, nil</span>
}

// enqueueTx inserts a new transaction into the non-executable transaction queue.
//
// Note, this method assumes the pool lock is held!
func (pool *TxPool) enqueueTx(tx types.PoolTransaction) (bool, error) <span class="cov8" title="1">{
        // Try to insert the transaction into the future queue
        from, _ := tx.SenderAddress() // already validated
        if pool.queue[from] == nil </span><span class="cov8" title="1">{
                pool.queue[from] = newTxList(false)
        }</span>
        <span class="cov8" title="1">inserted, old := pool.queue[from].Add(tx, pool.config.PriceBump)
        if !inserted </span><span class="cov0" title="0">{
                // An older transaction was better, discard this
                queuedDiscardCounter.Inc(1)
                return false, ErrReplaceUnderpriced
        }</span>
        // Discard any previous transaction and mark this
        <span class="cov8" title="1">if old != nil </span><span class="cov8" title="1">{
                pool.all.Remove(old.Hash())
                pool.priced.Removed()
                queuedReplaceCounter.Inc(1)
                pool.txErrorSink.Add(old,
                        fmt.Errorf("replaced enqueued non-executable transaction, new transaction %v has same nonce &amp; higher price", tx.Hash().String()))
                utils.Logger().Info().
                        Str("hash", old.Hash().String()).
                        Str("new-tx-hash", tx.Hash().String()).
                        Str("price", old.GasPrice().String()).
                        Msg("Replaced enqueued non-executable transaction")
        }</span>
        <span class="cov8" title="1">if pool.all.Get(tx.Hash()) == nil </span><span class="cov8" title="1">{
                pool.all.Add(tx)
                pool.priced.Put(tx)
        }</span>
        <span class="cov8" title="1">return old != nil, nil</span>
}

// journalTx adds the specified transaction to the local disk journal if it is
// deemed to have been sent from a local account.
func (pool *TxPool) journalTx(from common.Address, tx types.PoolTransaction) <span class="cov8" title="1">{
        // Only journal if it's enabled and the transaction is local
        if pool.journal == nil || !pool.locals.contains(from) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if err := pool.journal.insert(tx); err != nil </span><span class="cov0" title="0">{
                utils.Logger().Warn().Err(err).Msg("Failed to journal local transaction")
        }</span>
}

// promoteTx adds a transaction to the pending (processable) list of transactions
// and returns whether it was inserted or an older was better.
//
// Note, this method assumes the pool lock is held!
func (pool *TxPool) promoteTx(addr common.Address, tx types.PoolTransaction) bool <span class="cov8" title="1">{
        // Try to insert the transaction into the pending queue
        if pool.pending[addr] == nil </span><span class="cov8" title="1">{
                pool.pending[addr] = newTxList(true)
        }</span>
        <span class="cov8" title="1">list := pool.pending[addr]

        inserted, old := list.Add(tx, pool.config.PriceBump)
        if !inserted </span><span class="cov0" title="0">{
                // An older transaction was better, discard this
                pool.all.Remove(tx.Hash())
                pool.priced.Removed()
                pendingDiscardCounter.Inc(1)
                pool.txErrorSink.Add(tx, fmt.Errorf("could not promote to executable"))
                utils.Logger().Info().
                        Str("hash", tx.Hash().String()).
                        Msg("Could not promote to executable")
                return false
        }</span>
        // Otherwise discard any previous transaction and mark this
        <span class="cov8" title="1">if old != nil </span><span class="cov0" title="0">{
                pool.all.Remove(old.Hash())
                pool.priced.Removed()
                pendingReplaceCounter.Inc(1)
                pool.txErrorSink.Add(old,
                        fmt.Errorf("did not promote to executable, existing transaction %v has same nonce &amp; higher price", tx.Hash().String()))
                utils.Logger().Info().
                        Str("hash", old.Hash().String()).
                        Str("existing-tx-hash", tx.Hash().String()).
                        Msg("Did not promote to executable, new transaction has higher price")
        }</span>
        // Failsafe to work around direct pending inserts (tests)
        <span class="cov8" title="1">if pool.all.Get(tx.Hash()) == nil </span><span class="cov8" title="1">{
                pool.all.Add(tx)
                pool.priced.Put(tx)
        }</span>
        // Set the potentially new pending nonce and notify any subsystems of the new tx
        <span class="cov8" title="1">pool.beats[addr] = time.Now()
        pool.pendingState.SetNonce(addr, tx.Nonce()+1)

        return true</span>
}

// AddLocal enqueues a single transaction into the pool if it is valid, marking
// the sender as a local one in the mean time, ensuring it goes around the local
// pricing constraints.
func (pool *TxPool) AddLocal(tx types.PoolTransaction) error <span class="cov8" title="1">{
        return pool.addTx(tx, !pool.config.NoLocals)
}</span>

// AddRemote enqueues a single transaction into the pool if it is valid. If the
// sender is not among the locally tracked ones, full pricing constraints will
// apply.
func (pool *TxPool) AddRemote(tx types.PoolTransaction) error <span class="cov8" title="1">{
        return pool.addTx(tx, false)
}</span>

// AddLocals enqueues a batch of transactions into the pool if they are valid,
// marking the senders as a local ones in the mean time, ensuring they go around
// the local pricing constraints.
func (pool *TxPool) AddLocals(txs types.PoolTransactions) []error <span class="cov8" title="1">{
        return pool.addTxs(txs, !pool.config.NoLocals)
}</span>

// AddRemotes enqueues a batch of transactions into the pool if they are valid.
// If the senders are not among the locally tracked ones, full pricing constraints
// will apply.
func (pool *TxPool) AddRemotes(txs types.PoolTransactions) []error <span class="cov8" title="1">{
        return pool.addTxs(txs, false)
}</span>

// addTx enqueues a single transaction into the pool if it is valid.
func (pool *TxPool) addTx(tx types.PoolTransaction, local bool) error <span class="cov8" title="1">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        // Try to inject the transaction and update any state
        replace, err := pool.add(tx, local)
        if err != nil </span><span class="cov8" title="1">{
                errCause := errors.Cause(err)
                // Ignore known transaction for tx rebroadcast case.
                if errCause != ErrKnownTransaction </span><span class="cov8" title="1">{
                        pool.txErrorSink.Add(tx, err)
                }</span>
                <span class="cov8" title="1">return errCause</span>
        }
        // If we added a new transaction, run promotion checks and return
        <span class="cov8" title="1">if !replace </span><span class="cov8" title="1">{
                from, _ := tx.SenderAddress() // already validated
                pool.promoteExecutables([]common.Address{from})
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// addTxs attempts to queue a batch of transactions if they are valid.
func (pool *TxPool) addTxs(txs types.PoolTransactions, local bool) []error <span class="cov8" title="1">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        return pool.addTxsLocked(txs, local)
}</span>

// addTxsLocked attempts to queue a batch of transactions if they are valid,
// whilst assuming the transaction pool lock is already held.
func (pool *TxPool) addTxsLocked(txs types.PoolTransactions, local bool) []error <span class="cov8" title="1">{
        // Add the batch of transaction, tracking the accepted ones
        dirty := map[common.Address]struct{}{}
        errs := make([]error, txs.Len())

        for i, tx := range txs </span><span class="cov8" title="1">{
                replace, err := pool.add(tx, local)
                if err == nil &amp;&amp; !replace </span><span class="cov8" title="1">{
                        from, _ := tx.SenderAddress() // already validated
                        dirty[from] = struct{}{}
                }</span>
                <span class="cov8" title="1">errCause := errors.Cause(err)
                // Ignore known transaction for tx rebroadcast case.
                if err != nil &amp;&amp; errCause != ErrKnownTransaction </span><span class="cov8" title="1">{
                        pool.txErrorSink.Add(tx, err)
                }</span>
                <span class="cov8" title="1">errs[i] = errCause</span>
        }
        // Only reprocess the internal state if something was actually added
        <span class="cov8" title="1">if len(dirty) &gt; 0 </span><span class="cov8" title="1">{
                addrs := make([]common.Address, len(dirty))
                i := 0
                for addr := range dirty </span><span class="cov8" title="1">{
                        addrs[i] = addr
                        i++
                }</span>
                <span class="cov8" title="1">pool.promoteExecutables(addrs)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Status returns the status (unknown/pending/queued) of a batch of transactions
// identified by their hashes.
func (pool *TxPool) Status(hashes []common.Hash) []TxStatus <span class="cov8" title="1">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()

        status := make([]TxStatus, len(hashes))
        for i, hash := range hashes </span><span class="cov8" title="1">{
                if tx := pool.all.Get(hash); tx != nil </span><span class="cov8" title="1">{
                        from, _ := tx.SenderAddress() // already validated
                        if pool.pending[from] != nil &amp;&amp; pool.pending[from].txs.items[tx.Nonce()] != nil </span><span class="cov8" title="1">{
                                status[i] = TxStatusPending
                        }</span> else<span class="cov8" title="1"> {
                                status[i] = TxStatusQueued
                        }</span>
                }
        }
        <span class="cov8" title="1">return status</span>
}

// Get returns a transaction if it is contained in the pool
// and nil otherwise.
func (pool *TxPool) Get(hash common.Hash) types.PoolTransaction <span class="cov0" title="0">{
        return pool.all.Get(hash)
}</span>

// removeTx removes a single transaction from the queue, moving all subsequent
// transactions back to the future queue.
func (pool *TxPool) removeTx(hash common.Hash, outofbound bool) <span class="cov8" title="1">{
        // Fetch the transaction we wish to delete
        tx := pool.all.Get(hash)
        if tx == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">addr, _ := tx.SenderAddress() // already validated during insertion

        // Remove it from the list of known transactions
        pool.all.Remove(hash)
        if outofbound </span><span class="cov8" title="1">{
                pool.priced.Removed()
        }</span>
        // Remove the transaction from the pending lists and reset the account nonce
        <span class="cov8" title="1">if pending := pool.pending[addr]; pending != nil </span><span class="cov0" title="0">{
                if removed, invalids := pending.Remove(tx); removed </span><span class="cov0" title="0">{
                        // If no more pending transactions are left, remove the list
                        if pending.Empty() </span><span class="cov0" title="0">{
                                delete(pool.pending, addr)
                                delete(pool.beats, addr)
                        }</span>
                        // Postpone any invalidated transactions
                        <span class="cov0" title="0">for _, tx := range invalids </span><span class="cov0" title="0">{
                                if _, err := pool.enqueueTx(tx); err != nil </span><span class="cov0" title="0">{
                                        pool.txErrorSink.Add(tx, err)
                                }</span>
                        }
                        // Update the account nonce if needed
                        <span class="cov0" title="0">if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce </span><span class="cov0" title="0">{
                                pool.pendingState.SetNonce(addr, nonce)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
        // Transaction is in the future queue
        <span class="cov8" title="1">if future := pool.queue[addr]; future != nil </span><span class="cov8" title="1">{
                future.Remove(tx)
                if future.Empty() </span><span class="cov8" title="1">{
                        delete(pool.queue, addr)
                }</span>
        }
}

// promoteExecutables moves transactions that have become processable from the
// future queue to the set of pending transactions. During this process, all
// invalidated transactions (low nonce, low balance) are deleted.
func (pool *TxPool) promoteExecutables(accounts []common.Address) <span class="cov8" title="1">{
        // Track the promoted transactions to broadcast them at once
        var promoted []types.PoolTransaction
        logger := utils.Logger().With().Stack().Logger()

        // Gather all the accounts potentially needing updates
        if accounts == nil </span><span class="cov8" title="1">{
                accounts = make([]common.Address, len(pool.queue))
                i := 0
                for addr := range pool.queue </span><span class="cov8" title="1">{
                        accounts[i] = addr
                        i++
                }</span>
        }
        // Iterate over all accounts and promote any executable transactions
        <span class="cov8" title="1">for _, addr := range accounts </span><span class="cov8" title="1">{
                list := pool.queue[addr]
                if list == nil </span><span class="cov8" title="1">{
                        continue</span> // Just in case someone calls with a non existing account
                }
                // Drop all transactions that are deemed too old (low nonce)
                <span class="cov8" title="1">nonce := pool.currentState.GetNonce(addr)
                for _, tx := range list.Forward(nonce) </span><span class="cov8" title="1">{
                        hash := tx.Hash()
                        pool.all.Remove(hash)
                        pool.priced.Removed()
                        logger.Debug().Str("hash", hash.Hex()).Msg("Removed old queued transaction")
                        // Do not report to error sink as old txs are on chain or meaningful error caught elsewhere.
                }</span>
                // Drop all transactions that are too costly (low balance or out of gas)
                <span class="cov8" title="1">drops, errs, _ := list.FilterValid(pool, addr, 0)
                for i, tx := range drops </span><span class="cov8" title="1">{
                        hash := tx.Hash()
                        pool.all.Remove(hash)
                        pool.priced.Removed()
                        queuedNofundsCounter.Inc(1)
                        pool.txErrorSink.Add(tx, errs[i])
                        logger.Warn().Str("hash", hash.Hex()).Err(errs[i]).
                                Msg("Removed unpayable queued transaction")
                }</span>
                // Gather all executable transactions and promote them
                <span class="cov8" title="1">for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) </span><span class="cov8" title="1">{
                        hash := tx.Hash()
                        if pool.promoteTx(addr, tx) </span><span class="cov8" title="1">{
                                logger.Info().Str("hash", hash.Hex()).Msg("Promoting queued transaction")
                                promoted = append(promoted, tx)
                        }</span>
                }
                // Drop all transactions over the allowed limit
                <span class="cov8" title="1">if !pool.locals.contains(addr) </span><span class="cov8" title="1">{
                        for _, tx := range list.Cap(int(pool.config.AccountQueue)) </span><span class="cov8" title="1">{
                                hash := tx.Hash()
                                pool.all.Remove(hash)
                                pool.priced.Removed()
                                queuedRateLimitCounter.Inc(1)
                                pool.txErrorSink.Add(tx, fmt.Errorf("exceeds cap for queued transactions for account %s", addr.String()))
                                logger.Warn().Str("hash", hash.Hex()).Msg("Removed cap-exceeding queued transaction")
                        }</span>
                }
                // Delete the entire queue entry if it became empty.
                <span class="cov8" title="1">if list.Empty() </span><span class="cov8" title="1">{
                        delete(pool.queue, addr)
                }</span>
        }
        // Notify subsystem for new promoted transactions.
        <span class="cov8" title="1">if len(promoted) &gt; 0 </span><span class="cov8" title="1">{
                go pool.txFeed.Send(NewTxsEvent{promoted})
        }</span>
        // If the pending limit is overflown, start equalizing allowances
        <span class="cov8" title="1">pending := uint64(0)
        for _, list := range pool.pending </span><span class="cov8" title="1">{
                pending += uint64(list.Len())
        }</span>
        <span class="cov8" title="1">if pending &gt; pool.config.GlobalSlots </span><span class="cov0" title="0">{
                pendingBeforeCap := pending
                // Assemble a spam order to penalize large transactors first
                spammers := prque.New(nil)
                for addr, list := range pool.pending </span><span class="cov0" title="0">{
                        // Only evict transactions from high rollers
                        if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots </span><span class="cov0" title="0">{
                                spammers.Push(addr, int64(list.Len()))
                        }</span>
                }
                // Gradually drop transactions from offenders
                <span class="cov0" title="0">offenders := []common.Address{}
                for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() </span><span class="cov0" title="0">{
                        // Retrieve the next offender if not local address
                        offender, _ := spammers.Pop()
                        offenders = append(offenders, offender.(common.Address))

                        // Equalize balances until all the same or below threshold
                        if len(offenders) &gt; 1 </span><span class="cov0" title="0">{
                                // Calculate the equalization threshold for all current offenders
                                threshold := pool.pending[offender.(common.Address)].Len()

                                // Iteratively reduce all offenders until below limit or threshold reached
                                for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold </span><span class="cov0" title="0">{
                                        for i := 0; i &lt; len(offenders)-1; i++ </span><span class="cov0" title="0">{
                                                list := pool.pending[offenders[i]]
                                                for _, tx := range list.Cap(list.Len() - 1) </span><span class="cov0" title="0">{
                                                        // Drop the transaction from the global pools too
                                                        hash := tx.Hash()
                                                        pool.all.Remove(hash)
                                                        pool.priced.Removed()
                                                        pool.txErrorSink.Add(tx, fmt.Errorf("fairness-exceeding pending transaction"))

                                                        // Update the account nonce to the dropped transaction
                                                        if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce </span><span class="cov0" title="0">{
                                                                pool.pendingState.SetNonce(offenders[i], nonce)
                                                        }</span>
                                                        <span class="cov0" title="0">logger.Warn().Str("hash", hash.Hex()).Msg("Removed fairness-exceeding pending transaction")</span>
                                                }
                                                <span class="cov0" title="0">pending--</span>
                                        }
                                }
                        }
                }
                // If still above threshold, reduce to limit or min allowance
                <span class="cov0" title="0">if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 </span><span class="cov0" title="0">{
                        for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots </span><span class="cov0" title="0">{
                                for _, addr := range offenders </span><span class="cov0" title="0">{
                                        list := pool.pending[addr]
                                        for _, tx := range list.Cap(list.Len() - 1) </span><span class="cov0" title="0">{
                                                // Drop the transaction from the global pools too
                                                hash := tx.Hash()
                                                pool.all.Remove(hash)
                                                pool.priced.Removed()
                                                pool.txErrorSink.Add(tx, fmt.Errorf("fairness-exceeding pending transaction"))

                                                // Update the account nonce to the dropped transaction
                                                if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce </span><span class="cov0" title="0">{
                                                        pool.pendingState.SetNonce(addr, nonce)
                                                }</span>
                                                <span class="cov0" title="0">logger.Warn().Str("hash", hash.Hex()).Msg("Removed fairness-exceeding pending transaction")</span>
                                        }
                                        <span class="cov0" title="0">pending--</span>
                                }
                        }
                }
                <span class="cov0" title="0">pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending))</span>
        }
        // If we've queued more transactions than the hard limit, drop oldest ones
        <span class="cov8" title="1">queued := uint64(0)
        for _, list := range pool.queue </span><span class="cov8" title="1">{
                queued += uint64(list.Len())
        }</span>
        <span class="cov8" title="1">if queued &gt; pool.config.GlobalQueue </span><span class="cov8" title="1">{
                // Sort all accounts with queued transactions by heartbeat
                addresses := make(addressesByHeartbeat, 0, len(pool.queue))
                for addr := range pool.queue </span><span class="cov8" title="1">{
                        if !pool.locals.contains(addr) </span><span class="cov8" title="1">{ // don't drop locals
                                addresses = append(addresses, addressByHeartbeat{addr, pool.beats[addr]})
                        }</span>
                }
                <span class="cov8" title="1">sort.Sort(addresses)

                // Drop transactions until the total is below the limit or only locals remain
                for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; </span><span class="cov8" title="1">{
                        addr := addresses[len(addresses)-1]
                        list := pool.queue[addr.address]

                        addresses = addresses[:len(addresses)-1]

                        // Drop all transactions if they are less than the overflow
                        if size := uint64(list.Len()); size &lt;= drop </span><span class="cov8" title="1">{
                                for _, tx := range list.Flatten() </span><span class="cov8" title="1">{
                                        pool.txErrorSink.Add(tx, fmt.Errorf("exceeds global cap for queued transactions"))
                                        pool.removeTx(tx.Hash(), true)
                                }</span>
                                <span class="cov8" title="1">drop -= size
                                queuedRateLimitCounter.Inc(int64(size))
                                continue</span>
                        }
                        // Otherwise drop only last few transactions
                        <span class="cov8" title="1">txs := list.Flatten()
                        for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- </span><span class="cov8" title="1">{
                                pool.txErrorSink.Add(txs[i], fmt.Errorf("exceeds global cap for queued transactions"))
                                pool.removeTx(txs[i].Hash(), true)
                                drop--
                                queuedRateLimitCounter.Inc(1)
                        }</span>
                }
        }
}

// demoteUnexecutables removes invalid and processed transactions from the pools
// executable/pending queue and any subsequent transactions that become unexecutable
// are moved back into the future queue.
func (pool *TxPool) demoteUnexecutables(bn uint64) <span class="cov8" title="1">{
        // Iterate over all accounts and demote any non-executable transactions
        logger := utils.Logger().With().Stack().Logger()

        for addr, list := range pool.pending </span><span class="cov8" title="1">{
                nonce := pool.currentState.GetNonce(addr)

                // Drop all transactions that are deemed too old (low nonce)
                for _, tx := range list.Forward(nonce) </span><span class="cov8" title="1">{
                        hash := tx.Hash()
                        pool.all.Remove(hash)
                        pool.priced.Removed()
                        logger.Debug().Str("hash", hash.Hex()).Msg("Removed old pending transaction")
                        // Do not report to error sink as old txs are on chain or meaningful error caught elsewhere.
                }</span>
                // Drop all transactions that are too costly (low balance or out of gas), and queue any invalids back for later
                <span class="cov8" title="1">drops, errs, invalids := list.FilterValid(pool, addr, bn)
                for i, tx := range drops </span><span class="cov8" title="1">{
                        hash := tx.Hash()
                        pool.all.Remove(hash)
                        pool.priced.Removed()
                        pendingNofundsCounter.Inc(1)
                        pool.txErrorSink.Add(tx, errs[i])
                        logger.Warn().Str("hash", hash.Hex()).Err(errs[i]).
                                Msg("Removed unexecutable pending transaction")
                }</span>
                <span class="cov8" title="1">for _, tx := range invalids </span><span class="cov8" title="1">{
                        hash := tx.Hash()
                        logger.Warn().Str("hash", hash.Hex()).Msg("Demoting pending transaction")
                        if _, err := pool.enqueueTx(tx); err != nil </span><span class="cov0" title="0">{
                                pool.txErrorSink.Add(tx, err)
                        }</span>
                }
                // If there's a gap in front, alert (should never happen)
                <span class="cov8" title="1">if list.Len() &gt; 0 &amp;&amp; list.txs.Get(nonce) == nil </span><span class="cov8" title="1">{
                        for _, tx := range list.Cap(0) </span><span class="cov8" title="1">{
                                hash := tx.Hash()
                                logger.Error().Str("hash", hash.Hex()).Msg("Demoting invalidated transaction")
                                if _, err := pool.enqueueTx(tx); err != nil </span><span class="cov0" title="0">{
                                        pool.txErrorSink.Add(tx, err)
                                }</span>
                        }
                }
                // Delete the entire queue entry if it became empty.
                <span class="cov8" title="1">if list.Empty() </span><span class="cov8" title="1">{
                        delete(pool.pending, addr)
                        delete(pool.beats, addr)
                }</span>
        }
}

// addressByHeartbeat is an account address tagged with its last activity timestamp.
type addressByHeartbeat struct {
        address   common.Address
        heartbeat time.Time
}

type addressesByHeartbeat []addressByHeartbeat

func (a addressesByHeartbeat) Len() int           <span class="cov8" title="1">{ return len(a) }</span>
func (a addressesByHeartbeat) Less(i, j int) bool <span class="cov8" title="1">{ return a[i].heartbeat.Before(a[j].heartbeat) }</span>
func (a addressesByHeartbeat) Swap(i, j int)      <span class="cov8" title="1">{ a[i], a[j] = a[j], a[i] }</span>

// accountSet is simply a set of addresses to check for existence, and a signer
// capable of deriving addresses from transactions.
type accountSet struct {
        accounts map[common.Address]struct{}
        signer   types.Signer
        cache    *[]common.Address
}

// newAccountSet creates a new address set with the associated signer.
// Note that tx pool will never see an unprotected tx, therefore can use only EIP155 signer.
func newAccountSet(chainID *big.Int) *accountSet <span class="cov8" title="1">{
        return &amp;accountSet{
                accounts: make(map[common.Address]struct{}),
                signer:   types.NewEIP155Signer(chainID),
        }
}</span>

// contains checks if a given address is contained within the set.
func (as *accountSet) contains(addr common.Address) bool <span class="cov8" title="1">{
        _, exist := as.accounts[addr]
        return exist
}</span>

// containsTx checks if the sender of a given tx is within the set. If the sender
// cannot be derived, this method returns false.
func (as *accountSet) containsTx(tx types.PoolTransaction) bool <span class="cov8" title="1">{
        if addr, err := tx.SenderAddress(); err == nil </span><span class="cov8" title="1">{
                return as.contains(addr)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// add inserts a new address into the set to track.
func (as *accountSet) add(addr common.Address) <span class="cov8" title="1">{
        as.accounts[addr] = struct{}{}
        as.cache = nil
}</span>

// flatten returns the list of addresses within this set, also caching it for later
// reuse. The returned slice should not be changed!
func (as *accountSet) flatten() []common.Address <span class="cov0" title="0">{
        if as.cache == nil </span><span class="cov0" title="0">{
                accounts := make([]common.Address, 0, len(as.accounts))
                for account := range as.accounts </span><span class="cov0" title="0">{
                        accounts = append(accounts, account)
                }</span>
                <span class="cov0" title="0">as.cache = &amp;accounts</span>
        }
        <span class="cov0" title="0">return *as.cache</span>
}

// txLookup is used internally by TxPool to track transactions while allowing lookup without
// mutex contention.
//
// Note, although this type is properly protected against concurrent access, it
// is **not** a type that should ever be mutated or even exposed outside of the
// transaction pool, since its internal state is tightly coupled with the pools
// internal mechanisms. The sole purpose of the type is to permit out-of-bound
// peeking into the pool in TxPool.Get without having to acquire the widely scoped
// TxPool.mu mutex.
type txLookup struct {
        all  map[common.Hash]types.PoolTransaction
        lock sync.RWMutex
}

// newTxLookup returns a new txLookup structure.
func newTxLookup() *txLookup <span class="cov8" title="1">{
        return &amp;txLookup{
                all: make(map[common.Hash]types.PoolTransaction),
        }
}</span>

// Range calls f on each key and value present in the map.
func (t *txLookup) Range(f func(hash common.Hash, tx types.PoolTransaction) bool) <span class="cov8" title="1">{
        t.lock.RLock()
        defer t.lock.RUnlock()

        for key, value := range t.all </span><span class="cov8" title="1">{
                if !f(key, value) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

// Get returns a transaction if it exists in the lookup, or nil if not found.
func (t *txLookup) Get(hash common.Hash) types.PoolTransaction <span class="cov8" title="1">{
        t.lock.RLock()
        defer t.lock.RUnlock()

        return t.all[hash]
}</span>

// Count returns the current number of items in the lookup.
func (t *txLookup) Count() int <span class="cov8" title="1">{
        t.lock.RLock()
        defer t.lock.RUnlock()

        return len(t.all)
}</span>

// Add adds a transaction to the lookup.
func (t *txLookup) Add(tx types.PoolTransaction) <span class="cov8" title="1">{
        t.lock.Lock()
        defer t.lock.Unlock()

        t.all[tx.Hash()] = tx
}</span>

// Remove removes a transaction from the lookup.
func (t *txLookup) Remove(hash common.Hash) <span class="cov8" title="1">{
        t.lock.Lock()
        defer t.lock.Unlock()

        delete(t.all, hash)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package vm

import (
        "crypto/sha256"
        "encoding/binary"
        "errors"
        "fmt"
        "math/big"

        "github.com/ethereum/go-ethereum/crypto/blake2b"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/math"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/crypto/bn256"
        "github.com/harmony-one/harmony/internal/params"
        "golang.org/x/crypto/ripemd160"

        //Needed for SHA3-256 FIPS202
        "encoding/hex"

        "golang.org/x/crypto/sha3"
)

// PrecompiledContract is the basic interface for native Go contracts. The implementation
// requires a deterministic gas count based on the input size of the Run method of the
// contract.
type PrecompiledContract interface {
        RequiredGas(input []byte) uint64  // RequiredPrice calculates the contract gas use
        Run(input []byte) ([]byte, error) // Run runs the precompiled contract
}

// PrecompiledContractsHomestead contains the default set of pre-compiled Ethereum
// contracts used in the Frontier and Homestead releases.
var PrecompiledContractsHomestead = map[common.Address]PrecompiledContract{
        common.BytesToAddress([]byte{1}): &amp;ecrecover{},
        common.BytesToAddress([]byte{2}): &amp;sha256hash{},
        common.BytesToAddress([]byte{3}): &amp;ripemd160hash{},
        common.BytesToAddress([]byte{4}): &amp;dataCopy{},
}

// PrecompiledContractsByzantium contains the default set of pre-compiled Ethereum
// contracts used in the Byzantium release.
var PrecompiledContractsByzantium = map[common.Address]PrecompiledContract{
        common.BytesToAddress([]byte{1}): &amp;ecrecover{},
        common.BytesToAddress([]byte{2}): &amp;sha256hash{},
        common.BytesToAddress([]byte{3}): &amp;ripemd160hash{},
        common.BytesToAddress([]byte{4}): &amp;dataCopy{},
        common.BytesToAddress([]byte{5}): &amp;bigModExp{},
        common.BytesToAddress([]byte{6}): &amp;bn256AddByzantium{},
        common.BytesToAddress([]byte{7}): &amp;bn256ScalarMulByzantium{},
        common.BytesToAddress([]byte{8}): &amp;bn256PairingByzantium{},
}

// PrecompiledContractsIstanbul contains the default set of pre-compiled Ethereum
// contracts used in the Istanbul release.
var PrecompiledContractsIstanbul = map[common.Address]PrecompiledContract{
        common.BytesToAddress([]byte{1}): &amp;ecrecover{},
        common.BytesToAddress([]byte{2}): &amp;sha256hash{},
        common.BytesToAddress([]byte{3}): &amp;ripemd160hash{},
        common.BytesToAddress([]byte{4}): &amp;dataCopy{},
        common.BytesToAddress([]byte{5}): &amp;bigModExp{},
        common.BytesToAddress([]byte{6}): &amp;bn256AddIstanbul{},
        common.BytesToAddress([]byte{7}): &amp;bn256ScalarMulIstanbul{},
        common.BytesToAddress([]byte{8}): &amp;bn256PairingIstanbul{},
        common.BytesToAddress([]byte{9}): &amp;blake2F{},
}

// PrecompiledContractsIstanbul contains the default set of pre-compiled Ethereum
// contracts used in the Istanbul release.
var PrecompiledContractsVRF = map[common.Address]PrecompiledContract{
        common.BytesToAddress([]byte{1}):   &amp;ecrecover{},
        common.BytesToAddress([]byte{2}):   &amp;sha256hash{},
        common.BytesToAddress([]byte{3}):   &amp;ripemd160hash{},
        common.BytesToAddress([]byte{4}):   &amp;dataCopy{},
        common.BytesToAddress([]byte{5}):   &amp;bigModExp{},
        common.BytesToAddress([]byte{6}):   &amp;bn256AddIstanbul{},
        common.BytesToAddress([]byte{7}):   &amp;bn256ScalarMulIstanbul{},
        common.BytesToAddress([]byte{8}):   &amp;bn256PairingIstanbul{},
        common.BytesToAddress([]byte{9}):   &amp;blake2F{},
        common.BytesToAddress([]byte{255}): &amp;vrf{},
}

// PrecompiledContractsSHA3FIPS contains the default set of pre-compiled Ethereum
// contracts used in the Istanbul release. plus VRF  and SHA3FIPS-202 standard
var PrecompiledContractsSHA3FIPS = map[common.Address]PrecompiledContract{
        common.BytesToAddress([]byte{1}):   &amp;ecrecover{},
        common.BytesToAddress([]byte{2}):   &amp;sha256hash{},
        common.BytesToAddress([]byte{3}):   &amp;ripemd160hash{},
        common.BytesToAddress([]byte{4}):   &amp;dataCopy{},
        common.BytesToAddress([]byte{5}):   &amp;bigModExp{},
        common.BytesToAddress([]byte{6}):   &amp;bn256AddIstanbul{},
        common.BytesToAddress([]byte{7}):   &amp;bn256ScalarMulIstanbul{},
        common.BytesToAddress([]byte{8}):   &amp;bn256PairingIstanbul{},
        common.BytesToAddress([]byte{9}):   &amp;blake2F{},
        common.BytesToAddress([]byte{255}): &amp;vrf{},

        common.BytesToAddress([]byte{253}): &amp;sha3fip{},
        common.BytesToAddress([]byte{254}): &amp;ecrecoverPublicKey{},
}

// PrecompiledContractsStaking contains the default set of pre-compiled Ethereum
// contracts used in the Istanbul release. plus VRF, SHA3FIPS-202 and staking precompiles
// These are available in the EVM after the StakingPrecompileEpoch
var PrecompiledContractsStaking = map[common.Address]PrecompiledContract{
        common.BytesToAddress([]byte{1}): &amp;ecrecover{},
        common.BytesToAddress([]byte{2}): &amp;sha256hash{},
        common.BytesToAddress([]byte{3}): &amp;ripemd160hash{},
        common.BytesToAddress([]byte{4}): &amp;dataCopy{},
        common.BytesToAddress([]byte{5}): &amp;bigModExp{},
        common.BytesToAddress([]byte{6}): &amp;bn256AddIstanbul{},
        common.BytesToAddress([]byte{7}): &amp;bn256ScalarMulIstanbul{},
        common.BytesToAddress([]byte{8}): &amp;bn256PairingIstanbul{},
        common.BytesToAddress([]byte{9}): &amp;blake2F{},

        common.BytesToAddress([]byte{250}): &amp;epoch{},
        common.BytesToAddress([]byte{251}): nil,
        common.BytesToAddress([]byte{252}): nil, // used by WriteCapablePrecompiledContractsStaking
        // marked nil to ensure no overwrite
        common.BytesToAddress([]byte{253}): &amp;sha3fip{},
        common.BytesToAddress([]byte{254}): &amp;ecrecoverPublicKey{},
        common.BytesToAddress([]byte{255}): &amp;vrf{},
}

func init() <span class="cov8" title="1">{
        // check that there is no overlap, and panic if there is
        readOnlyContracts := PrecompiledContractsStaking
        writeCapableContracts := WriteCapablePrecompiledContractsStaking
        for address, readOnlyContract := range readOnlyContracts </span><span class="cov8" title="1">{
                if readOnlyContract != nil &amp;&amp; writeCapableContracts[address] != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Address %v is included in both readOnlyContracts and writeCapableContracts", address))</span>
                }
        }
        <span class="cov8" title="1">for address, writeCapableContract := range writeCapableContracts </span><span class="cov8" title="1">{
                if writeCapableContract != nil &amp;&amp; readOnlyContracts[address] != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Address %v is included in both readOnlyContracts and writeCapableContracts", address))</span>
                }
        }
}

// RunPrecompiledContract runs and evaluates the output of a precompiled contract.
func RunPrecompiledContract(p PrecompiledContract, input []byte, contract *Contract) (ret []byte, err error) <span class="cov8" title="1">{
        gas := p.RequiredGas(input)
        if contract.UseGas(gas) </span><span class="cov8" title="1">{
                return p.Run(input)
        }</span>
        <span class="cov8" title="1">return nil, ErrOutOfGas</span>
}

// ECRECOVER implemented as a native contract.
type ecrecover struct{}

func (c *ecrecover) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        return params.EcrecoverGas
}</span>

func (c *ecrecover) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        const ecRecoverInputLength = 128

        input = common.RightPadBytes(input, ecRecoverInputLength)
        // "input" is (hash, v, r, s), each 32 bytes
        // but for ecrecover we want (r, s, v)

        r := new(big.Int).SetBytes(input[64:96])
        s := new(big.Int).SetBytes(input[96:128])
        v := input[63] - 27

        // tighter sig s values input homestead only apply to tx sigs
        if !allZero(input[32:63]) || !crypto.ValidateSignatureValues(v, r, s, false) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        // We must make sure not to modify the 'input', so placing the 'v' along with
        // the signature needs to be done on a new allocation
        <span class="cov8" title="1">sig := make([]byte, 65)
        copy(sig, input[64:128])
        sig[64] = v
        // v needs to be at the end for libsecp256k1
        pubKey, err := crypto.Ecrecover(input[:32], sig)
        // make sure the public key is a valid one
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // the first byte of pubkey is bitcoin heritage
        <span class="cov8" title="1">return common.LeftPadBytes(crypto.Keccak256(pubKey[1:])[12:], 32), nil</span>
}

// SHA256 implemented as a native contract.
type sha256hash struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *sha256hash) RequiredGas(input []byte) uint64 <span class="cov0" title="0">{
        return uint64(len(input)+31)/32*params.Sha256PerWordGas + params.Sha256BaseGas
}</span>
func (c *sha256hash) Run(input []byte) ([]byte, error) <span class="cov0" title="0">{
        h := sha256.Sum256(input)
        return h[:], nil
}</span>

// RIPEMD160 implemented as a native contract.
type ripemd160hash struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *ripemd160hash) RequiredGas(input []byte) uint64 <span class="cov0" title="0">{
        return uint64(len(input)+31)/32*params.Ripemd160PerWordGas + params.Ripemd160BaseGas
}</span>
func (c *ripemd160hash) Run(input []byte) ([]byte, error) <span class="cov0" title="0">{
        ripemd := ripemd160.New()
        ripemd.Write(input)
        return common.LeftPadBytes(ripemd.Sum(nil), 32), nil
}</span>

// data copy implemented as a native contract.
type dataCopy struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *dataCopy) RequiredGas(input []byte) uint64 <span class="cov0" title="0">{
        return uint64(len(input)+31)/32*params.IdentityPerWordGas + params.IdentityBaseGas
}</span>
func (c *dataCopy) Run(in []byte) ([]byte, error) <span class="cov0" title="0">{
        return in, nil
}</span>

// bigModExp implements a native big integer exponential modular operation.
type bigModExp struct{}

var (
        big1      = big.NewInt(1)
        big4      = big.NewInt(4)
        big8      = big.NewInt(8)
        big16     = big.NewInt(16)
        big32     = big.NewInt(32)
        big64     = big.NewInt(64)
        big96     = big.NewInt(96)
        big480    = big.NewInt(480)
        big1024   = big.NewInt(1024)
        big3072   = big.NewInt(3072)
        big199680 = big.NewInt(199680)
)

// RequiredGas returns the gas required to execute the pre-compiled contract.
func (c *bigModExp) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        var (
                baseLen = new(big.Int).SetBytes(getData(input, 0, 32))
                expLen  = new(big.Int).SetBytes(getData(input, 32, 32))
                modLen  = new(big.Int).SetBytes(getData(input, 64, 32))
        )
        if len(input) &gt; 96 </span><span class="cov8" title="1">{
                input = input[96:]
        }</span> else<span class="cov0" title="0"> {
                input = input[:0]
        }</span>
        // Retrieve the head 32 bytes of exp for the adjusted exponent length
        <span class="cov8" title="1">var expHead *big.Int
        if big.NewInt(int64(len(input))).Cmp(baseLen) &lt;= 0 </span><span class="cov0" title="0">{
                expHead = new(big.Int)
        }</span> else<span class="cov8" title="1"> {
                if expLen.Cmp(big32) &gt; 0 </span><span class="cov0" title="0">{
                        expHead = new(big.Int).SetBytes(getData(input, baseLen.Uint64(), 32))
                }</span> else<span class="cov8" title="1"> {
                        expHead = new(big.Int).SetBytes(getData(input, baseLen.Uint64(), expLen.Uint64()))
                }</span>
        }
        // Calculate the adjusted exponent length
        <span class="cov8" title="1">var msb int
        if bitlen := expHead.BitLen(); bitlen &gt; 0 </span><span class="cov8" title="1">{
                msb = bitlen - 1
        }</span>
        <span class="cov8" title="1">adjExpLen := new(big.Int)
        if expLen.Cmp(big32) &gt; 0 </span><span class="cov0" title="0">{
                adjExpLen.Sub(expLen, big32)
                adjExpLen.Mul(big8, adjExpLen)
        }</span>
        <span class="cov8" title="1">adjExpLen.Add(adjExpLen, big.NewInt(int64(msb)))

        // Calculate the gas cost of the operation
        gas := new(big.Int).Set(math.BigMax(modLen, baseLen))
        switch </span>{
        case gas.Cmp(big64) &lt;= 0:<span class="cov8" title="1">
                gas.Mul(gas, gas)</span>
        case gas.Cmp(big1024) &lt;= 0:<span class="cov8" title="1">
                gas = new(big.Int).Add(
                        new(big.Int).Div(new(big.Int).Mul(gas, gas), big4),
                        new(big.Int).Sub(new(big.Int).Mul(big96, gas), big3072),
                )</span>
        default:<span class="cov0" title="0">
                gas = new(big.Int).Add(
                        new(big.Int).Div(new(big.Int).Mul(gas, gas), big16),
                        new(big.Int).Sub(new(big.Int).Mul(big480, gas), big199680),
                )</span>
        }
        <span class="cov8" title="1">gas.Mul(gas, math.BigMax(adjExpLen, big1))
        gas.Div(gas, new(big.Int).SetUint64(params.ModExpQuadCoeffDiv))

        if gas.BitLen() &gt; 64 </span><span class="cov0" title="0">{
                return math.MaxUint64
        }</span>
        <span class="cov8" title="1">return gas.Uint64()</span>
}

func (c *bigModExp) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        var (
                baseLen = new(big.Int).SetBytes(getData(input, 0, 32)).Uint64()
                expLen  = new(big.Int).SetBytes(getData(input, 32, 32)).Uint64()
                modLen  = new(big.Int).SetBytes(getData(input, 64, 32)).Uint64()
        )
        if len(input) &gt; 96 </span><span class="cov8" title="1">{
                input = input[96:]
        }</span> else<span class="cov0" title="0"> {
                input = input[:0]
        }</span>
        // Handle a special case when both the base and mod length is zero
        <span class="cov8" title="1">if baseLen == 0 &amp;&amp; modLen == 0 </span><span class="cov0" title="0">{
                return []byte{}, nil
        }</span>
        // Retrieve the operands and execute the exponentiation
        <span class="cov8" title="1">var (
                base = new(big.Int).SetBytes(getData(input, 0, baseLen))
                exp  = new(big.Int).SetBytes(getData(input, baseLen, expLen))
                mod  = new(big.Int).SetBytes(getData(input, baseLen+expLen, modLen))
        )
        if mod.BitLen() == 0 </span><span class="cov0" title="0">{
                // Modulo 0 is undefined, return zero
                return common.LeftPadBytes([]byte{}, int(modLen)), nil
        }</span>
        <span class="cov8" title="1">return common.LeftPadBytes(base.Exp(base, exp, mod).Bytes(), int(modLen)), nil</span>
}

// newCurvePoint unmarshals a binary blob into a bn256 elliptic curve point,
// returning it, or an error if the point is invalid.
func newCurvePoint(blob []byte) (*bn256.G1, error) <span class="cov8" title="1">{
        p := new(bn256.G1)
        if _, err := p.Unmarshal(blob); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return p, nil</span>
}

// newTwistPoint unmarshals a binary blob into a bn256 elliptic curve point,
// returning it, or an error if the point is invalid.
func newTwistPoint(blob []byte) (*bn256.G2, error) <span class="cov8" title="1">{
        p := new(bn256.G2)
        if _, err := p.Unmarshal(blob); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return p, nil</span>
}

// runBn256Add implements the Bn256Add precompile, referenced by both
// Byzantium and Istanbul operations.
func runBn256Add(input []byte) ([]byte, error) <span class="cov8" title="1">{
        x, err := newCurvePoint(getData(input, 0, 64))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">y, err := newCurvePoint(getData(input, 64, 64))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">res := new(bn256.G1)
        res.Add(x, y)
        return res.Marshal(), nil</span>
}

// bn256Add implements a native elliptic curve point addition conforming to
// Istanbul consensus rules.
type bn256AddIstanbul struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
func (c *bn256AddIstanbul) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        return params.Bn256AddGasIstanbul
}</span>

func (c *bn256AddIstanbul) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        return runBn256Add(input)
}</span>

// bn256AddByzantium implements a native elliptic curve point addition
// conforming to Byzantium consensus rules.
type bn256AddByzantium struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
func (c *bn256AddByzantium) RequiredGas(input []byte) uint64 <span class="cov0" title="0">{
        return params.Bn256AddGasByzantium
}</span>

func (c *bn256AddByzantium) Run(input []byte) ([]byte, error) <span class="cov0" title="0">{
        return runBn256Add(input)
}</span>

// runBn256ScalarMul implements the Bn256ScalarMul precompile, referenced by
// both Byzantium and Istanbul operations.
func runBn256ScalarMul(input []byte) ([]byte, error) <span class="cov8" title="1">{
        p, err := newCurvePoint(getData(input, 0, 64))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">res := new(bn256.G1)
        res.ScalarMult(p, new(big.Int).SetBytes(getData(input, 64, 32)))
        return res.Marshal(), nil</span>
}

// bn256ScalarMulIstanbul implements a native elliptic curve scalar
// multiplication conforming to Istanbul consensus rules.
type bn256ScalarMulIstanbul struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
func (c *bn256ScalarMulIstanbul) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        return params.Bn256ScalarMulGasIstanbul
}</span>

func (c *bn256ScalarMulIstanbul) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        return runBn256ScalarMul(input)
}</span>

// bn256ScalarMulByzantium implements a native elliptic curve scalar
// multiplication conforming to Byzantium consensus rules.
type bn256ScalarMulByzantium struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
func (c *bn256ScalarMulByzantium) RequiredGas(input []byte) uint64 <span class="cov0" title="0">{
        return params.Bn256ScalarMulGasByzantium
}</span>

func (c *bn256ScalarMulByzantium) Run(input []byte) ([]byte, error) <span class="cov0" title="0">{
        return runBn256ScalarMul(input)
}</span>

var (
        // true32Byte is returned if the bn256 pairing check succeeds.
        true32Byte = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}

        // false32Byte is returned if the bn256 pairing check fails.
        false32Byte = make([]byte, 32)

        // errBadPairingInput is returned if the bn256 pairing input is invalid.
        errBadPairingInput = errors.New("bad elliptic curve pairing size")
)

// runBn256Pairing implements the Bn256Pairing precompile, referenced by both
// Byzantium and Istanbul operations.
func runBn256Pairing(input []byte) ([]byte, error) <span class="cov8" title="1">{
        // Handle some corner cases cheaply
        if len(input)%192 &gt; 0 </span><span class="cov0" title="0">{
                return nil, errBadPairingInput
        }</span>
        // Convert the input into a set of coordinates
        <span class="cov8" title="1">var (
                cs []*bn256.G1
                ts []*bn256.G2
        )
        for i := 0; i &lt; len(input); i += 192 </span><span class="cov8" title="1">{
                c, err := newCurvePoint(input[i : i+64])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">t, err := newTwistPoint(input[i+64 : i+192])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">cs = append(cs, c)
                ts = append(ts, t)</span>
        }
        // Execute the pairing checks and return the results
        <span class="cov8" title="1">if bn256.PairingCheck(cs, ts) </span><span class="cov8" title="1">{
                return true32Byte, nil
        }</span>
        <span class="cov8" title="1">return false32Byte, nil</span>
}

// bn256PairingIstanbul implements a pairing pre-compile for the bn256 curve
// conforming to Istanbul consensus rules.
type bn256PairingIstanbul struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
func (c *bn256PairingIstanbul) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        return params.Bn256PairingBaseGasIstanbul + uint64(len(input)/192)*params.Bn256PairingPerPointGasIstanbul
}</span>

func (c *bn256PairingIstanbul) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        return runBn256Pairing(input)
}</span>

// bn256PairingByzantium implements a pairing pre-compile for the bn256 curve
// conforming to Byzantium consensus rules.
type bn256PairingByzantium struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
func (c *bn256PairingByzantium) RequiredGas(input []byte) uint64 <span class="cov0" title="0">{
        return params.Bn256PairingBaseGasByzantium + uint64(len(input)/192)*params.Bn256PairingPerPointGasByzantium
}</span>

func (c *bn256PairingByzantium) Run(input []byte) ([]byte, error) <span class="cov0" title="0">{
        return runBn256Pairing(input)
}</span>

type blake2F struct{}

func (c *blake2F) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        // If the input is malformed, we can't calculate the gas, return 0 and let the
        // actual call choke and fault.
        if len(input) != blake2FInputLength </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return uint64(binary.BigEndian.Uint32(input[0:4]))</span>
}

const (
        blake2FInputLength        = 213
        blake2FFinalBlockBytes    = byte(1)
        blake2FNonFinalBlockBytes = byte(0)
)

var (
        errBlake2FInvalidInputLength = errors.New("invalid input length")
        errBlake2FInvalidFinalFlag   = errors.New("invalid final flag")
)

func (c *blake2F) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        // Make sure the input is valid (correct lenth and final flag)
        if len(input) != blake2FInputLength </span><span class="cov8" title="1">{
                return nil, errBlake2FInvalidInputLength
        }</span>
        <span class="cov8" title="1">if input[212] != blake2FNonFinalBlockBytes &amp;&amp; input[212] != blake2FFinalBlockBytes </span><span class="cov8" title="1">{
                return nil, errBlake2FInvalidFinalFlag
        }</span>
        // Parse the input into the Blake2b call parameters
        <span class="cov8" title="1">var (
                rounds = binary.BigEndian.Uint32(input[0:4])
                final  = (input[212] == blake2FFinalBlockBytes)

                h [8]uint64
                m [16]uint64
                t [2]uint64
        )
        for i := 0; i &lt; 8; i++ </span><span class="cov8" title="1">{
                offset := 4 + i*8
                h[i] = binary.LittleEndian.Uint64(input[offset : offset+8])
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                offset := 68 + i*8
                m[i] = binary.LittleEndian.Uint64(input[offset : offset+8])
        }</span>
        <span class="cov8" title="1">t[0] = binary.LittleEndian.Uint64(input[196:204])
        t[1] = binary.LittleEndian.Uint64(input[204:212])

        // Execute the compression function, extract and return the result
        blake2b.F(&amp;h, m, t, final, rounds)

        output := make([]byte, 64)
        for i := 0; i &lt; 8; i++ </span><span class="cov8" title="1">{
                offset := i * 8
                binary.LittleEndian.PutUint64(output[offset:offset+8], h[i])
        }</span>
        <span class="cov8" title="1">return output, nil</span>
}

// epoch returns the current epoch, implemented as a native contract
type epoch struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *epoch) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        return GasQuickStep
}</span>

func (c *epoch) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        // Note the input was overwritten with the epoch of the current block
        // So just format and return
        return common.LeftPadBytes(input, 32), nil
}</span>

// VRF implemented as a native contract.
type vrf struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *vrf) RequiredGas(input []byte) uint64 <span class="cov0" title="0">{
        return GasQuickStep
}</span>

func (c *vrf) Run(input []byte) ([]byte, error) <span class="cov0" title="0">{
        // Note the input was overwritten with the vrf of the block.
        // So here we simply return it
        return append([]byte{}, input...), nil
}</span>

// SHA3-256 FIPS 202 standard implemented as a native contract.

type sha3fip struct{}

// TODO Check if the gas price calculation needs modification
// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *sha3fip) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        return uint64(len(input)+31)/32*params.Sha3FipsWordGas + params.Sha3FipsGas
}</span>
func (c *sha3fip) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        hexStr := common.Bytes2Hex(input)
        pub, _ := hex.DecodeString(hexStr)
        h := sha3.Sum256(pub[:])
        return h[:], nil
}</span>

// ECRECOVER implemented as a native contract.
type ecrecoverPublicKey struct{}

func (c *ecrecoverPublicKey) RequiredGas(input []byte) uint64 <span class="cov8" title="1">{
        return params.EcrecoverGas
}</span>

func (c *ecrecoverPublicKey) Run(input []byte) ([]byte, error) <span class="cov8" title="1">{
        const ecrecoverPublicKeyInputLength = 128

        input = common.RightPadBytes(input, ecrecoverPublicKeyInputLength)
        // "input" is (hash, v, r, s), each 32 bytes
        // but for ecrecover we want (r, s, v)

        r := new(big.Int).SetBytes(input[64:96])
        s := new(big.Int).SetBytes(input[96:128])
        v := input[63]

        // tighter sig s values input homestead only apply to tx sigs
        if !allZero(input[32:63]) || !crypto.ValidateSignatureValues(v, r, s, false) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        // We must make sure not to modify the 'input', so placing the 'v' along with
        // the signature needs to be done on a new allocation
        <span class="cov8" title="1">sig := make([]byte, 65)
        copy(sig, input[64:128])
        sig[64] = v
        // v needs to be at the end for libsecp256k1
        pubKey, err := crypto.Ecrecover(input[:32], sig)
        // make sure the public key is a valid one
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return pubKey, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package vm

import (
        "errors"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/staking"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
)

// WriteCapablePrecompiledContractsStaking lists out the write capable precompiled contracts
// which are available after the StakingPrecompileEpoch
// for now, we have only one contract at 252 or 0xfc - which is the staking precompile
var WriteCapablePrecompiledContractsStaking = map[common.Address]WriteCapablePrecompiledContract{
        common.BytesToAddress([]byte{251}): &amp;migrationPrecompile{},
        common.BytesToAddress([]byte{252}): &amp;stakingPrecompile{},
}

// WriteCapablePrecompiledContract represents the interface for Native Go contracts
// which are available as a precompile in the EVM
// As with (read-only) PrecompiledContracts, these need a RequiredGas function
// Note that these contracts have the capability to alter the state
// while those in contracts.go do not
type WriteCapablePrecompiledContract interface {
        // RequiredGas calculates the contract gas use
        RequiredGas(evm *EVM, contract *Contract, input []byte) (uint64, error)
        // use a different name from read-only contracts to be safe
        RunWriteCapable(evm *EVM, contract *Contract, input []byte) ([]byte, error)
}

// RunWriteCapablePrecompiledContract runs and evaluates the output of a write capable precompiled contract.
func RunWriteCapablePrecompiledContract(
        p WriteCapablePrecompiledContract,
        evm *EVM,
        contract *Contract,
        input []byte,
        readOnly bool,
) ([]byte, error) <span class="cov8" title="1">{
        // immediately error out if readOnly
        if readOnly </span><span class="cov8" title="1">{
                return nil, errWriteProtection
        }</span>
        <span class="cov8" title="1">gas, err := p.RequiredGas(evm, contract, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !contract.UseGas(gas) </span><span class="cov0" title="0">{
                return nil, ErrOutOfGas
        }</span>
        <span class="cov8" title="1">return p.RunWriteCapable(evm, contract, input)</span>
}

type stakingPrecompile struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *stakingPrecompile) RequiredGas(
        evm *EVM,
        contract *Contract,
        input []byte,
) (uint64, error) <span class="cov8" title="1">{
        // if invalid data or invalid shard
        // set payload to blank and charge minimum gas
        var payload []byte = make([]byte, 0)
        // availability of staking and precompile has already been checked
        if evm.Context.ShardID == shard.BeaconChainShardID </span><span class="cov8" title="1">{
                // check that input is well formed
                // meaning all the expected parameters are available
                // and that we are only trying to perform staking tx
                // on behalf of the correct entity
                stakeMsg, err := staking.ParseStakeMsg(contract.Caller(), input)
                if err == nil </span><span class="cov8" title="1">{
                        // otherwise charge similar to a regular staking tx
                        if encoded, err := rlp.EncodeToBytes(stakeMsg); err == nil </span><span class="cov8" title="1">{
                                payload = encoded
                        }</span>
                }
        }
        <span class="cov8" title="1">if gas, err := IntrinsicGas(
                payload,
                false,                                   // contractCreation
                evm.ChainConfig().IsS3(evm.EpochNumber), // homestead
                evm.ChainConfig().IsIstanbul(evm.EpochNumber), // istanbul
                false, // isValidatorCreation
        ); err != nil </span><span class="cov0" title="0">{
                return 0, err // ErrOutOfGas occurs when gas payable &gt; uint64
        }</span> else<span class="cov8" title="1"> {
                return gas, nil
        }</span>
}

// RunWriteCapable runs the actual contract (that is it performs the staking)
func (c *stakingPrecompile) RunWriteCapable(
        evm *EVM,
        contract *Contract,
        input []byte,
) ([]byte, error) <span class="cov8" title="1">{
        if evm.Context.ShardID != shard.BeaconChainShardID </span><span class="cov0" title="0">{
                return nil, errors.New("Staking not supported on this shard")
        }</span>
        <span class="cov8" title="1">stakeMsg, err := staking.ParseStakeMsg(contract.Caller(), input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if delegate, ok := stakeMsg.(*stakingTypes.Delegate); ok </span><span class="cov8" title="1">{
                if err := evm.Delegate(evm.StateDB, delegate); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        evm.StakeMsgs = append(evm.StakeMsgs, delegate)
                        return nil, nil
                }</span>
        }
        <span class="cov8" title="1">if undelegate, ok := stakeMsg.(*stakingTypes.Undelegate); ok </span><span class="cov8" title="1">{
                return nil, evm.Undelegate(evm.StateDB, undelegate)
        }</span>
        <span class="cov8" title="1">if collectRewards, ok := stakeMsg.(*stakingTypes.CollectRewards); ok </span><span class="cov8" title="1">{
                return nil, evm.CollectRewards(evm.StateDB, collectRewards)
        }</span>
        <span class="cov0" title="0">return nil, stakingTypes.ErrInvalidStakingKind</span>
}

type migrationPrecompile struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *migrationPrecompile) RequiredGas(
        evm *EVM,
        contract *Contract,
        input []byte,
) (uint64, error) <span class="cov8" title="1">{
        // if invalid data or invalid shard
        // set payload to blank and charge minimum gas
        var payload []byte = make([]byte, 0)
        // availability of staking and precompile has already been checked
        if evm.Context.ShardID == shard.BeaconChainShardID </span><span class="cov8" title="1">{
                // check that input is well formed
                // meaning all the expected parameters are available
                // and that we are only trying to perform staking tx
                // on behalf of the correct entity
                migrationMsg, err := staking.ParseMigrationMsg(contract.Caller(), input)
                if err == nil </span><span class="cov8" title="1">{
                        // otherwise charge based on the data
                        if encoded, err := rlp.EncodeToBytes(migrationMsg); err == nil </span><span class="cov0" title="0">{
                                payload = encoded
                        }</span>
                }
        }
        <span class="cov8" title="1">if gas, err := IntrinsicGas(
                payload,
                false,                                   // contractCreation
                evm.ChainConfig().IsS3(evm.EpochNumber), // homestead
                evm.ChainConfig().IsIstanbul(evm.EpochNumber), // istanbul
                false, // isValidatorCreation
        ); err != nil </span><span class="cov0" title="0">{
                return 0, err // ErrOutOfGas occurs when gas payable &gt; uint64
        }</span> else<span class="cov8" title="1"> {
                return gas, nil
        }</span>
}

func (c *migrationPrecompile) RunWriteCapable(
        evm *EVM,
        contract *Contract,
        input []byte,
) ([]byte, error) <span class="cov8" title="1">{
        if evm.Context.ShardID != shard.BeaconChainShardID </span><span class="cov0" title="0">{
                return nil, errors.New("Staking not supported on this shard")
        }</span>
        <span class="cov8" title="1">migrationMsg, err := staking.ParseMigrationMsg(contract.Caller(), input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stakeMsgs, err := evm.MigrateDelegations(evm.StateDB, migrationMsg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                for _, stakeMsg := range stakeMsgs </span><span class="cov0" title="0">{
                        if delegate, ok := stakeMsg.(*stakingTypes.Delegate); ok </span><span class="cov0" title="0">{
                                evm.StakeMsgs = append(evm.StakeMsgs, delegate)
                        }</span> else<span class="cov0" title="0"> {
                                panic("Received incompatible stakeMsg")</span>
                        }
                }
                <span class="cov8" title="1">return nil, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package vm

import (
        "math/big"
        "sync/atomic"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/internal/params"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
)

// emptyCodeHash is used by create to ensure deployment is disallowed to already
// deployed contract addresses (relevant after the account abstraction).
var emptyCodeHash = crypto.Keccak256Hash(nil)

type (
        // CanTransferFunc is the signature of a transfer guard function
        CanTransferFunc func(StateDB, common.Address, *big.Int) bool
        // IsValidatorFunc is the signature of IsValidator function
        IsValidatorFunc func(StateDB, common.Address) bool
        // TransferFunc is the signature of a transfer function
        TransferFunc func(StateDB, common.Address, common.Address, *big.Int, types.TransactionType)
        // GetHashFunc returns the nth block hash in the blockchain
        // and is used by the BLOCKHASH EVM op code.
        GetHashFunc func(uint64) common.Hash
        // GetVRFFunc returns the nth block vrf in the blockchain
        // and is used by the precompile VRF contract.
        GetVRFFunc func(uint64) common.Hash
        // Below functions are used by staking precompile, and state transition
        CreateValidatorFunc func(db StateDB, stakeMsg *stakingTypes.CreateValidator) error
        EditValidatorFunc   func(db StateDB, stakeMsg *stakingTypes.EditValidator) error
        DelegateFunc        func(db StateDB, stakeMsg *stakingTypes.Delegate) error
        UndelegateFunc      func(db StateDB, stakeMsg *stakingTypes.Undelegate) error
        CollectRewardsFunc  func(db StateDB, stakeMsg *stakingTypes.CollectRewards) error
        // Used for migrating delegations via the migration precompile
        MigrateDelegationsFunc func(db StateDB, migrationMsg *stakingTypes.MigrationMsg) ([]interface{}, error)
)

// run runs the given contract and takes care of running precompiles with a fallback to the byte code interpreter.
func run(evm *EVM, contract *Contract, input []byte, readOnly bool) ([]byte, error) <span class="cov8" title="1">{
        if contract.CodeAddr != nil </span><span class="cov8" title="1">{
                precompiles := PrecompiledContractsHomestead
                // assign empty write capable precompiles till they are available in the fork
                writeCapablePrecompiles := make(map[common.Address]WriteCapablePrecompiledContract)
                if evm.ChainConfig().IsS3(evm.EpochNumber) </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsByzantium
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsIstanbul </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsIstanbul
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsVRF </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsVRF
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsSHA3 </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsSHA3FIPS
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsStakingPrecompile </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsStaking
                        writeCapablePrecompiles = WriteCapablePrecompiledContractsStaking
                }</span>
                <span class="cov8" title="1">if p := precompiles[*contract.CodeAddr]; p != nil </span><span class="cov8" title="1">{
                        if _, ok := p.(*vrf); ok </span><span class="cov0" title="0">{
                                if evm.chainRules.IsPrevVRF </span><span class="cov0" title="0">{
                                        requestedBlockNum := big.NewInt(0).SetBytes(input)
                                        minBlockNum := big.NewInt(0).Sub(evm.BlockNumber, common.Big257)

                                        if requestedBlockNum.Cmp(evm.BlockNumber) == 0 </span><span class="cov0" title="0">{
                                                input = evm.Context.VRF.Bytes()
                                        }</span> else<span class="cov0" title="0"> if requestedBlockNum.Cmp(minBlockNum) &gt; 0 &amp;&amp; requestedBlockNum.Cmp(evm.BlockNumber) &lt; 0 </span><span class="cov0" title="0">{
                                                // requested block number is in range
                                                input = evm.GetVRF(requestedBlockNum.Uint64()).Bytes()
                                        }</span> else<span class="cov0" title="0"> {
                                                // else default to the current block's VRF
                                                input = evm.Context.VRF.Bytes()
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Override the input with vrf data of the requested block so it can be returned to the contract program.
                                        input = evm.Context.VRF.Bytes()
                                }</span>
                        } else<span class="cov8" title="1"> if _, ok := p.(*epoch); ok </span><span class="cov8" title="1">{
                                input = evm.EpochNumber.Bytes()
                        }</span>
                        <span class="cov8" title="1">return RunPrecompiledContract(p, input, contract)</span>
                }
                <span class="cov8" title="1">if p := writeCapablePrecompiles[*contract.CodeAddr]; p != nil </span><span class="cov8" title="1">{
                        return RunWriteCapablePrecompiledContract(p, evm, contract, input, readOnly)
                }</span>
        }
        <span class="cov8" title="1">for _, interpreter := range evm.interpreters </span><span class="cov8" title="1">{
                if interpreter.CanRun(contract.Code) </span><span class="cov8" title="1">{
                        if evm.interpreter != interpreter </span><span class="cov0" title="0">{
                                // Ensure that the interpreter pointer is set back
                                // to its current value upon return.
                                defer func(i Interpreter) </span><span class="cov0" title="0">{
                                        evm.interpreter = i
                                }</span>(evm.interpreter)
                                <span class="cov0" title="0">evm.interpreter = interpreter</span>
                        }

                        <span class="cov8" title="1">if evm.ChainConfig().IsDataCopyFixEpoch(evm.EpochNumber) </span><span class="cov8" title="1">{
                                contract.WithDataCopyFix = true
                        }</span>
                        <span class="cov8" title="1">return interpreter.Run(contract, input, readOnly)</span>

                }
        }
        <span class="cov0" title="0">return nil, ErrNoCompatibleInterpreter</span>
}

// Context provides the EVM with auxiliary information. Once provided
// it shouldn't be modified.
type Context struct {
        // CanTransfer returns whether the account contains
        // sufficient ether to transfer the value
        CanTransfer CanTransferFunc
        // Transfer transfers ether from one account to the other
        Transfer TransferFunc
        // GetHash returns the hash corresponding to n
        GetHash GetHashFunc
        // GetVRF returns the VRF corresponding to n
        GetVRF GetVRFFunc

        // IsValidator determines whether the address corresponds to a validator or a smart contract
        // true: is a validator address; false: is smart contract address
        IsValidator IsValidatorFunc

        // Message information
        Origin   common.Address // Provides information for ORIGIN
        GasPrice *big.Int       // Provides information for GASPRICE

        // Block information
        Coinbase    common.Address // Provides information for COINBASE
        GasLimit    uint64         // Provides information for GASLIMIT
        BlockNumber *big.Int       // Provides information for NUMBER
        EpochNumber *big.Int       // Provides information for EPOCH
        Time        *big.Int       // Provides information for TIME
        VRF         common.Hash    // Provides information for VRF

        TxType types.TransactionType

        CreateValidator    CreateValidatorFunc
        EditValidator      EditValidatorFunc
        Delegate           DelegateFunc
        Undelegate         UndelegateFunc
        CollectRewards     CollectRewardsFunc
        MigrateDelegations MigrateDelegationsFunc

        // staking precompile checks this before proceeding forward
        ShardID uint32
}

// EVM is the Ethereum Virtual Machine base object and provides
// the necessary tools to run a contract on the given state with
// the provided context. It should be noted that any error
// generated through any of the calls should be considered a
// revert-state-and-consume-all-gas operation, no checks on
// specific errors should ever be performed. The interpreter makes
// sure that any errors generated are to be considered faulty code.
//
// The EVM should never be reused and is not thread safe.
type EVM struct {
        // Context provides auxiliary blockchain related information
        Context
        // DB gives access to the underlying state
        StateDB StateDB
        // Depth is the current call stack
        depth int

        // chainConfig contains information about the current chain
        chainConfig *params.ChainConfig
        // chain rules contains the chain rules for the current epoch
        chainRules params.Rules
        // virtual machine configuration options used to initialise the
        // evm.
        vmConfig Config
        // global (to this context) ethereum virtual machine
        // used throughout the execution of the tx.
        interpreters []Interpreter
        interpreter  Interpreter
        // abort is used to abort the EVM calling operations
        // NOTE: must be set atomically
        abort int32
        // callGasTemp holds the gas available for the current call. This is needed because the
        // available gas is calculated in gasCall* according to the 63/64 rule and later
        // applied in opCall*.
        callGasTemp uint64
        // stored temporarily by stakingPrecompile and cleared immediately after return
        // (although the EVM object itself is ephemeral)
        StakeMsgs []stakingTypes.StakeMsg
}

// NewEVM returns a new EVM. The returned EVM is not thread safe and should
// only ever be used *once*.
func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM <span class="cov8" title="1">{
        evm := &amp;EVM{
                Context:      ctx,
                StateDB:      statedb,
                vmConfig:     vmConfig,
                chainConfig:  chainConfig,
                chainRules:   chainConfig.Rules(ctx.EpochNumber),
                interpreters: make([]Interpreter, 0, 1),
        }

        //if chainConfig.IsS3(ctx.EpochNumber) {
        //        to be implemented by EVM-C and Wagon PRs.
        //        if vmConfig.EWASMInterpreter != "" {
        //         extIntOpts := strings.Split(vmConfig.EWASMInterpreter, ":")
        //         path := extIntOpts[0]
        //         options := []string{}
        //         if len(extIntOpts) &gt; 1 {
        //           options = extIntOpts[1..]
        //         }
        //         evm.interpreters = append(evm.interpreters, NewEVMVCInterpreter(evm, vmConfig, options))
        //        } else {
        //                evm.interpreters = append(evm.interpreters, NewEWASMInterpreter(evm, vmConfig))
        //        }
        //        panic("No supported ewasm interpreter yet.")
        //}

        // vmConfig.EVMInterpreter will be used by EVM-C, it won't be checked here
        // as we always want to have the built-in EVM as the failover option.
        evm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig))
        evm.interpreter = evm.interpreters[0]

        return evm
}</span>

// Cancel cancels any running EVM operation. This may be called concurrently and
// it's safe to be called multiple times.
func (evm *EVM) Cancel() <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;evm.abort, 1)
}</span>

// Cancelled returns true if Cancel has been called
func (evm *EVM) Cancelled() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;evm.abort) == 1
}</span>

// Interpreter returns the current interpreter
func (evm *EVM) Interpreter() Interpreter <span class="cov0" title="0">{
        return evm.interpreter
}</span>

// Call executes the contract associated with the addr with the given input as
// parameters. It also handles any necessary value transfer required and takes
// the necessary steps to create accounts and reverses the state in case of an
// execution error or failed value transfer.
func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) <span class="cov8" title="1">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>

        // Fail if we're trying to execute above the call depth limit
        <span class="cov8" title="1">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>

        <span class="cov8" title="1">txType := evm.Context.TxType

        // Fail if we're trying to transfer more than the available balance
        if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) </span><span class="cov0" title="0">{
                return nil, gas, ErrInsufficientBalance
        }</span>

        <span class="cov8" title="1">var (
                to       = AccountRef(addr)
                snapshot = evm.StateDB.Snapshot()
        )
        if !evm.StateDB.Exist(addr) &amp;&amp; txType != types.SubtractionOnly </span><span class="cov8" title="1">{
                precompiles := PrecompiledContractsHomestead
                writeCapablePrecompiles := make(map[common.Address]WriteCapablePrecompiledContract)
                if evm.ChainConfig().IsS3(evm.EpochNumber) </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsByzantium
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsIstanbul </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsIstanbul
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsVRF </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsVRF
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsSHA3 </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsSHA3FIPS
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsStakingPrecompile </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsStaking
                        writeCapablePrecompiles = WriteCapablePrecompiledContractsStaking
                }</span>

                <span class="cov8" title="1">if writeCapablePrecompiles[addr] == nil &amp;&amp; precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsS3(evm.EpochNumber) &amp;&amp; value.Sign() == 0 </span><span class="cov0" title="0">{
                        // Calling a non existing account, don't do anything, but ping the tracer
                        if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                                evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)
                                evm.vmConfig.Tracer.CaptureEnd(ret, 0, 0, nil)
                        }</span>
                        <span class="cov0" title="0">return nil, gas, nil</span>
                }
                <span class="cov8" title="1">evm.StateDB.CreateAccount(addr)</span>
        }
        <span class="cov8" title="1">evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value, txType)

        codeHash := evm.StateDB.GetCodeHash(addr)
        code := evm.StateDB.GetCode(addr)
        // If address is a validator address, then it's not a smart contract address
        // we don't use its code and codeHash fields
        if evm.Context.IsValidator(evm.StateDB, addr) </span><span class="cov8" title="1">{
                codeHash = emptyCodeHash
                code = nil
        }</span>
        // Initialise a new contract and set the code that is to be used by the EVM.
        // The contract is a scoped environment for this execution context only.
        <span class="cov8" title="1">contract := NewContract(caller, to, value, gas)
        contract.SetCallCode(&amp;addr, codeHash, code)

        // Even if the account has no code, we need to continue because it might be a precompile
        start := time.Now()

        // Capture the tracer start/end events in debug mode
        if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)

                defer func() </span><span class="cov0" title="0">{ // Lazy evaluation of the parameters
                        evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)
                }</span>()
        }
        <span class="cov8" title="1">ret, err = run(evm, contract, input, false)

        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're in homestead this also counts for code storage gas errors.
        if err != nil </span><span class="cov8" title="1">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov8" title="1">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov8" title="1">return ret, contract.Gas, err</span>
}

// CallCode executes the contract associated with the addr with the given input
// as parameters. It also handles any necessary value transfer required and takes
// the necessary steps to create accounts and reverses the state in case of an
// execution error or failed value transfer.
//
// CallCode differs from Call in the sense that it executes the given address'
// code with the caller as context.
func (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) <span class="cov0" title="0">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>

        // Fail if we're trying to execute above the call depth limit
        <span class="cov0" title="0">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>
        // Fail if we're trying to transfer more than the available balance
        <span class="cov0" title="0">if !evm.CanTransfer(evm.StateDB, caller.Address(), value) </span><span class="cov0" title="0">{
                return nil, gas, ErrInsufficientBalance
        }</span>

        <span class="cov0" title="0">var (
                snapshot = evm.StateDB.Snapshot()
                to       = AccountRef(caller.Address())
        )
        // initialise a new contract and set the code that is to be used by the
        // EVM. The contract is a scoped environment for this execution context
        // only.
        contract := NewContract(caller, to, value, gas)
        contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        ret, err = run(evm, contract, input, false)
        if err != nil </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov0" title="0">return ret, contract.Gas, err</span>
}

// DelegateCall executes the contract associated with the addr with the given input
// as parameters. It reverses the state in case of an execution error.
//
// DelegateCall differs from CallCode in the sense that it executes the given address'
// code with the caller as context and the caller is set to the caller of the caller.
func (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) <span class="cov0" title="0">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>
        // Fail if we're trying to execute above the call depth limit
        <span class="cov0" title="0">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>

        <span class="cov0" title="0">var (
                snapshot = evm.StateDB.Snapshot()
                to       = AccountRef(caller.Address())
        )

        // Initialise a new contract and make initialise the delegate values
        contract := NewContract(caller, to, nil, gas).AsDelegate()
        contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        ret, err = run(evm, contract, input, false)
        if err != nil </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov0" title="0">return ret, contract.Gas, err</span>
}

// StaticCall executes the contract associated with the addr with the given input
// as parameters while disallowing any modifications to the state during the call.
// Opcodes that attempt to perform such modifications will result in exceptions
// instead of performing the modifications.
func (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) <span class="cov0" title="0">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>
        // Fail if we're trying to execute above the call depth limit
        <span class="cov0" title="0">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>

        <span class="cov0" title="0">var (
                to       = AccountRef(addr)
                snapshot = evm.StateDB.Snapshot()
        )
        // Initialise a new contract and set the code that is to be used by the
        // EVM. The contract is a scoped environment for this execution context
        // only.
        contract := NewContract(caller, to, new(big.Int), gas)
        contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        // We do an AddBalance of zero here, just in order to trigger a touch.
        // This doesn't matter on Mainnet, where all empties are gone at the time of Byzantium,
        // but is the correct thing to do and matters on other networks, in tests, and potential
        // future scenarios
        evm.StateDB.AddBalance(addr, bigZero)

        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're in Homestead this also counts for code storage gas errors.
        ret, err = run(evm, contract, input, true)
        if err != nil </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov0" title="0">return ret, contract.Gas, err</span>
}

type codeAndHash struct {
        code []byte
        hash common.Hash
}

func (c *codeAndHash) Hash() common.Hash <span class="cov0" title="0">{
        if c.hash == (common.Hash{}) </span><span class="cov0" title="0">{
                c.hash = crypto.Keccak256Hash(c.code)
        }</span>
        <span class="cov0" title="0">return c.hash</span>
}

// create creates a new contract using code as deployment code.
func (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) <span class="cov0" title="0">{
        // Depth check execution. Fail if we're trying to execute above the
        // limit.
        if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, common.Address{}, gas, ErrDepth
        }</span>
        <span class="cov0" title="0">if !evm.CanTransfer(evm.StateDB, caller.Address(), value) </span><span class="cov0" title="0">{
                return nil, common.Address{}, gas, ErrInsufficientBalance
        }</span>
        <span class="cov0" title="0">nonce := evm.StateDB.GetNonce(caller.Address())
        evm.StateDB.SetNonce(caller.Address(), nonce+1)

        // Ensure there's no existing contract already at the designated address
        contractHash := evm.StateDB.GetCodeHash(address)
        if evm.StateDB.GetNonce(address) != 0 || (contractHash != (common.Hash{}) &amp;&amp; contractHash != emptyCodeHash) </span><span class="cov0" title="0">{
                return nil, common.Address{}, 0, ErrContractAddressCollision
        }</span>
        // Create a new account on the state
        <span class="cov0" title="0">snapshot := evm.StateDB.Snapshot()
        evm.StateDB.CreateAccount(address)
        if evm.ChainConfig().IsEIP155(evm.EpochNumber) </span><span class="cov0" title="0">{
                evm.StateDB.SetNonce(address, 1)
        }</span>
        <span class="cov0" title="0">evm.Transfer(evm.StateDB, caller.Address(), address, value, types.SameShardTx)

        // initialise a new contract and set the code that is to be used by the
        // EVM. The contract is a scoped environment for this execution context
        // only.
        contract := NewContract(caller, AccountRef(address), value, gas)
        contract.SetCodeOptionalHash(&amp;address, codeAndHash)

        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, address, gas, nil
        }</span>

        <span class="cov0" title="0">if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), address, true, codeAndHash.code, gas, value)
        }</span>
        <span class="cov0" title="0">start := time.Now()

        ret, err := run(evm, contract, nil, false)

        // check whether the max code size has been exceeded
        maxCodeSizeExceeded := evm.ChainConfig().IsEIP155(evm.EpochNumber) &amp;&amp; len(ret) &gt; params.MaxCodeSize
        // if the contract creation ran successfully and no errors were returned
        // calculate the gas required to store the code. If the code could not
        // be stored due to not enough gas set an error and let it be handled
        // by the error checking condition below.
        if err == nil &amp;&amp; !maxCodeSizeExceeded </span><span class="cov0" title="0">{
                createDataGas := uint64(len(ret)) * params.CreateDataGas
                if contract.UseGas(createDataGas) </span><span class="cov0" title="0">{
                        evm.StateDB.SetCode(address, ret)
                }</span> else<span class="cov0" title="0"> {
                        err = ErrCodeStoreOutOfGas
                }</span>
        }

        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're in homestead this also counts for code storage gas errors.
        <span class="cov0" title="0">if maxCodeSizeExceeded || (err != nil &amp;&amp; (evm.ChainConfig().IsS3(evm.EpochNumber) || err != ErrCodeStoreOutOfGas)) </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        // Assign err if contract code size exceeds the max while the err is still empty.
        <span class="cov0" title="0">if maxCodeSizeExceeded &amp;&amp; err == nil </span><span class="cov0" title="0">{
                err = errMaxCodeSizeExceeded
        }</span>
        <span class="cov0" title="0">if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)
        }</span>
        <span class="cov0" title="0">return ret, address, contract.Gas, err</span>

}

// Create creates a new contract using code as deployment code.
func (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) <span class="cov0" title="0">{
        contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))
        return evm.create(caller, &amp;codeAndHash{code: code}, gas, value, contractAddr)
}</span>

// Create2 creates a new contract using code as deployment code.
//
// The different between Create2 with Create is Create2 uses sha3(0xff ++ msg.sender ++ salt ++ sha3(init_code))[12:]
// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.
func (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) <span class="cov0" title="0">{
        codeAndHash := &amp;codeAndHash{code: code}
        contractAddr = crypto.CreateAddress2(caller.Address(), common.BigToHash(salt), codeAndHash.Hash().Bytes())
        return evm.create(caller, codeAndHash, gas, endowment, contractAddr)
}</span>

// ChainConfig returns the environment's chain configuration
func (evm *EVM) ChainConfig() *params.ChainConfig <span class="cov8" title="1">{ return evm.chainConfig }</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package vm

import (
        "math"
        "math/big"

        "github.com/harmony-one/harmony/internal/params"
)

// Gas costs
const (
        GasQuickStep   uint64 = 2
        GasFastestStep uint64 = 3
        GasFastStep    uint64 = 5
        GasMidStep     uint64 = 8
        GasSlowStep    uint64 = 10
        GasExtStep     uint64 = 20
)

// calcGas returns the actual gas cost of the call.
//
// The cost of gas was changed during the homestead price change HF.
// As part of EIP 150 (TangerineWhistle), the returned gas is gas - base * 63 / 64.
func callGas(isEip150 bool, availableGas, base uint64, callCost *big.Int) (uint64, error) <span class="cov0" title="0">{
        if isEip150 </span><span class="cov0" title="0">{
                availableGas = availableGas - base
                gas := availableGas - availableGas/64
                // If the bit length exceeds 64 bit we know that the newly calculated "gas" for EIP150
                // is smaller than the requested amount. Therefor we return the new gas instead
                // of returning an error.
                if !callCost.IsUint64() || gas &lt; callCost.Uint64() </span><span class="cov0" title="0">{
                        return gas, nil
                }</span>
        }
        <span class="cov0" title="0">if !callCost.IsUint64() </span><span class="cov0" title="0">{
                return 0, errGasUintOverflow
        }</span>

        <span class="cov0" title="0">return callCost.Uint64(), nil</span>
}

// IntrinsicGas computes the 'intrinsic gas' for a message with the given data.
func IntrinsicGas(data []byte, contractCreation, homestead, istanbul, isValidatorCreation bool) (uint64, error) <span class="cov8" title="1">{
        // Set the starting gas for the raw transaction
        var gas uint64
        if contractCreation &amp;&amp; homestead </span><span class="cov0" title="0">{
                gas = params.TxGasContractCreation
        }</span> else<span class="cov8" title="1"> if isValidatorCreation </span><span class="cov8" title="1">{
                gas = params.TxGasValidatorCreation
        }</span> else<span class="cov8" title="1"> {
                gas = params.TxGas
        }</span>
        // Bump the required gas by the amount of transactional data
        <span class="cov8" title="1">if len(data) &gt; 0 </span><span class="cov8" title="1">{
                // Zero and non-zero bytes are priced differently
                var nz uint64
                for _, byt := range data </span><span class="cov8" title="1">{
                        if byt != 0 </span><span class="cov8" title="1">{
                                nz++
                        }</span>
                }
                // Make sure we don't exceed uint64 for all data combinations
                <span class="cov8" title="1">nonZeroGas := params.TxDataNonZeroGasFrontier
                if istanbul </span><span class="cov8" title="1">{
                        nonZeroGas = params.TxDataNonZeroGasEIP2028
                }</span>
                <span class="cov8" title="1">if (math.MaxUint64-gas)/nonZeroGas &lt; nz </span><span class="cov0" title="0">{
                        return 0, ErrOutOfGas
                }</span>
                <span class="cov8" title="1">gas += nz * nonZeroGas

                z := uint64(len(data)) - nz
                if (math.MaxUint64-gas)/params.TxDataZeroGas &lt; z </span><span class="cov0" title="0">{
                        return 0, ErrOutOfGas
                }</span>
                <span class="cov8" title="1">gas += z * params.TxDataZeroGas</span>
        }
        <span class="cov8" title="1">return gas, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2017 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package hmy

import (
        "bufio"
        "context"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "runtime"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/hexutil"
        "github.com/ethereum/go-ethereum/common/math"
        "github.com/ethereum/go-ethereum/trie"
        "github.com/harmony-one/harmony/core"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/eth/rpc"
        "github.com/harmony-one/harmony/hmy/tracers"
        "github.com/harmony-one/harmony/internal/utils"
)

const (
        // defaultTraceTimeout is the amount of time a single transaction can execute
        // by default before being forcefully aborted.
        defaultTraceTimeout = 5 * time.Second

        // defaultTraceReExec is the number of blocks the tracer is willing to go back
        // and re-execute to produce missing historical state necessary to run a specific
        // trace.
        defaultTraceReexec = uint64(128)

        err
)

// TraceConfig holds extra parameters to trace functions.
type TraceConfig struct {
        *vm.LogConfig
        Tracer  *string
        Timeout *string
        Reexec  *uint64
}

// StdTraceConfig holds extra parameters to standard-json trace functions.
type StdTraceConfig struct {
        *vm.LogConfig
        Reexec *uint64
        TxHash common.Hash
}

// TxTraceResult is the result of a single transaction trace.
type TxTraceResult struct {
        Result interface{} `json:"result,omitempty"` // Trace results produced by the tracer
        Error  string      `json:"error,omitempty"`  // Trace failure produced by the tracer
}

// blockTraceTask represents a single block trace task when an entire chain is
// being traced.
type blockTraceTask struct {
        statedb *state.DB        // Intermediate state prepped for tracing
        block   *types.Block     // Block to trace the transactions from
        rootRef common.Hash      // Trie root reference held for this task
        results []*TxTraceResult // Trace results produced by the task
}

// blockTraceResult represets the results of tracing a single block when an entire
// chain is being traced.
type blockTraceResult struct {
        Block  hexutil.Uint64   `json:"block"`  // Block number corresponding to this trace
        Hash   common.Hash      `json:"hash"`   // Block hash corresponding to this trace
        Traces []*TxTraceResult `json:"traces"` // Trace results produced by the task
}

// txTraceTask represents a single transaction trace task when an entire block
// is being traced.
type txTraceTask struct {
        statedb *state.DB // Intermediate state prepped for tracing
        index   int       // Transaction offset in the block
}

// TraceChain configures a new tracer according to the provided configuration, and
// executes all the transactions contained within. The return value will be one item
// per transaction, dependent on the requested tracer.
func (hmy *Harmony) TraceChain(ctx context.Context, start, end *types.Block, config *TraceConfig) (*rpc.Subscription, error) <span class="cov0" title="0">{
        // Tracing a chain is a **long** operation, only do with subscriptions
        notifier, supported := rpc.NotifierFromContext(ctx)
        if !supported </span><span class="cov0" title="0">{
                return nil, rpc.ErrNotificationsUnsupported
        }</span>
        <span class="cov0" title="0">sub := notifier.CreateSubscription()

        // Ensure we have a valid starting state before doing any work
        origin := start.NumberU64()
        database := state.NewDatabaseWithCache(hmy.ChainDb(), 16)

        if origin &gt; 0 </span><span class="cov0" title="0">{
                start = hmy.BlockChain.GetBlock(start.ParentHash(), origin-1)
                if start == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parent block #%d not found", origin-1)
                }</span>
        }

        <span class="cov0" title="0">statedb, err := state.New(start.Root(), database)
        if err != nil </span><span class="cov0" title="0">{
                // If the starting state is missing, allow some number of blocks to be executed
                reexec := defaultTraceReexec
                if config != nil &amp;&amp; config.Reexec != nil </span><span class="cov0" title="0">{
                        reexec = *config.Reexec
                }</span>
                // Find the most recent block that has state available
                <span class="cov0" title="0">for i := uint64(0); i &lt; reexec; i++ </span><span class="cov0" title="0">{
                        start = hmy.BlockChain.GetBlock(start.ParentHash(), start.NumberU64()-1)
                        if start == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if statedb, err = state.New(start.Root(), database); err == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                // If we still don't have the state available, bail
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Execute all the transactions contained within the chain concurrently for each block
        <span class="cov0" title="0">blocks := int(end.NumberU64() - origin)

        threads := runtime.NumCPU()
        if threads &gt; blocks </span><span class="cov0" title="0">{
                threads = blocks
        }</span>
        <span class="cov0" title="0">var (
                pending = new(sync.WaitGroup)
                tasks   = make(chan *blockTraceTask, threads)
                results = make(chan *blockTraceTask, threads)
        )
        for th := 0; th &lt; threads; th++ </span><span class="cov0" title="0">{
                pending.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer pending.Done()

                        // Fetch and execute the next block trace tasks
                        for task := range tasks </span><span class="cov0" title="0">{
                                hmySigner := types.MakeSigner(hmy.BlockChain.Config(), task.block.Number())
                                ethSigner := types.NewEIP155Signer(hmy.BlockChain.Config().EthCompatibleChainID)

                                // Trace all the transactions contained within
                                for i, tx := range task.block.Transactions() </span><span class="cov0" title="0">{
                                        signer := hmySigner
                                        if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                                                signer = ethSigner
                                        }</span>
                                        <span class="cov0" title="0">msg, _ := tx.AsMessage(signer)
                                        vmCtx := core.NewEVMContext(msg, task.block.Header(), hmy.BlockChain, nil)

                                        res, err := hmy.TraceTx(ctx, msg, vmCtx, task.statedb, config)
                                        if err != nil </span><span class="cov0" title="0">{
                                                task.results[i] = &amp;TxTraceResult{Error: err.Error()}
                                                utils.Logger().Warn().Msg("Tracing failed")
                                                break</span>
                                        }
                                        // EIP 158/161 (Spurious Dragon) does not apply to Harmony
                                        <span class="cov0" title="0">task.statedb.Finalise(true)
                                        task.results[i] = &amp;TxTraceResult{Result: res}</span>
                                }
                                // Stream the result back to the user or abort on teardown
                                <span class="cov0" title="0">select </span>{
                                case results &lt;- task:<span class="cov0" title="0"></span>
                                case &lt;-notifier.Closed():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }()
        }
        // Start a goroutine that feeds all the blocks into the tracers
        <span class="cov0" title="0">begin := time.Now()

        go func() </span><span class="cov0" title="0">{
                var (
                        logged time.Time
                        number uint64
                        traced uint64
                        failed error
                        proot  common.Hash
                )
                // Ensure everything is properly cleaned up on any exit path
                defer func() </span><span class="cov0" title="0">{
                        close(tasks)
                        pending.Wait()

                        switch </span>{
                        case failed != nil:<span class="cov0" title="0">
                                utils.Logger().Warn().
                                        Uint64("start", start.NumberU64()).
                                        Uint64("end", end.NumberU64()).
                                        Uint64("transactions", traced).
                                        Float64("elapsed", time.Since(begin).Seconds()).
                                        Err(failed).
                                        Msg("Chain tracing failed")</span>
                        case number &lt; end.NumberU64():<span class="cov0" title="0">
                                utils.Logger().Warn().
                                        Uint64("start", start.NumberU64()).
                                        Uint64("end", end.NumberU64()).
                                        Uint64("abort", number).
                                        Uint64("transactions", traced).
                                        Float64("elapsed", time.Since(begin).Seconds()).
                                        Msg("Chain tracing aborted")</span>
                        default:<span class="cov0" title="0">
                                utils.Logger().Info().
                                        Uint64("start", start.NumberU64()).
                                        Uint64("end", end.NumberU64()).
                                        Uint64("transactions", traced).
                                        Float64("elapsed", time.Since(begin).Seconds()).
                                        Msg("Chain tracing finished")</span>
                        }
                        <span class="cov0" title="0">close(results)</span>
                }()
                // Feed all the blocks both into the tracer, as well as fast process concurrently
                <span class="cov0" title="0">for number = start.NumberU64() + 1; number &lt;= end.NumberU64(); number++ </span><span class="cov0" title="0">{
                        // Stop tracing if interrupt was requested
                        select </span>{
                        case &lt;-notifier.Closed():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        // Print progress logs if long enough time elapsed
                        <span class="cov0" title="0">if time.Since(logged) &gt; 8*time.Second </span><span class="cov0" title="0">{
                                if number &gt; origin </span><span class="cov0" title="0">{
                                        nodes, imgs := database.TrieDB().Size()
                                        utils.Logger().Info().
                                                Uint64("start", origin).
                                                Uint64("end", end.NumberU64()).
                                                Uint64("current", number).
                                                Uint64("transactions", traced).
                                                Float64("elapsed", time.Since(begin).Seconds()).
                                                Float64("memory", float64(nodes)+float64(imgs)).
                                                Msg("Tracing chain segment")
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Logger().Info().Msg("Preparing state for chain trace")
                                }</span>
                                <span class="cov0" title="0">logged = time.Now()</span>
                        }
                        // Retrieve the next block to trace
                        <span class="cov0" title="0">block := hmy.BlockChain.GetBlockByNumber(number)
                        if block == nil </span><span class="cov0" title="0">{
                                failed = fmt.Errorf("block #%d not found", number)
                                break</span>
                        }
                        // Send the block over to the concurrent tracers (if not in the fast-forward phase)
                        <span class="cov0" title="0">if number &gt; origin </span><span class="cov0" title="0">{
                                txs := block.Transactions()

                                select </span>{
                                case tasks &lt;- &amp;blockTraceTask{statedb: statedb.Copy(), block: block, rootRef: proot, results: make([]*TxTraceResult, len(txs))}:<span class="cov0" title="0"></span>
                                case &lt;-notifier.Closed():<span class="cov0" title="0">
                                        return</span>
                                }
                                <span class="cov0" title="0">traced += uint64(len(txs))</span>
                        }
                        // Generate the next state snapshot fast without tracing
                        <span class="cov0" title="0">_, _, _, _, _, _, _, err := hmy.BlockChain.Processor().Process(block, statedb, vm.Config{}, false)
                        if err != nil </span><span class="cov0" title="0">{
                                failed = err
                                break</span>
                        }
                        // Finalize the state so any modifications are written to the trie
                        <span class="cov0" title="0">root, err := statedb.Commit(true)
                        if err != nil </span><span class="cov0" title="0">{
                                failed = err
                                break</span>
                        }
                        <span class="cov0" title="0">if err := statedb.Reset(root); err != nil </span><span class="cov0" title="0">{
                                failed = err
                                break</span>
                        }
                        // Reference the trie twice, once for us, once for the tracer
                        <span class="cov0" title="0">database.TrieDB().Reference(root, common.Hash{})
                        if number &gt;= origin </span><span class="cov0" title="0">{
                                database.TrieDB().Reference(root, common.Hash{})
                        }</span>
                        // Deference all past tries we ourselves are done working with
                        <span class="cov0" title="0">if proot != (common.Hash{}) </span><span class="cov0" title="0">{
                                database.TrieDB().Dereference(proot)
                        }</span>
                        <span class="cov0" title="0">proot = root</span>

                        // TODO(karalabe): Do we need the preimages? Won't they accumulate too much?
                }
        }()

        // Keep reading the trace results and stream them to the user
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                var (
                        done = make(map[uint64]*blockTraceResult)
                        next = origin + 1
                )
                for res := range results </span><span class="cov0" title="0">{
                        // Queue up next received result
                        result := &amp;blockTraceResult{
                                Block:  hexutil.Uint64(res.block.NumberU64()),
                                Hash:   res.block.Hash(),
                                Traces: res.results,
                        }
                        done[uint64(result.Block)] = result

                        // Dereference any parent tries held in memory by this task
                        database.TrieDB().Dereference(res.rootRef)

                        // Stream completed traces to the user, aborting on the first error
                        for result, ok := done[next]; ok; result, ok = done[next] </span><span class="cov0" title="0">{
                                if len(result.Traces) &gt; 0 || next == end.NumberU64() </span><span class="cov0" title="0">{
                                        notifier.Notify(sub.ID, result)
                                }</span>
                                <span class="cov0" title="0">delete(done, next)
                                next++</span>
                        }
                }
        }()

        <span class="cov0" title="0">return sub, nil</span>
}

// same as TraceBlock, but only use 1 thread
func (hmy *Harmony) traceBlockNoThread(ctx context.Context, block *types.Block, config *TraceConfig) ([]*TxTraceResult, error) <span class="cov0" title="0">{
        // Create the parent state database
        if err := hmy.BlockChain.Engine().VerifyHeader(hmy.BlockChain, block.Header(), true); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">parent := hmy.BlockChain.GetBlock(block.ParentHash(), block.NumberU64()-1)
        if parent == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parent %#x not found", block.ParentHash())
        }</span>
        <span class="cov0" title="0">reexec := defaultTraceReexec
        if config != nil &amp;&amp; config.Reexec != nil </span><span class="cov0" title="0">{
                reexec = *config.Reexec
        }</span>
        <span class="cov0" title="0">statedb, err := hmy.ComputeStateDB(parent, reexec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Execute all the transaction contained within the block concurrently
        <span class="cov0" title="0">var (
                hmySigner = types.MakeSigner(hmy.BlockChain.Config(), block.Number())
                ethSigner = types.NewEIP155Signer(hmy.BlockChain.Config().EthCompatibleChainID)
                txs       = block.Transactions()
                results   = make([]*TxTraceResult, len(txs))
        )

        blockHash := block.Hash()
        // Feed the transactions into the tracers and return
        var failed error
traceLoop:
        for i, tx := range txs </span><span class="cov0" title="0">{
                signer := hmySigner
                if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                        signer = ethSigner
                }</span>
                // Generate the next state snapshot fast without tracing
                <span class="cov0" title="0">msg, _ := tx.AsMessage(signer)

                ethTx := tx.ConvertToEth()
                statedb.Prepare(ethTx.Hash(), blockHash, i)
                vmctx := core.NewEVMContext(msg, block.Header(), hmy.BlockChain, nil)
                res, err := hmy.TraceTx(ctx, msg, vmctx, statedb, config)
                if err != nil </span><span class="cov0" title="0">{
                        results[i] = &amp;TxTraceResult{Error: err.Error()}
                        failed = err
                        break</span>
                }
                <span class="cov0" title="0">results[i] = &amp;TxTraceResult{Result: res}
                // Finalize the state so any modifications are written to the trie
                statedb.Finalise(true)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        failed = errors.New("trace task was canceled!")
                        break traceLoop</span>
                default:<span class="cov0" title="0"></span>
                }
        }

        // If execution failed in between, abort
        <span class="cov0" title="0">if failed != nil </span><span class="cov0" title="0">{
                return nil, failed
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

// TraceBlock configures a new tracer according to the provided configuration, and
// executes all the transactions contained within. The return value will be one item
// per transaction, dependent on the requested tracer.
func (hmy *Harmony) TraceBlock(ctx context.Context, block *types.Block, config *TraceConfig) ([]*TxTraceResult, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, errors.New("canceled!")</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">if *config.Tracer == "ParityBlockTracer" </span><span class="cov0" title="0">{
                return hmy.traceBlockNoThread(ctx, block, config)
        }</span>
        // Create the parent state database
        <span class="cov0" title="0">if err := hmy.BlockChain.Engine().VerifyHeader(hmy.BlockChain, block.Header(), true); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">parent := hmy.BlockChain.GetBlock(block.ParentHash(), block.NumberU64()-1)
        if parent == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parent %#x not found", block.ParentHash())
        }</span>
        <span class="cov0" title="0">reexec := defaultTraceReexec
        if config != nil &amp;&amp; config.Reexec != nil </span><span class="cov0" title="0">{
                reexec = *config.Reexec
        }</span>
        <span class="cov0" title="0">statedb, err := hmy.ComputeStateDB(parent, reexec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Execute all the transaction contained within the block concurrently
        <span class="cov0" title="0">var (
                hmySigner = types.MakeSigner(hmy.BlockChain.Config(), block.Number())
                ethSigner = types.NewEIP155Signer(hmy.BlockChain.Config().EthCompatibleChainID)
                txs       = block.Transactions()
                results   = make([]*TxTraceResult, len(txs))

                pend = new(sync.WaitGroup)
                jobs = make(chan *txTraceTask, len(txs))
        )
        threads := runtime.NumCPU()
        if threads &gt; len(txs) </span><span class="cov0" title="0">{
                threads = len(txs)
        }</span>
        <span class="cov0" title="0">blockHash := block.Hash()
        for th := 0; th &lt; threads; th++ </span><span class="cov0" title="0">{
                pend.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer pend.Done()

                        // Fetch and execute the next transaction trace tasks
                        for task := range jobs </span><span class="cov0" title="0">{
                                signer := hmySigner
                                if txs[task.index].IsEthCompatible() </span><span class="cov0" title="0">{
                                        signer = ethSigner
                                }</span>

                                <span class="cov0" title="0">msg, _ := txs[task.index].AsMessage(signer)
                                vmctx := core.NewEVMContext(msg, block.Header(), hmy.BlockChain, nil)
                                ethTx := txs[task.index].ConvertToEth()
                                task.statedb.Prepare(ethTx.Hash(), blockHash, task.index)
                                res, err := hmy.TraceTx(ctx, msg, vmctx, task.statedb, config)
                                if err != nil </span><span class="cov0" title="0">{
                                        results[task.index] = &amp;TxTraceResult{Error: err.Error()}
                                        continue</span>
                                }
                                <span class="cov0" title="0">results[task.index] = &amp;TxTraceResult{Result: res}</span>
                        }
                }()
        }
        // Feed the transactions into the tracers and return
        <span class="cov0" title="0">var failed error
        for i, tx := range txs </span><span class="cov0" title="0">{
                // Send the trace task over for execution
                jobs &lt;- &amp;txTraceTask{statedb: statedb.Copy(), index: i}

                signer := hmySigner
                if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                        signer = ethSigner
                }</span>
                // Generate the next state snapshot fast without tracing
                <span class="cov0" title="0">msg, _ := tx.AsMessage(signer)
                statedb.Prepare(tx.Hash(), block.Hash(), i)
                vmctx := core.NewEVMContext(msg, block.Header(), hmy.BlockChain, nil)

                vmenv := vm.NewEVM(vmctx, statedb, hmy.BlockChain.Config(), vm.Config{})
                if _, err := core.ApplyMessage(vmenv, msg, new(core.GasPool).AddGas(msg.Gas())); err != nil </span><span class="cov0" title="0">{
                        failed = err
                        break</span>
                }
                // Finalize the state so any modifications are written to the trie
                <span class="cov0" title="0">statedb.Finalise(true)</span>
        }
        <span class="cov0" title="0">close(jobs)
        pend.Wait()

        // If execution failed in between, abort
        if failed != nil </span><span class="cov0" title="0">{
                return nil, failed
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

// standardTraceBlockToFile configures a new tracer which uses standard JSON output,
// and traces either a full block or an individual transaction. The return value will
// be one filename per transaction traced.
func (hmy *Harmony) standardTraceBlockToFile(ctx context.Context, block *types.Block, config *StdTraceConfig) ([]string, error) <span class="cov0" title="0">{
        // If we're tracing a single transaction, make sure it's present
        if config != nil &amp;&amp; config.TxHash != (common.Hash{}) </span><span class="cov0" title="0">{
                if !containsTx(block, config.TxHash) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transaction %#x not found in block", config.TxHash)
                }</span>
        }
        // Create the parent state database
        <span class="cov0" title="0">if err := hmy.BlockChain.Engine().VerifyHeader(hmy.BlockChain, block.Header(), true); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">parent := hmy.BlockChain.GetBlock(block.ParentHash(), block.NumberU64()-1)
        if parent == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parent %#x not found", block.ParentHash())
        }</span>
        <span class="cov0" title="0">reexec := defaultTraceReexec
        if config != nil &amp;&amp; config.Reexec != nil </span><span class="cov0" title="0">{
                reexec = *config.Reexec
        }</span>
        <span class="cov0" title="0">statedb, err := hmy.ComputeStateDB(parent, reexec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Retrieve the tracing configurations, or use default values
        <span class="cov0" title="0">var (
                logConfig vm.LogConfig
                txHash    common.Hash
        )
        if config != nil </span><span class="cov0" title="0">{
                if config.LogConfig != nil </span><span class="cov0" title="0">{
                        logConfig = *config.LogConfig
                }</span>
                <span class="cov0" title="0">txHash = config.TxHash</span>
        }
        <span class="cov0" title="0">logConfig.Debug = true

        // Execute transaction, either tracing all or just the requested one
        var (
                hmySigner = types.MakeSigner(hmy.BlockChain.Config(), block.Number())
                ethSigner = types.NewEIP155Signer(hmy.BlockChain.Config().EthCompatibleChainID)
                dumps     []string
        )
        for i, tx := range block.Transactions() </span><span class="cov0" title="0">{
                signer := hmySigner
                if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                        signer = ethSigner
                }</span>
                // Prepare the transaction for un-traced execution
                <span class="cov0" title="0">var (
                        msg, _ = tx.AsMessage(signer)
                        vmctx  = core.NewEVMContext(msg, block.Header(), hmy.BlockChain, nil)

                        vmConf vm.Config
                        dump   *os.File
                        writer *bufio.Writer
                        err    error
                )
                // If the transaction needs tracing, swap out the configs
                if tx.Hash() == txHash || txHash == (common.Hash{}) </span><span class="cov0" title="0">{
                        // Generate a unique temporary file to dump it into
                        prefix := fmt.Sprintf("block_%#x-%d-%#x-", block.Hash().Bytes()[:4], i, tx.Hash().Bytes()[:4])

                        dump, err = ioutil.TempFile(os.TempDir(), prefix)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">dumps = append(dumps, dump.Name())

                        // Swap out the noop logger to the standard tracer
                        writer = bufio.NewWriter(dump)
                        vmConf = vm.Config{
                                Debug:                   true,
                                Tracer:                  vm.NewJSONLogger(&amp;logConfig, writer),
                                EnablePreimageRecording: true,
                        }</span>
                }
                // Execute the transaction and flush any traces to disk
                <span class="cov0" title="0">vmenv := vm.NewEVM(vmctx, statedb, hmy.BlockChain.Config(), vmConf)
                _, err = core.ApplyMessage(vmenv, msg, new(core.GasPool).AddGas(msg.Gas()))
                if writer != nil </span><span class="cov0" title="0">{
                        writer.Flush()
                }</span>
                <span class="cov0" title="0">if dump != nil </span><span class="cov0" title="0">{
                        dump.Close()
                        utils.Logger().Info().Msg(fmt.Sprintf("Wrote standard trace file %s", dump.Name()))
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return dumps, err
                }</span>
                // Finalize the state so any modifications are written to the trie
                <span class="cov0" title="0">statedb.Finalise(true)

                // If we've traced the transaction we were looking for, abort
                if tx.Hash() == txHash </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return dumps, nil</span>
}

// containsTx reports whether the transaction with a certain hash
// is contained within the specified block.
func containsTx(block *types.Block, hash common.Hash) bool <span class="cov0" title="0">{
        for _, tx := range block.Transactions() </span><span class="cov0" title="0">{
                if tx.Hash() == hash </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ComputeStateDB retrieves the state database associated with a certain block.
// If no state is locally available for the given block, a number of blocks are
// attempted to be reexecuted to generate the desired state.
func (hmy *Harmony) ComputeStateDB(block *types.Block, reexec uint64) (*state.DB, error) <span class="cov0" title="0">{
        // If we have the state fully available, use that
        statedb, err := hmy.BlockChain.StateAt(block.Root())
        if err == nil </span><span class="cov0" title="0">{
                return statedb, nil
        }</span>
        // Otherwise try to reexec blocks until we find a state or reach our limit
        <span class="cov0" title="0">origin := block.NumberU64()
        database := state.NewDatabaseWithCache(hmy.BlockChain.ChainDb(), 16)

        for i := uint64(0); i &lt; reexec; i++ </span><span class="cov0" title="0">{
                block = hmy.BlockChain.GetBlock(block.ParentHash(), block.NumberU64()-1)
                if block == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if statedb, err = state.New(block.Root(), database); err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                switch err.(type) </span>{
                case *trie.MissingNodeError:<span class="cov0" title="0">
                        return nil, fmt.Errorf("required historical state unavailable (reexec=%d)", reexec)</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        // State was available at historical point, regenerate
        <span class="cov0" title="0">var (
                start  = time.Now()
                logged time.Time
                proot  common.Hash
        )
        for block.NumberU64() &lt; origin </span><span class="cov0" title="0">{
                // Print progress logs if long enough time elapsed
                if time.Since(logged) &gt; 8*time.Second </span><span class="cov0" title="0">{
                        utils.Logger().Info().
                                Uint64("block", block.NumberU64()).
                                Uint64("target", origin).
                                Uint64("remaining", origin-block.NumberU64()).
                                Float64("elasped", time.Since(start).Seconds()).
                                Msg(fmt.Sprintf("Regenerating historical state"))
                        logged = time.Now()
                }</span>
                // Retrieve the next block to regenerate and process it
                <span class="cov0" title="0">if block = hmy.BlockChain.GetBlockByNumber(block.NumberU64() + 1); block == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("block #%d not found", block.NumberU64()+1)
                }</span>
                <span class="cov0" title="0">_, _, _, _, _, _, _, err := hmy.BlockChain.Processor().Process(block, statedb, vm.Config{}, false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("processing block %d failed: %v", block.NumberU64(), err)
                }</span>
                // Finalize the state so any modifications are written to the trie
                <span class="cov0" title="0">root, err := statedb.Commit(true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := statedb.Reset(root); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("state reset after block %d failed: %v", block.NumberU64(), err)
                }</span>
                <span class="cov0" title="0">database.TrieDB().Reference(root, common.Hash{})
                if proot != (common.Hash{}) </span><span class="cov0" title="0">{
                        database.TrieDB().Dereference(proot)
                }</span>
                <span class="cov0" title="0">proot = root</span>
        }
        <span class="cov0" title="0">nodes, imgs := database.TrieDB().Size()
        utils.Logger().Info().
                Uint64("block", block.NumberU64()).
                Float64("elasped", time.Since(start).Seconds()).
                Float64("nodes", float64(nodes)).
                Float64("preimages", float64(imgs)).
                Msg("Historical state regenerated")
        return statedb, nil</span>
}

// TraceTx configures a new tracer according to the provided configuration, and
// executes the given message in the provided environment. The return value will
// be tracer dependent.
// NOTE: Only support default StructLogger tracer
func (hmy *Harmony) TraceTx(ctx context.Context, message core.Message, vmctx vm.Context, statedb *state.DB, config *TraceConfig) (interface{}, error) <span class="cov0" title="0">{
        // Assemble the structured logger or the JavaScript tracer
        var (
                tracer vm.Tracer
                err    error
        )
        switch </span>{
        case config != nil &amp;&amp; config.Tracer != nil:<span class="cov0" title="0">
                if *config.Tracer == "ParityBlockTracer" </span><span class="cov0" title="0">{
                        tracer = &amp;tracers.ParityBlockTracer{}
                        break</span>
                }
                // Define a meaningful timeout of a single transaction trace
                <span class="cov0" title="0">timeout := defaultTraceTimeout
                if config.Timeout != nil </span><span class="cov0" title="0">{
                        if timeout, err = time.ParseDuration(*config.Timeout); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                // Constuct the JavaScript tracer to execute with
                <span class="cov0" title="0">if tracer, err = tracers.New(*config.Tracer); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Handle timeouts and RPC cancellations
                <span class="cov0" title="0">deadlineCtx, cancel := context.WithTimeout(ctx, timeout)
                go func() </span><span class="cov0" title="0">{
                        &lt;-deadlineCtx.Done()
                        tracer.(*tracers.Tracer).Stop(errors.New("execution timeout"))
                }</span>()
                <span class="cov0" title="0">defer cancel()</span>

        case config == nil:<span class="cov0" title="0">
                tracer = vm.NewStructLogger(nil)</span>

        default:<span class="cov0" title="0">
                tracer = vm.NewStructLogger(config.LogConfig)</span>
        }
        // Run the transaction with tracing enabled.
        <span class="cov0" title="0">vmenv := vm.NewEVM(vmctx, statedb, hmy.BlockChain.Config(), vm.Config{Debug: true, Tracer: tracer})

        result, err := core.ApplyMessage(vmenv, message, new(core.GasPool).AddGas(message.Gas()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tracing failed: %v", err)
        }</span>
        // Depending on the tracer type, format and return the output
        <span class="cov0" title="0">switch tracer := tracer.(type) </span>{
        case *vm.StructLogger:<span class="cov0" title="0">
                return &amp;ExecutionResult{
                        Gas:         result.UsedGas,
                        Failed:      result.VMErr != nil,
                        ReturnValue: fmt.Sprintf("%x", result.ReturnData),
                        StructLogs:  FormatLogs(tracer.StructLogs()),
                }, nil</span>

        case *tracers.Tracer:<span class="cov0" title="0">
                return tracer.GetResult()</span>
        case *tracers.ParityBlockTracer:<span class="cov0" title="0">
                return tracer.GetResult()</span>

        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("bad tracer type %T", tracer))</span>
        }
}

// ComputeTxEnv returns the execution environment of a certain transaction.
func (hmy *Harmony) ComputeTxEnv(block *types.Block, txIndex int, reexec uint64) (core.Message, vm.Context, *state.DB, error) <span class="cov0" title="0">{
        // Create the parent state database
        parent := hmy.BlockChain.GetBlock(block.ParentHash(), block.NumberU64()-1)
        if parent == nil </span><span class="cov0" title="0">{
                return nil, vm.Context{}, nil, fmt.Errorf("parent %#x not found", block.ParentHash())
        }</span>
        <span class="cov0" title="0">statedb, err := hmy.ComputeStateDB(parent, reexec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, vm.Context{}, nil, err
        }</span>

        <span class="cov0" title="0">if txIndex == 0 &amp;&amp; len(block.Transactions()) == 0 </span><span class="cov0" title="0">{
                return nil, vm.Context{}, statedb, nil
        }</span>

        // Recompute transactions up to the target index.
        <span class="cov0" title="0">hmySigner := types.MakeSigner(hmy.BlockChain.Config(), block.Number())
        ethSigner := types.NewEIP155Signer(hmy.BlockChain.Config().EthCompatibleChainID)

        for idx, tx := range block.Transactions() </span><span class="cov0" title="0">{
                signer := hmySigner
                if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                        signer = ethSigner
                }</span>

                // Assemble the transaction call message and return if the requested offset
                <span class="cov0" title="0">msg, _ := tx.AsMessage(signer)
                context := core.NewEVMContext(msg, block.Header(), hmy.BlockChain, nil)
                if idx == txIndex </span><span class="cov0" title="0">{
                        return msg, context, statedb, nil
                }</span>
                // Not yet the searched for transaction, execute on top of the current state
                <span class="cov0" title="0">vmenv := vm.NewEVM(context, statedb, hmy.BlockChain.Config(), vm.Config{})
                if _, err := core.ApplyMessage(vmenv, msg, new(core.GasPool).AddGas(tx.GasLimit())); err != nil </span><span class="cov0" title="0">{
                        return nil, vm.Context{}, nil, fmt.Errorf("transaction %#x failed: %v", tx.Hash(), err)
                }</span>
                // Ensure any modifications are committed to the state
                <span class="cov0" title="0">statedb.Finalise(true)</span>
        }
        <span class="cov0" title="0">return nil, vm.Context{}, nil, fmt.Errorf("transaction index %d out of range for block %#x", txIndex, block.Hash())</span>
}

// ExecutionResult groups all structured logs emitted by the EVM
// while replaying a transaction in debug mode as well as transaction
// execution status, the amount of gas used and the return value
// Taken from go-ethereum/internal/ethapi/api.go
type ExecutionResult struct {
        Gas         uint64         `json:"gas"`
        Failed      bool           `json:"failed"`
        ReturnValue string         `json:"returnValue"`
        StructLogs  []StructLogRes `json:"structLogs"`
}

// StructLogRes stores a structured log emitted by the EVM while replaying a
// transaction in debug mode
type StructLogRes struct {
        Pc              uint64            `json:"pc"`
        Op              string            `json:"op"`
        CallerAddress   common.Address    `json:"callerAddress"`
        ContractAddress common.Address    `json:"contractAddress"`
        Gas             uint64            `json:"gas"`
        GasCost         uint64            `json:"gasCost"`
        Depth           int               `json:"depth"`
        Error           error             `json:"error,omitempty"`
        Stack           []string          `json:"stack,omitempty"`
        Memory          []string          `json:"memory,omitempty"`
        Storage         map[string]string `json:"storage,omitempty"`
}

// FormatLogs formats EVM returned structured logs for json output
func FormatLogs(logs []vm.StructLog) []StructLogRes <span class="cov0" title="0">{
        formatted := make([]StructLogRes, len(logs))
        for index, trace := range logs </span><span class="cov0" title="0">{
                formatted[index] = StructLogRes{
                        Pc:              trace.Pc,
                        Op:              trace.Op.String(),
                        CallerAddress:   trace.CallerAddress,
                        ContractAddress: trace.ContractAddress,
                        Gas:             trace.Gas,
                        GasCost:         trace.GasCost,
                        Depth:           trace.Depth,
                        Error:           trace.Err,
                }
                if trace.Stack != nil </span><span class="cov0" title="0">{
                        stack := make([]string, len(trace.Stack))
                        for i, stackValue := range trace.Stack </span><span class="cov0" title="0">{
                                stack[i] = fmt.Sprintf("%x", math.PaddedBigBytes(stackValue, 32))
                        }</span>
                        <span class="cov0" title="0">formatted[index].Stack = stack</span>
                }
                <span class="cov0" title="0">if trace.Memory != nil </span><span class="cov0" title="0">{
                        memory := make([]string, 0, (len(trace.Memory)+31)/32)
                        for i := 0; i+32 &lt;= len(trace.Memory); i += 32 </span><span class="cov0" title="0">{
                                memory = append(memory, fmt.Sprintf("%x", trace.Memory[i:i+32]))
                        }</span>
                        <span class="cov0" title="0">formatted[index].Memory = memory</span>
                }
                <span class="cov0" title="0">if trace.Storage != nil </span><span class="cov0" title="0">{
                        storage := make(map[string]string)
                        for i, storageValue := range trace.Storage </span><span class="cov0" title="0">{
                                storage[fmt.Sprintf("%x", i)] = fmt.Sprintf("%x", storageValue)
                        }</span>
                        <span class="cov0" title="0">formatted[index].Storage = storage</span>
                }
        }
        <span class="cov0" title="0">return formatted</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package params

import (
        "fmt"
        "math/big"
        "sync"

        "github.com/ethereum/go-ethereum/common"
)

// Well-known chain IDs.
var (
        MainnetChainID            = big.NewInt(1)
        TestnetChainID            = big.NewInt(2)
        PangaeaChainID            = big.NewInt(3)
        PartnerChainID            = big.NewInt(4)
        StressnetChainID          = big.NewInt(5)
        TestChainID               = big.NewInt(99)  // not a real network
        AllProtocolChangesChainID = big.NewInt(100) // not a real network

        // EthMainnetShard0ChainID to be reserved unique chain ID for eth compatible chains.
        EthMainnetShard0ChainID            = big.NewInt(1666600000)
        EthTestnetShard0ChainID            = big.NewInt(1666700000)
        EthPangaeaShard0ChainID            = big.NewInt(1666800000)
        EthPartnerShard0ChainID            = big.NewInt(1666900000)
        EthStressnetShard0ChainID          = big.NewInt(1667000000)
        EthTestShard0ChainID               = big.NewInt(1667100000) // not a real network
        EthAllProtocolChangesShard0ChainID = big.NewInt(1667200000) // not a real network
)

// EpochTBD is a large, â€œnot anytime soonâ€ epoch.  It used as a placeholder
// until the exact epoch is decided.
var EpochTBD = big.NewInt(10000000)
var once sync.Once

var (
        // MainnetChainConfig is the chain parameters to run a node on the main network.
        MainnetChainConfig = &amp;ChainConfig{
                ChainID:                    MainnetChainID,
                EthCompatibleChainID:       EthMainnetShard0ChainID,
                EthCompatibleShard0ChainID: EthMainnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(442), // Around Thursday Feb 4th 2020, 10AM PST
                CrossTxEpoch:               big.NewInt(28),
                CrossLinkEpoch:             big.NewInt(186),
                AggregatedRewardEpoch:      big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                StakingEpoch:               big.NewInt(186),
                PreStakingEpoch:            big.NewInt(185),
                QuickUnlockEpoch:           big.NewInt(191),
                FiveSecondsEpoch:           big.NewInt(230),
                TwoSecondsEpoch:            big.NewInt(366), // Around Tuesday Dec 8th 2020, 8AM PST
                SixtyPercentEpoch:          big.NewInt(530), // Around Monday Apr 12th 2021, 22:30 UTC
                RedelegationEpoch:          big.NewInt(290),
                NoEarlyUnlockEpoch:         big.NewInt(530), // Around Monday Apr 12th 2021, 22:30 UTC
                VRFEpoch:                   big.NewInt(631), // Around Wed July 7th 2021
                PrevVRFEpoch:               big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                MinDelegation100Epoch:      big.NewInt(631), // Around Wed July 7th 2021
                MinCommissionRateEpoch:     big.NewInt(631), // Around Wed July 7th 2021
                MinCommissionPromoPeriod:   big.NewInt(100),
                EPoSBound35Epoch:           big.NewInt(631), // Around Wed July 7th 2021
                EIP155Epoch:                big.NewInt(28),
                S3Epoch:                    big.NewInt(28),
                DataCopyFixEpoch:           big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                IstanbulEpoch:              big.NewInt(314),
                ReceiptLogEpoch:            big.NewInt(101),
                SHA3Epoch:                  big.NewInt(725), // Around Mon Oct 11 2021, 19:00 UTC
                HIP6And8Epoch:              big.NewInt(725), // Around Mon Oct 11 2021, 19:00 UTC
                StakingPrecompileEpoch:     EpochTBD,
        }

        // TestnetChainConfig contains the chain parameters to run a node on the harmony test network.
        TestnetChainConfig = &amp;ChainConfig{
                ChainID:                    TestnetChainID,
                EthCompatibleChainID:       EthTestnetShard0ChainID,
                EthCompatibleShard0ChainID: EthTestnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(73290),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(74275),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(16500),
                TwoSecondsEpoch:            big.NewInt(73000),
                SixtyPercentEpoch:          big.NewInt(73282),
                RedelegationEpoch:          big.NewInt(36500),
                NoEarlyUnlockEpoch:         big.NewInt(73580),
                VRFEpoch:                   big.NewInt(73880),
                PrevVRFEpoch:               big.NewInt(74384),
                MinDelegation100Epoch:      big.NewInt(73880),
                MinCommissionRateEpoch:     big.NewInt(73880),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(73880),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(74412),
                IstanbulEpoch:              big.NewInt(43800),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(74570),
                HIP6And8Epoch:              big.NewInt(74570),
                StakingPrecompileEpoch:     EpochTBD,
        }

        // PangaeaChainConfig contains the chain parameters for the Pangaea network.
        // All features except for CrossLink are enabled at launch.
        PangaeaChainConfig = &amp;ChainConfig{
                ChainID:                    PangaeaChainID,
                EthCompatibleChainID:       EthPangaeaShard0ChainID,
                EthCompatibleShard0ChainID: EthPangaeaShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(0),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:     big.NewInt(2), // same as staking
        }

        // PartnerChainConfig contains the chain parameters for the Partner network.
        // All features except for CrossLink are enabled at launch.
        PartnerChainConfig = &amp;ChainConfig{
                ChainID:                    PartnerChainID,
                EthCompatibleChainID:       EthPartnerShard0ChainID,
                EthCompatibleShard0ChainID: EthPartnerShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(4),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:     big.NewInt(2),
        }

        // StressnetChainConfig contains the chain parameters for the Stress test network.
        // All features except for CrossLink are enabled at launch.
        StressnetChainConfig = &amp;ChainConfig{
                ChainID:                    StressnetChainID,
                EthCompatibleChainID:       EthStressnetShard0ChainID,
                EthCompatibleShard0ChainID: EthStressnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(10),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:     big.NewInt(2),
        }

        // LocalnetChainConfig contains the chain parameters to run for local development.
        LocalnetChainConfig = &amp;ChainConfig{
                ChainID:                    TestnetChainID,
                EthCompatibleChainID:       EthTestnetShard0ChainID,
                EthCompatibleShard0ChainID: EthTestnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(0),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(3),
                SixtyPercentEpoch:          EpochTBD, // Never enable it for localnet as localnet has no external validator setup
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              EpochTBD, // Never enable it for localnet as localnet has no external validator setup
                StakingPrecompileEpoch:     big.NewInt(2),
        }

        // AllProtocolChanges ...
        // This configuration is intentionally not using keyed fields to force anyone
        // adding flags to the config to also have to set these fields.
        AllProtocolChanges = &amp;ChainConfig{
                AllProtocolChangesChainID,          // ChainID
                EthAllProtocolChangesShard0ChainID, // EthCompatibleChainID
                EthAllProtocolChangesShard0ChainID, // EthCompatibleShard0ChainID
                big.NewInt(0),                      // EthCompatibleEpoch
                big.NewInt(0),                      // CrossTxEpoch
                big.NewInt(0),                      // CrossLinkEpoch
                big.NewInt(0),                      // AggregatedRewardEpoch
                big.NewInt(0),                      // StakingEpoch
                big.NewInt(0),                      // PreStakingEpoch
                big.NewInt(0),                      // QuickUnlockEpoch
                big.NewInt(0),                      // FiveSecondsEpoch
                big.NewInt(0),                      // TwoSecondsEpoch
                big.NewInt(0),                      // SixtyPercentEpoch
                big.NewInt(0),                      // RedelegationEpoch
                big.NewInt(0),                      // NoEarlyUnlockEpoch
                big.NewInt(0),                      // VRFEpoch
                big.NewInt(0),                      // PrevVRFEpoch
                big.NewInt(0),                      // MinDelegation100Epoch
                big.NewInt(0),                      // MinCommissionRateEpoch
                big.NewInt(10),                     // MinCommissionPromoPeriod
                big.NewInt(0),                      // EPoSBound35Epoch
                big.NewInt(0),                      // EIP155Epoch
                big.NewInt(0),                      // S3Epoch
                big.NewInt(0),                      // DataCopyFixEpoch
                big.NewInt(0),                      // IstanbulEpoch
                big.NewInt(0),                      // ReceiptLogEpoch
                big.NewInt(0),                      // SHA3Epoch
                big.NewInt(0),                      // HIP6And8Epoch
                big.NewInt(0),                      // StakingPrecompileEpoch
        }

        // TestChainConfig ...
        // This configuration is intentionally not using keyed fields to force anyone
        // adding flags to the config to also have to set these fields.
        TestChainConfig = &amp;ChainConfig{
                TestChainID,          // ChainID
                EthTestShard0ChainID, // EthCompatibleChainID
                EthTestShard0ChainID, // EthCompatibleShard0ChainID
                big.NewInt(0),        // EthCompatibleEpoch
                big.NewInt(0),        // CrossTxEpoch
                big.NewInt(0),        // CrossLinkEpoch
                big.NewInt(0),        // AggregatedRewardEpoch
                big.NewInt(0),        // StakingEpoch
                big.NewInt(0),        // PreStakingEpoch
                big.NewInt(0),        // QuickUnlockEpoch
                big.NewInt(0),        // FiveSecondsEpoch
                big.NewInt(0),        // TwoSecondsEpoch
                big.NewInt(0),        // SixtyPercentEpoch
                big.NewInt(0),        // RedelegationEpoch
                big.NewInt(0),        // NoEarlyUnlockEpoch
                big.NewInt(0),        // VRFEpoch
                big.NewInt(0),        // PrevVRFEpoch
                big.NewInt(0),        // MinDelegation100Epoch
                big.NewInt(0),        // MinCommissionRateEpoch
                big.NewInt(10),       // MinCommissionPromoPeriod
                big.NewInt(0),        // EPoSBound35Epoch
                big.NewInt(0),        // EIP155Epoch
                big.NewInt(0),        // S3Epoch
                big.NewInt(0),        // DataCopyFixEpoch
                big.NewInt(0),        // IstanbulEpoch
                big.NewInt(0),        // ReceiptLogEpoch
                big.NewInt(0),        // SHA3Epoch
                big.NewInt(0),        // HIP6And8Epoch
                big.NewInt(0),        // StakingPrecompileEpoch
        }

        // TestRules ...
        TestRules = TestChainConfig.Rules(new(big.Int))
)

// TrustedCheckpoint represents a set of post-processed trie roots (CHT and
// BloomTrie) associated with the appropriate section index and head hash. It is
// used to start light syncing from this checkpoint and avoid downloading the
// entire header chain while still being able to securely access old headers/logs.
type TrustedCheckpoint struct {
        Name         string      `json:"-"`
        SectionIndex uint64      `json:"sectionIndex"`
        SectionHead  common.Hash `json:"sectionHead"`
        CHTRoot      common.Hash `json:"chtRoot"`
        BloomRoot    common.Hash `json:"bloomRoot"`
}

// ChainConfig is the core config which determines the blockchain settings.
//
// ChainConfig is stored in the database on a per block basis. This means
// that any network, identified by its genesis block, can have its own
// set of configuration options.
type ChainConfig struct {
        // ChainId identifies the current chain and is used for replay protection
        ChainID *big.Int `json:"chain-id"`

        // EthCompatibleChainID identifies the chain id used for ethereum compatible transactions
        EthCompatibleChainID *big.Int `json:"eth-compatible-chain-id"`

        // EthCompatibleShard0ChainID identifies the shard 0 chain id used for ethereum compatible transactions
        EthCompatibleShard0ChainID *big.Int `json:"eth-compatible-shard-0-chain-id"`

        // EthCompatibleEpoch is the epoch where ethereum-compatible transaction starts being
        // processed.
        EthCompatibleEpoch *big.Int `json:"eth-compatible-epoch,omitempty"`

        // CrossTxEpoch is the epoch where cross-shard transaction starts being
        // processed.
        CrossTxEpoch *big.Int `json:"cross-tx-epoch,omitempty"`

        // CrossLinkEpoch is the epoch where beaconchain starts containing
        // cross-shard links.
        CrossLinkEpoch *big.Int `json:"cross-link-epoch,omitempty"`

        // AggregatedRewardEpoch is the epoch when block rewards are distributed every 64 blocks
        AggregatedRewardEpoch *big.Int `json:"aggregated-reward-epoch,omitempty"`

        // StakingEpoch is the epoch when shard assign takes staking into account
        StakingEpoch *big.Int `json:"staking-epoch,omitempty"`

        // PreStakingEpoch is the epoch we allow staking transactions
        PreStakingEpoch *big.Int `json:"prestaking-epoch,omitempty"`

        // QuickUnlockEpoch is the epoch when undelegation will be unlocked at the current epoch
        QuickUnlockEpoch *big.Int `json:"quick-unlock-epoch,omitempty"`

        // FiveSecondsEpoch is the epoch when block time is reduced to 5 seconds
        // and block rewards adjusted to 17.5 ONE/block
        FiveSecondsEpoch *big.Int `json:"five-seconds-epoch,omitempty"`

        // TwoSecondsEpoch is the epoch when block time is reduced to 2 seconds
        // and block rewards adjusted to 7 ONE/block
        TwoSecondsEpoch *big.Int `json:"two-seconds-epoch,omitempty"`

        // SixtyPercentEpoch is the epoch when internal voting power reduced from 68% to 60%
        SixtyPercentEpoch *big.Int `json:"sixty-percent-epoch,omitempty"`

        // RedelegationEpoch is the epoch when redelegation is supported and undelegation locking time
        // is restored to 7 epoch
        RedelegationEpoch *big.Int `json:"redelegation-epoch,omitempty"`

        // NoEarlyUnlockEpoch is the epoch when the early unlock of undelegated token from validators who were elected for
        // more than 7 epochs is disabled
        NoEarlyUnlockEpoch *big.Int `json:"no-early-unlock-epoch,omitempty"`

        // VRFEpoch is the epoch when VRF randomness is enabled
        VRFEpoch *big.Int `json:"vrf-epoch,omitempty"`

        // PrevVRFEpoch is the epoch when previous VRF randomness can be fetched
        PrevVRFEpoch *big.Int `json:"prev-vrf-epoch,omitempty"`

        // MinDelegation100Epoch is the epoch when min delegation is reduced from 1000 ONE to 100 ONE
        MinDelegation100Epoch *big.Int `json:"min-delegation-100-epoch,omitempty"`

        // MinCommissionRateEpoch is the epoch when policy for minimum comission rate of 5% is started
        MinCommissionRateEpoch *big.Int `json:"min-commission-rate-epoch,omitempty"`

        // MinCommissionPromoPeriod is the number of epochs when newly elected validators can have 0% commission
        MinCommissionPromoPeriod *big.Int `json:"commission-promo-period,omitempty"`

        // EPoSBound35Epoch is the epoch when the EPoS bound parameter c is changed from 15% to 35%
        EPoSBound35Epoch *big.Int `json:"epos-bound-35-epoch,omitempty"`

        // EIP155 hard fork epoch (include EIP158 too)
        EIP155Epoch *big.Int `json:"eip155-epoch,omitempty"`

        // S3 epoch is the first epoch containing S3 mainnet and all ethereum update up to Constantinople
        S3Epoch *big.Int `json:"s3-epoch,omitempty"`

        // DataCopyFix epoch is the first epoch containing fix for evm datacopy bug.
        DataCopyFixEpoch *big.Int `json:"data-copy-fix-epoch,omitempty"`

        // Istanbul epoch
        IstanbulEpoch *big.Int `json:"istanbul-epoch,omitempty"`

        // ReceiptLogEpoch is the first epoch support receiptlog
        ReceiptLogEpoch *big.Int `json:"receipt-log-epoch,omitempty"`

        // IsSHA3Epoch is the first epoch in supporting SHA3 FIPS-202 standard
        SHA3Epoch *big.Int `json:"sha3-epoch,omitempty"`

        // IsHIP6And8Epoch is the first epoch to support HIP-6 and HIP-8
        HIP6And8Epoch *big.Int `json:"hip6_8-epoch,omitempty"`

        // StakingPrecompileEpoch is the first epoch to support the staking precompiles
        StakingPrecompileEpoch *big.Int `json:"staking-precompile-epoch,omitempty"`
}

// String implements the fmt.Stringer interface.
func (c *ChainConfig) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("{ChainID: %v EthCompatibleChainID: %v EIP155: %v CrossTx: %v Staking: %v CrossLink: %v ReceiptLog: %v SHA3Epoch: %v StakingPrecompileEpoch: %v}",
                c.ChainID,
                c.EthCompatibleChainID,
                c.EIP155Epoch,
                c.CrossTxEpoch,
                c.StakingEpoch,
                c.CrossLinkEpoch,
                c.ReceiptLogEpoch,
                c.SHA3Epoch,
                c.StakingPrecompileEpoch,
        )
}</span>

// IsEIP155 returns whether epoch is either equal to the EIP155 fork epoch or greater.
func (c *ChainConfig) IsEIP155(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.EIP155Epoch, epoch)
}</span>

// AcceptsCrossTx returns whether cross-shard transaction is accepted in the
// given epoch.
//
// Note that this is different from comparing epoch against CrossTxEpoch.
// Cross-shard transaction is accepted from CrossTxEpoch+1 and on, in order to
// allow for all shards to roll into CrossTxEpoch and become able to handle
// ingress receipts.  In other words, cross-shard transaction fields are
// introduced and ingress receipts are processed at CrossTxEpoch, but the shard
// does not accept cross-shard transactions from clients until CrossTxEpoch+1.
func (c *ChainConfig) AcceptsCrossTx(epoch *big.Int) bool <span class="cov8" title="1">{
        crossTxEpoch := new(big.Int).Add(c.CrossTxEpoch, common.Big1)
        return isForked(crossTxEpoch, epoch)
}</span>

// HasCrossTxFields returns whether blocks in the given epoch includes
// cross-shard transaction fields.
func (c *ChainConfig) HasCrossTxFields(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.CrossTxEpoch, epoch)
}</span>

// IsEthCompatible determines whether it is ethereum compatible epoch
func (c *ChainConfig) IsEthCompatible(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.EthCompatibleEpoch, epoch)
}</span>

// IsAggregatedRewardEpoch determines whether it is the epoch when rewards are distributed every 64 blocks
func (c *ChainConfig) IsAggregatedRewardEpoch(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.AggregatedRewardEpoch, epoch)
}</span>

// IsStaking determines whether it is staking epoch
func (c *ChainConfig) IsStaking(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.StakingEpoch, epoch)
}</span>

// IsFiveSeconds determines whether it is the epoch to change to 5 seconds block time
func (c *ChainConfig) IsFiveSeconds(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.FiveSecondsEpoch, epoch)
}</span>

// IsTwoSeconds determines whether it is the epoch to change to 3 seconds block time
func (c *ChainConfig) IsTwoSeconds(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.TwoSecondsEpoch, epoch)
}</span>

// IsSixtyPercent determines whether it is the epoch to reduce internal voting power to 60%
func (c *ChainConfig) IsSixtyPercent(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.SixtyPercentEpoch, epoch)
}</span>

// IsRedelegation determines whether it is the epoch to support redelegation
func (c *ChainConfig) IsRedelegation(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.RedelegationEpoch, epoch)
}</span>

// IsNoEarlyUnlock determines whether it is the epoch to stop early unlock
func (c *ChainConfig) IsNoEarlyUnlock(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.NoEarlyUnlockEpoch, epoch)
}</span>

// IsVRF determines whether it is the epoch to enable vrf
func (c *ChainConfig) IsVRF(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.VRFEpoch, epoch)
}</span>

// IsPrevVRF determines whether it is the epoch to enable previous vrf
func (c *ChainConfig) IsPrevVRF(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.PrevVRFEpoch, epoch)
}</span>

// IsMinDelegation100 determines whether it is the epoch to reduce min delegation to 100
func (c *ChainConfig) IsMinDelegation100(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.MinDelegation100Epoch, epoch)
}</span>

// IsMinCommissionRate determines whether it is the epoch to start the policy of 5% min commission
func (c *ChainConfig) IsMinCommissionRate(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.MinCommissionRateEpoch, epoch)
}</span>

// IsEPoSBound35 determines whether it is the epoch to extend the EPoS bound to 35%
func (c *ChainConfig) IsEPoSBound35(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.EPoSBound35Epoch, epoch)
}</span>

// IsPreStaking determines whether staking transactions are allowed
func (c *ChainConfig) IsPreStaking(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.PreStakingEpoch, epoch)
}</span>

// IsQuickUnlock determines whether it's the epoch when the undelegation should be unlocked at end of current epoch
func (c *ChainConfig) IsQuickUnlock(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.QuickUnlockEpoch, epoch)
}</span>

// IsCrossLink returns whether epoch is either equal to the CrossLink fork epoch or greater.
func (c *ChainConfig) IsCrossLink(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.CrossLinkEpoch, epoch)
}</span>

// IsS3 returns whether epoch is either equal to the S3 fork epoch or greater.
func (c *ChainConfig) IsS3(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.S3Epoch, epoch)
}</span>

// IsDataCopyFixEpoch returns whether epoch has the fix for DataCopy evm bug.
func (c *ChainConfig) IsDataCopyFixEpoch(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.DataCopyFixEpoch, epoch)
}</span>

// IsIstanbul returns whether epoch is either equal to the Istanbul fork epoch or greater.
func (c *ChainConfig) IsIstanbul(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.IstanbulEpoch, epoch)
}</span>

// IsReceiptLog returns whether epoch is either equal to the ReceiptLog fork epoch or greater.
func (c *ChainConfig) IsReceiptLog(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.ReceiptLogEpoch, epoch)
}</span>

// IsSHA3 returns whether epoch is either equal to the IsSHA3 fork epoch or greater.
func (c *ChainConfig) IsSHA3(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.SHA3Epoch, epoch)
}</span>

// IsHIP6And8Epoch determines whether it is the epoch to support
// HIP-6: reduce the internal voting power from 60% to 49%
// HIP-8: increase external nodes from 800 to 900
func (c *ChainConfig) IsHIP6And8Epoch(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.HIP6And8Epoch, epoch)
}</span>

// IsStakingPrecompileEpoch determines whether staking
// precompiles are available in the EVM
func (c *ChainConfig) IsStakingPrecompile(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.StakingPrecompileEpoch, epoch)
}</span>

// UpdateEthChainIDByShard update the ethChainID based on shard ID.
func UpdateEthChainIDByShard(shardID uint32) <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                MainnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(MainnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                TestnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(TestnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                PangaeaChainConfig.EthCompatibleChainID = big.NewInt(0).Add(PangaeaChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                PartnerChainConfig.EthCompatibleChainID = big.NewInt(0).Add(PartnerChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                StressnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(StressnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                LocalnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(LocalnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                AllProtocolChanges.EthCompatibleChainID = big.NewInt(0).Add(AllProtocolChanges.EthCompatibleChainID, big.NewInt(int64(shardID)))
                TestChainConfig.EthCompatibleChainID = big.NewInt(0).Add(TestChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
        }</span>)
}

// IsEthCompatible returns whether the chainID is for ethereum compatible txn or not
func IsEthCompatible(chainID *big.Int) bool <span class="cov8" title="1">{
        return chainID.Cmp(EthMainnetShard0ChainID) &gt;= 0
}</span>

// GasTable returns the gas table corresponding to the current phase (homestead or homestead reprice).
//
// The returned GasTable's fields shouldn't, under any circumstances, be changed.
func (c *ChainConfig) GasTable(epoch *big.Int) GasTable <span class="cov0" title="0">{
        if epoch == nil </span><span class="cov0" title="0">{
                return GasTableR3
        }</span>
        <span class="cov0" title="0">switch </span>{
        case c.IsS3(epoch):<span class="cov0" title="0">
                return GasTableS3</span>
        default:<span class="cov0" title="0">
                return GasTableR3</span>
        }
}

// isForked returns whether a fork scheduled at epoch s is active at the given head epoch.
func isForked(s, epoch *big.Int) bool <span class="cov8" title="1">{
        if s == nil || epoch == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return s.Cmp(epoch) &lt;= 0</span>
}

// Rules wraps ChainConfig and is merely syntactic sugar or can be used for functions
// that do not have or require information about the block.
//
// Rules is a one time interface meaning that it shouldn't be used in between transition
// phases.
type Rules struct {
        ChainID                                                                                              *big.Int
        EthChainID                                                                                           *big.Int
        IsCrossLink, IsEIP155, IsS3, IsReceiptLog, IsIstanbul, IsVRF, IsPrevVRF, IsSHA3, IsStakingPrecompile bool
}

// Rules ensures c's ChainID is not nil.
func (c *ChainConfig) Rules(epoch *big.Int) Rules <span class="cov8" title="1">{
        if c.IsStakingPrecompile(epoch) </span><span class="cov8" title="1">{
                if !c.IsPreStaking(epoch) </span><span class="cov0" title="0">{
                        panic("Cannot have staking precompile epoch if not prestaking epoch")</span>
                }
        }
        <span class="cov8" title="1">chainID := c.ChainID
        if chainID == nil </span><span class="cov0" title="0">{
                chainID = new(big.Int)
        }</span>
        <span class="cov8" title="1">ethChainID := c.EthCompatibleChainID
        if ethChainID == nil </span><span class="cov0" title="0">{
                ethChainID = new(big.Int)
        }</span>
        <span class="cov8" title="1">return Rules{
                ChainID:             new(big.Int).Set(chainID),
                EthChainID:          new(big.Int).Set(ethChainID),
                IsCrossLink:         c.IsCrossLink(epoch),
                IsEIP155:            c.IsEIP155(epoch),
                IsS3:                c.IsS3(epoch),
                IsReceiptLog:        c.IsReceiptLog(epoch),
                IsIstanbul:          c.IsIstanbul(epoch),
                IsVRF:               c.IsVRF(epoch),
                IsPrevVRF:           c.IsPrevVRF(epoch),
                IsSHA3:              c.IsSHA3(epoch),
                IsStakingPrecompile: c.IsStakingPrecompile(epoch),
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package worker

import (
        "bytes"
        "fmt"
        "math/big"
        "sort"
        "time"

        "github.com/harmony-one/harmony/consensus/reward"

        "github.com/harmony-one/harmony/consensus"

        "github.com/harmony-one/harmony/crypto/bls"

        "github.com/harmony-one/harmony/crypto/hash"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/block"
        blockfactory "github.com/harmony-one/harmony/block/factory"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/core"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        common2 "github.com/harmony-one/harmony/internal/common"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

// environment is the worker's current environment and holds all of the current state information.
type environment struct {
        signer     types.Signer
        ethSigner  types.Signer
        state      *state.DB     // apply state changes here
        gasPool    *core.GasPool // available gas used to pack transactions
        header     *block.Header
        txs        []*types.Transaction
        stakingTxs []*staking.StakingTransaction
        receipts   []*types.Receipt
        logs       []*types.Log
        reward     reward.Reader
        outcxs     []*types.CXReceipt       // cross shard transaction receipts (source shard)
        incxs      []*types.CXReceiptsProof // cross shard receipts and its proof (desitinatin shard)
        slashes    slash.Records
        stakeMsgs  []staking.StakeMsg
}

// Worker is the main object which takes care of submitting new work to consensus engine
// and gathering the sealing result.
type Worker struct {
        config   *params.ChainConfig
        factory  blockfactory.Factory
        chain    *core.BlockChain
        current  *environment // An environment for current running cycle.
        engine   consensus_engine.Engine
        gasFloor uint64
        gasCeil  uint64
}

// CommitSortedTransactions commits transactions for new block.
func (w *Worker) CommitSortedTransactions(
        txs *types.TransactionsByPriceAndNonce,
        coinbase common.Address,
) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                // If we don't have enough gas for any further transactions then we're done
                if w.current.gasPool.Gas() &lt; params.TxGas </span><span class="cov0" title="0">{
                        utils.Logger().Info().Uint64("have", w.current.gasPool.Gas()).Uint64("want", params.TxGas).Msg("Not enough gas for further transactions")
                        break</span>
                }
                // Retrieve the next transaction and abort if all done
                <span class="cov8" title="1">tx := txs.Peek()
                if tx == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                // Error may be ignored here. The error has already been checked
                // during transaction acceptance is the transaction pool.
                // We use the eip155 signer regardless of the current hf.
                <span class="cov8" title="1">signer := w.current.signer
                if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                        signer = w.current.ethSigner
                }</span>
                <span class="cov8" title="1">from, _ := types.Sender(signer, tx)
                // Check whether the tx is replay protected. If we're not in the EIP155 hf
                // phase, start ignoring the sender until we do.
                if tx.Protected() &amp;&amp; !w.config.IsEIP155(w.current.header.Epoch()) </span><span class="cov0" title="0">{
                        utils.Logger().Info().Str("hash", tx.Hash().Hex()).Str("eip155Epoch", w.config.EIP155Epoch.String()).Msg("Ignoring reply protected transaction")
                        txs.Pop()
                        continue</span>
                }

                <span class="cov8" title="1">if tx.ShardID() != w.chain.ShardID() </span><span class="cov0" title="0">{
                        txs.Shift()
                        continue</span>
                }

                // Start executing the transaction
                <span class="cov8" title="1">w.current.state.Prepare(tx.Hash(), common.Hash{}, len(w.current.txs))
                err := w.commitTransaction(tx, coinbase)

                sender, _ := common2.AddressToBech32(from)
                switch err </span>{
                case core.ErrGasLimitReached:<span class="cov0" title="0">
                        // Pop the current out-of-gas transaction without shifting in the next from the account
                        utils.Logger().Info().Str("sender", sender).Msg("Gas limit exceeded for current block")
                        txs.Pop()</span>

                case core.ErrNonceTooLow:<span class="cov0" title="0">
                        // New head notification data race between the transaction pool and miner, shift
                        utils.Logger().Info().Str("sender", sender).Uint64("nonce", tx.Nonce()).Msg("Skipping transaction with low nonce")
                        txs.Shift()</span>

                case core.ErrNonceTooHigh:<span class="cov0" title="0">
                        // Reorg notification data race between the transaction pool and miner, skip account =
                        utils.Logger().Info().Str("sender", sender).Uint64("nonce", tx.Nonce()).Msg("Skipping account with high nonce")
                        txs.Pop()</span>

                case nil:<span class="cov8" title="1">
                        // Everything ok, collect the logs and shift in the next transaction from the same account
                        txs.Shift()</span>

                default:<span class="cov0" title="0">
                        // Strange error, discard the transaction and get the next in line (note, the
                        // nonce-too-high clause will prevent us from executing in vain).
                        utils.Logger().Info().Str("hash", tx.Hash().Hex()).AnErr("err", err).Msg("Transaction failed, account skipped")
                        txs.Shift()</span>
                }
        }
}

// CommitTransactions commits transactions for new block.
func (w *Worker) CommitTransactions(
        pendingNormal map[common.Address]types.Transactions,
        pendingStaking staking.StakingTransactions, coinbase common.Address,
) error <span class="cov8" title="1">{
        if w.current.gasPool == nil </span><span class="cov8" title="1">{
                w.current.gasPool = new(core.GasPool).AddGas(w.current.header.GasLimit())
        }</span>

        // HARMONY TXNS
        <span class="cov8" title="1">normalTxns := types.NewTransactionsByPriceAndNonce(w.current.signer, w.current.ethSigner, pendingNormal)

        w.CommitSortedTransactions(normalTxns, coinbase)

        // STAKING - only beaconchain process staking transaction
        if w.chain.ShardID() == shard.BeaconChainShardID </span><span class="cov8" title="1">{
                for _, tx := range pendingStaking </span><span class="cov0" title="0">{
                        // If we don't have enough gas for any further transactions then we're done
                        if w.current.gasPool.Gas() &lt; params.TxGas </span><span class="cov0" title="0">{
                                utils.Logger().Info().Uint64("have", w.current.gasPool.Gas()).Uint64("want", params.TxGas).Msg("Not enough gas for further transactions")
                                break</span>
                        }
                        // Check whether the tx is replay protected. If we're not in the EIP155 hf
                        // phase, start ignoring the sender until we do.
                        <span class="cov0" title="0">if tx.Protected() &amp;&amp; !w.config.IsEIP155(w.current.header.Epoch()) </span><span class="cov0" title="0">{
                                utils.Logger().Info().Str("hash", tx.Hash().Hex()).Str("eip155Epoch", w.config.EIP155Epoch.String()).Msg("Ignoring reply protected transaction")
                                continue</span>
                        }

                        // Start executing the transaction
                        <span class="cov0" title="0">w.current.state.Prepare(tx.Hash(), common.Hash{}, len(w.current.txs)+len(w.current.stakingTxs))
                        // THESE CODE ARE DUPLICATED AS ABOVE&gt;&gt;
                        if err := w.commitStakingTransaction(tx, coinbase); err != nil </span><span class="cov0" title="0">{
                                txID := tx.Hash().Hex()
                                utils.Logger().Error().Err(err).
                                        Str("stakingTxID", txID).
                                        Interface("stakingTx", tx).
                                        Msg("Failed committing staking transaction")
                        }</span> else<span class="cov0" title="0"> {
                                utils.Logger().Info().Str("stakingTxId", tx.Hash().Hex()).
                                        Uint64("txGasLimit", tx.GasLimit()).
                                        Msg("Successfully committed staking transaction")
                        }</span>
                }
        }

        <span class="cov8" title="1">utils.Logger().Info().
                Int("newTxns", len(w.current.txs)).
                Int("newStakingTxns", len(w.current.stakingTxs)).
                Uint64("blockGasLimit", w.current.header.GasLimit()).
                Uint64("blockGasUsed", w.current.header.GasUsed()).
                Msg("Block gas limit and usage info")
        return nil</span>
}

func (w *Worker) commitStakingTransaction(
        tx *staking.StakingTransaction, coinbase common.Address,
) error <span class="cov0" title="0">{
        snap := w.current.state.Snapshot()
        gasUsed := w.current.header.GasUsed()
        receipt, _, err := core.ApplyStakingTransaction(
                w.config, w.chain, &amp;coinbase, w.current.gasPool,
                w.current.state, w.current.header, tx, &amp;gasUsed, vm.Config{},
        )
        w.current.header.SetGasUsed(gasUsed)
        if err != nil </span><span class="cov0" title="0">{
                w.current.state.RevertToSnapshot(snap)
                utils.Logger().Error().
                        Err(err).Interface("stkTxn", tx).
                        Msg("Staking transaction failed commitment")
                return err
        }</span>
        <span class="cov0" title="0">if receipt == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("nil staking receipt")
        }</span>

        <span class="cov0" title="0">w.current.stakingTxs = append(w.current.stakingTxs, tx)
        w.current.receipts = append(w.current.receipts, receipt)
        w.current.logs = append(w.current.logs, receipt.Logs...)

        return nil</span>
}

var (
        errNilReceipt = errors.New("nil receipt")
)

func (w *Worker) commitTransaction(
        tx *types.Transaction, coinbase common.Address,
) error <span class="cov8" title="1">{
        snap := w.current.state.Snapshot()
        gasUsed := w.current.header.GasUsed()
        receipt, cx, stakeMsgs, _, err := core.ApplyTransaction(
                w.config,
                w.chain,
                &amp;coinbase,
                w.current.gasPool,
                w.current.state,
                w.current.header,
                tx,
                &amp;gasUsed,
                vm.Config{},
        )
        w.current.header.SetGasUsed(gasUsed)
        if err != nil </span><span class="cov0" title="0">{
                w.current.state.RevertToSnapshot(snap)
                utils.Logger().Error().
                        Err(err).Interface("txn", tx).
                        Msg("Transaction failed commitment")
                return errNilReceipt
        }</span>
        <span class="cov8" title="1">if receipt == nil </span><span class="cov0" title="0">{
                utils.Logger().Warn().Interface("tx", tx).Interface("cx", cx).Msg("Receipt is Nil!")
                return errNilReceipt
        }</span>

        <span class="cov8" title="1">w.current.txs = append(w.current.txs, tx)
        w.current.receipts = append(w.current.receipts, receipt)
        w.current.logs = append(w.current.logs, receipt.Logs...)
        w.current.stakeMsgs = append(w.current.stakeMsgs, stakeMsgs...)

        if cx != nil </span><span class="cov0" title="0">{
                w.current.outcxs = append(w.current.outcxs, cx)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CommitReceipts commits a list of already verified incoming cross shard receipts
func (w *Worker) CommitReceipts(receiptsList []*types.CXReceiptsProof) error <span class="cov0" title="0">{
        if w.current.gasPool == nil </span><span class="cov0" title="0">{
                w.current.gasPool = new(core.GasPool).AddGas(w.current.header.GasLimit())
        }</span>

        <span class="cov0" title="0">if len(receiptsList) == 0 </span><span class="cov0" title="0">{
                w.current.header.SetIncomingReceiptHash(types.EmptyRootHash)
        }</span> else<span class="cov0" title="0"> {
                w.current.header.SetIncomingReceiptHash(
                        types.DeriveSha(types.CXReceiptsProofs(receiptsList)),
                )
        }</span>

        <span class="cov0" title="0">for _, cx := range receiptsList </span><span class="cov0" title="0">{
                if err := core.ApplyIncomingReceipt(
                        w.config, w.current.state, w.current.header, cx,
                ); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "Failed applying cross-shard receipts")
                }</span>
        }
        <span class="cov0" title="0">w.current.incxs = append(w.current.incxs, receiptsList...)
        return nil</span>
}

// UpdateCurrent updates the current environment with the current state and header.
func (w *Worker) UpdateCurrent() error <span class="cov8" title="1">{
        parent := w.chain.CurrentBlock()
        num := parent.Number()
        timestamp := time.Now().Unix()

        epoch := w.GetNewEpoch()
        header := w.factory.NewHeader(epoch).With().
                ParentHash(parent.Hash()).
                Number(num.Add(num, common.Big1)).
                GasLimit(core.CalcGasLimit(parent, w.gasFloor, w.gasCeil)).
                Time(big.NewInt(timestamp)).
                ShardID(w.chain.ShardID()).
                Header()
        return w.makeCurrent(parent, header)
}</span>

// GetCurrentHeader returns the current header to propose
func (w *Worker) GetCurrentHeader() *block.Header <span class="cov8" title="1">{
        return w.current.header
}</span>

// makeCurrent creates a new environment for the current cycle.
func (w *Worker) makeCurrent(parent *types.Block, header *block.Header) error <span class="cov8" title="1">{
        state, err := w.chain.StateAt(parent.Root())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">env := &amp;environment{
                signer:    types.NewEIP155Signer(w.config.ChainID),
                ethSigner: types.NewEIP155Signer(w.config.EthCompatibleChainID),
                state:     state,
                header:    header,
        }

        w.current = env
        return nil</span>
}

// GetCurrentResult gets the current block processing result.
func (w *Worker) GetCurrentResult() *core.ProcessorResult <span class="cov0" title="0">{
        return &amp;core.ProcessorResult{
                Receipts:   w.current.receipts,
                CxReceipts: w.current.outcxs,
                Logs:       w.current.logs,
                UsedGas:    w.current.header.GasUsed(),
                Reward:     w.current.reward,
                State:      w.current.state,
                StakeMsgs:  w.current.stakeMsgs,
        }
}</span>

// GetCurrentState gets the current state.
func (w *Worker) GetCurrentState() *state.DB <span class="cov8" title="1">{
        return w.current.state
}</span>

// GetNewEpoch gets the current epoch.
func (w *Worker) GetNewEpoch() *big.Int <span class="cov8" title="1">{
        parent := w.chain.CurrentBlock()
        epoch := new(big.Int).Set(parent.Header().Epoch())

        shardState, err := parent.Header().GetShardState()
        if err == nil &amp;&amp;
                shardState.Epoch != nil &amp;&amp;
                w.config.IsStaking(shardState.Epoch) </span><span class="cov0" title="0">{
                // For shard state of staking epochs, the shard state will
                // have an epoch and it will decide the next epoch for following blocks
                epoch = new(big.Int).Set(shardState.Epoch)
        }</span> else<span class="cov8" title="1"> {
                if parent.IsLastBlockInEpoch() &amp;&amp; parent.NumberU64() != 0 </span><span class="cov0" title="0">{
                        // if parent has proposed a new shard state it increases by 1, except for genesis block.
                        epoch = epoch.Add(epoch, common.Big1)
                }</span>
        }
        <span class="cov8" title="1">return epoch</span>
}

// GetCurrentReceipts get the receipts generated starting from the last state.
func (w *Worker) GetCurrentReceipts() []*types.Receipt <span class="cov8" title="1">{
        return w.current.receipts
}</span>

// OutgoingReceipts get the receipts generated starting from the last state.
func (w *Worker) OutgoingReceipts() []*types.CXReceipt <span class="cov0" title="0">{
        return w.current.outcxs
}</span>

// IncomingReceipts get incoming receipts in destination shard that is received from source shard
func (w *Worker) IncomingReceipts() []*types.CXReceiptsProof <span class="cov0" title="0">{
        return w.current.incxs
}</span>

// CollectVerifiedSlashes sets w.current.slashes only to those that
// past verification
func (w *Worker) CollectVerifiedSlashes() error <span class="cov0" title="0">{
        pending, failures :=
                w.chain.ReadPendingSlashingCandidates(), slash.Records{}
        if d := pending; len(d) &gt; 0 </span><span class="cov0" title="0">{
                pending, failures = w.verifySlashes(d)
        }</span>

        <span class="cov0" title="0">if f := failures; len(f) &gt; 0 </span><span class="cov0" title="0">{
                if err := w.chain.DeleteFromPendingSlashingCandidates(f); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">w.current.slashes = pending
        return nil</span>
}

// returns (successes, failures, error)
func (w *Worker) verifySlashes(
        d slash.Records,
) (slash.Records, slash.Records) <span class="cov0" title="0">{
        successes, failures := slash.Records{}, slash.Records{}
        // Enforce order, reproducibility
        sort.SliceStable(d,
                func(i, j int) bool </span><span class="cov0" title="0">{
                        return bytes.Compare(
                                d[i].Reporter.Bytes(), d[j].Reporter.Bytes(),
                        ) == -1
                }</span>,
        )

        // Always base the state on current tip of the chain
        <span class="cov0" title="0">workingState, err := w.chain.State()
        if err != nil </span><span class="cov0" title="0">{
                return successes, failures
        }</span>

        <span class="cov0" title="0">seenEvidences := map[common.Hash]struct{}{}

        for i := range d </span><span class="cov0" title="0">{
                evidenceHash := hash.FromRLPNew256(d[i].Evidence)
                if existing, ok := seenEvidences[evidenceHash]; ok </span><span class="cov0" title="0">{
                        utils.Logger().Warn().
                                Interface("slashRecord1", existing).
                                Interface("slashRecord2", d[i]).
                                Msg("Duplicate slash records with different reporters")
                        failures = append(failures, d[i])
                }</span> else<span class="cov0" title="0"> {
                        seenEvidences[evidenceHash] = struct{}{}

                        // In addition, need to count the same evidence with first and second vote swapped as seen
                        swapVote := d[i].Evidence
                        tmp := swapVote.ConflictingVotes.FirstVote
                        swapVote.ConflictingVotes.FirstVote = swapVote.ConflictingVotes.SecondVote
                        swapVote.ConflictingVotes.SecondVote = tmp
                        swapHash := hash.FromRLPNew256(swapVote)
                        seenEvidences[swapHash] = struct{}{}
                }</span>

                <span class="cov0" title="0">if err := slash.Verify(
                        w.chain, workingState, &amp;d[i],
                ); err != nil </span><span class="cov0" title="0">{
                        utils.Logger().Warn().Err(err).
                                Interface("slashRecord", d[i]).
                                Msg("Slash failed verification")
                        failures = append(failures, d[i])
                        continue</span>
                }
                <span class="cov0" title="0">successes = append(successes, d[i])</span>
        }

        <span class="cov0" title="0">if f := len(failures); f &gt; 0 </span><span class="cov0" title="0">{
                utils.Logger().Debug().
                        Int("count", f).
                        Msg("invalid slash records passed over in block proposal")
        }</span>

        <span class="cov0" title="0">return successes, failures</span>
}

// FinalizeNewBlock generate a new block for the next consensus round.
func (w *Worker) FinalizeNewBlock(
        commitSigs chan []byte, viewID func() uint64, coinbase common.Address,
        crossLinks types.CrossLinks, shardState *shard.State,
) (*types.Block, error) <span class="cov8" title="1">{
        w.current.header.SetCoinbase(coinbase)

        // Put crosslinks into header
        if len(crossLinks) &gt; 0 </span><span class="cov0" title="0">{
                crossLinks.Sort()
                crossLinkData, err := rlp.EncodeToBytes(crossLinks)
                if err == nil </span><span class="cov0" title="0">{
                        utils.Logger().Debug().
                                Uint64("blockNum", w.current.header.Number().Uint64()).
                                Int("numCrossLinks", len(crossLinks)).
                                Msg("Successfully proposed cross links into new block")
                        w.current.header.SetCrossLinks(crossLinkData)
                }</span> else<span class="cov0" title="0"> {
                        utils.Logger().Debug().Err(err).Msg("Failed to encode proposed cross links")
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                utils.Logger().Debug().Msg("Zero crosslinks to finalize")
        }</span>

        // Put slashes into header
        <span class="cov8" title="1">if w.config.IsStaking(w.current.header.Epoch()) </span><span class="cov0" title="0">{
                doubleSigners := w.current.slashes
                if len(doubleSigners) &gt; 0 </span><span class="cov0" title="0">{
                        if data, err := rlp.EncodeToBytes(doubleSigners); err == nil </span><span class="cov0" title="0">{
                                w.current.header.SetSlashes(data)
                                utils.Logger().Info().
                                        Msg("encoded slashes into headers of proposed new block")
                        }</span> else<span class="cov0" title="0"> {
                                utils.Logger().Debug().Err(err).Msg("Failed to encode proposed slashes")
                                return nil, err
                        }</span>
                }
        }

        // Put shard state into header
        <span class="cov8" title="1">if shardState != nil &amp;&amp; len(shardState.Shards) != 0 </span><span class="cov8" title="1">{
                //we store shardstatehash in header only before prestaking epoch (header v0,v1,v2)
                if !w.config.IsPreStaking(w.current.header.Epoch()) </span><span class="cov0" title="0">{
                        w.current.header.SetShardStateHash(shardState.Hash())
                }</span>
                <span class="cov8" title="1">isStaking := false
                if shardState.Epoch != nil &amp;&amp; w.config.IsStaking(shardState.Epoch) </span><span class="cov0" title="0">{
                        isStaking = true
                }</span>
                // NOTE: Besides genesis, this is the only place where the shard state is encoded.
                <span class="cov8" title="1">shardStateData, err := shard.EncodeWrapper(*shardState, isStaking)
                if err == nil </span><span class="cov8" title="1">{
                        w.current.header.SetShardState(shardStateData)
                }</span> else<span class="cov0" title="0"> {
                        utils.Logger().Debug().Err(err).Msg("Failed to encode proposed shard state")
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">state := w.current.state
        copyHeader := types.CopyHeader(w.current.header)

        sigsReady := make(chan bool)
        go func() </span><span class="cov8" title="1">{
                select </span>{
                case sigs := &lt;-commitSigs:<span class="cov8" title="1">
                        sig, signers, err := bls.SeparateSigAndMask(sigs)
                        if err != nil </span><span class="cov8" title="1">{
                                utils.Logger().Error().Err(err).Msg("Failed to parse commit sigs")
                                sigsReady &lt;- false
                        }</span>
                        // Put sig, signers, viewID, coinbase into header
                        <span class="cov0" title="0">if len(sig) &gt; 0 &amp;&amp; len(signers) &gt; 0 </span><span class="cov0" title="0">{
                                sig2 := copyHeader.LastCommitSignature()
                                copy(sig2[:], sig[:])
                                utils.Logger().Info().Hex("sigs", sig).Hex("bitmap", signers).Msg("Setting commit sigs")
                                copyHeader.SetLastCommitSignature(sig2)
                                copyHeader.SetLastCommitBitmap(signers)
                        }</span>
                        <span class="cov0" title="0">sigsReady &lt;- true</span>
                case &lt;-time.After(consensus.CommitSigReceiverTimeout):<span class="cov8" title="1">
                        // Exit goroutine
                        utils.Logger().Warn().Msg("Timeout waiting for commit sigs")</span>
                }
        }()

        <span class="cov8" title="1">block, payout, err := w.engine.Finalize(
                w.chain, copyHeader, state, w.current.txs, w.current.receipts,
                w.current.outcxs, w.current.incxs, w.current.stakingTxs,
                w.current.slashes, sigsReady, viewID,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrapf(err, "cannot finalize block")
        }</span>
        <span class="cov8" title="1">w.current.reward = payout
        return block, nil</span>
}

// New create a new worker object.
func New(
        config *params.ChainConfig, chain *core.BlockChain, engine consensus_engine.Engine,
) *Worker <span class="cov8" title="1">{
        worker := &amp;Worker{
                config:  config,
                factory: blockfactory.NewFactory(config),
                chain:   chain,
                engine:  engine,
        }
        worker.gasFloor = 80000000
        worker.gasCeil = 120000000

        parent := worker.chain.CurrentBlock()
        num := parent.Number()
        timestamp := time.Now().Unix()

        epoch := worker.GetNewEpoch()
        header := worker.factory.NewHeader(epoch).With().
                ParentHash(parent.Hash()).
                Number(num.Add(num, common.Big1)).
                GasLimit(worker.gasFloor). //core.CalcGasLimit(parent, worker.gasFloor, worker.gasCeil)).
                Time(big.NewInt(timestamp)).
                ShardID(worker.chain.ShardID()).
                Header()
        worker.makeCurrent(parent, header)

        return worker
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "math/big"

        "github.com/coinbase/rosetta-sdk-go/types"
        ethCommon "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/hexutil"
        "github.com/pkg/errors"

        "github.com/harmony-one/harmony/core/vm"
        ethRpc "github.com/harmony-one/harmony/eth/rpc"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/rosetta/common"
        "github.com/harmony-one/harmony/rpc"
)

// ConstructMetadataOptions is constructed by ConstructionPreprocess for ConstructionMetadata options
type ConstructMetadataOptions struct {
        TransactionMetadata *TransactionMetadata `json:"transaction_metadata"`
        OperationType       string               `json:"operation_type,omitempty"`
        GasPriceMultiplier  *float64             `json:"gas_price_multiplier,omitempty"`
}

// UnmarshalFromInterface ..
func (m *ConstructMetadataOptions) UnmarshalFromInterface(metadata interface{}) error <span class="cov8" title="1">{
        var T ConstructMetadataOptions
        dat, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(dat, &amp;T); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if T.TransactionMetadata == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("transaction metadata is required")
        }</span>
        <span class="cov8" title="1">if T.OperationType == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("operation type is required")
        }</span>
        <span class="cov8" title="1">*m = T
        return nil</span>
}

// ConstructionPreprocess implements the /construction/preprocess endpoint.
// Note that `request.MaxFee` is never considered for this construction implementation.
func (s *ConstructAPI) ConstructionPreprocess(
        ctx context.Context, request *types.ConstructionPreprocessRequest,
) (*types.ConstructionPreprocessResponse, *types.Error) <span class="cov0" title="0">{
        if err := assertValidNetworkIdentifier(request.NetworkIdentifier, s.hmy.ShardID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">txMetadata := &amp;TransactionMetadata{}
        if request.Metadata != nil </span><span class="cov0" title="0">{
                if err := txMetadata.UnmarshalFromInterface(request.Metadata); err != nil </span><span class="cov0" title="0">{
                        return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                                "message": errors.WithMessage(err, "invalid transaction metadata").Error(),
                        })
                }</span>
        }
        <span class="cov0" title="0">if txMetadata.FromShardID != nil &amp;&amp; *txMetadata.FromShardID != s.hmy.ShardID </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": fmt.Sprintf("expect from shard ID to be %v", s.hmy.ShardID),
                })
        }</span>

        <span class="cov0" title="0">components, rosettaError := GetOperationComponents(request.Operations)
        if rosettaError != nil </span><span class="cov0" title="0">{
                return nil, rosettaError
        }</span>
        <span class="cov0" title="0">if components.From == nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "sender address is not found for given operations",
                })
        }</span>
        <span class="cov0" title="0">if request.Operations[0].Type == common.CreateValidatorOperation &amp;&amp; len(txMetadata.SlotPubKeys) == 0 </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "invalid slot public keys",
                })
        }</span>
        <span class="cov0" title="0">if request.Operations[0].Type == common.CreateValidatorOperation &amp;&amp; len(txMetadata.SlotKeySigs) == 0 </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "invalid slot key signatures",
                })
        }</span>
        <span class="cov0" title="0">if request.Operations[0].Type == common.EditValidatorOperation &amp;&amp; (txMetadata.SlotPubKeyToAdd == "" ||
                txMetadata.SlotPubKeyToRemove == "" || txMetadata.SlotKeyToAddSig == "") </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "slot pub key to add/remove or sig to add error",
                })
        }</span>
        <span class="cov0" title="0">if txMetadata.ToShardID != nil &amp;&amp; txMetadata.FromShardID != nil &amp;&amp;
                components.Type != common.NativeCrossShardTransferOperation &amp;&amp; *txMetadata.ToShardID != *txMetadata.FromShardID </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "given from &amp; to shard are different for a native same shard transfer",
                })
        }</span>
        <span class="cov0" title="0">if request.SuggestedFeeMultiplier != nil &amp;&amp; *request.SuggestedFeeMultiplier &lt; 1 </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "given gas price multiplier must be at least 1",
                })
        }</span>

        <span class="cov0" title="0">options, err := types.MarshalMap(ConstructMetadataOptions{
                TransactionMetadata: txMetadata,
                OperationType:       components.Type,
                GasPriceMultiplier:  request.SuggestedFeeMultiplier,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.CatchAllError, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>
        <span class="cov0" title="0">if _, err := getAddress(components.From); err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>
        <span class="cov0" title="0">return &amp;types.ConstructionPreprocessResponse{
                Options: options,
                RequiredPublicKeys: []*types.AccountIdentifier{
                        components.From,
                },
        }, nil</span>
}

// ConstructMetadata with a set of operations will construct a valid transaction
type ConstructMetadata struct {
        Nonce           uint64               `json:"nonce"`
        GasLimit        uint64               `json:"gas_limit"`
        GasPrice        *big.Int             `json:"gas_price"`
        ContractCode    hexutil.Bytes        `json:"contract_code"`
        EvmReturn       hexutil.Bytes        `json:"evm_return"`
        EvmErrorMessage string               `json:"evm_error_message"`
        Transaction     *TransactionMetadata `json:"transaction_metadata"`
}

// UnmarshalFromInterface ..
func (m *ConstructMetadata) UnmarshalFromInterface(blockArgs interface{}) error <span class="cov8" title="1">{
        var T ConstructMetadata
        dat, err := json.Marshal(blockArgs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(dat, &amp;T); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if T.GasPrice == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("gas price is required")
        }</span>
        <span class="cov8" title="1">if T.Transaction == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("transaction metadata is required")
        }</span>
        <span class="cov8" title="1">*m = T
        return nil</span>
}

// ConstructionMetadata implements the /construction/metadata endpoint.
func (s *ConstructAPI) ConstructionMetadata(
        ctx context.Context, request *types.ConstructionMetadataRequest,
) (*types.ConstructionMetadataResponse, *types.Error) <span class="cov0" title="0">{
        if err := assertValidNetworkIdentifier(request.NetworkIdentifier, s.hmy.ShardID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">options := &amp;ConstructMetadataOptions{}
        if err := options.UnmarshalFromInterface(request.Options); err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": errors.WithMessage(err, "invalid metadata option(s)").Error(),
                })
        }</span>

        <span class="cov0" title="0">if len(request.PublicKeys) != 1 </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "require sender public key only",
                })
        }</span>
        <span class="cov0" title="0">senderAddr, rosettaError := getAddressFromPublicKey(request.PublicKeys[0])
        if rosettaError != nil </span><span class="cov0" title="0">{
                return nil, rosettaError
        }</span>
        <span class="cov0" title="0">nonce, err := s.hmy.GetPoolNonce(ctx, *senderAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.CatchAllError, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">currBlock, err := s.hmy.BlockByNumber(ctx, ethRpc.LatestBlockNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.CatchAllError, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">if options.OperationType == common.NativeCrossShardTransferOperation &amp;&amp;
                !s.hmy.BlockChain.Config().AcceptsCrossTx(currBlock.Epoch()) </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": "cross-shard transaction is not accepted yet",
                })
        }</span>

        <span class="cov0" title="0">data := hexutil.Bytes{}
        if options.TransactionMetadata.Data != nil </span><span class="cov0" title="0">{
                var err error
                if data, err = hexutil.Decode(*options.TransactionMetadata.Data); err != nil </span><span class="cov0" title="0">{
                        return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                                "message": errors.WithMessage(err, "invalid tx data format").Error(),
                        })
                }</span>
        }

        <span class="cov0" title="0">var contractAddress ethCommon.Address
        if options.TransactionMetadata.ContractAccountIdentifier != nil </span><span class="cov0" title="0">{
                contractAddress, err = getAddress(options.TransactionMetadata.ContractAccountIdentifier)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                                "message": errors.WithMessage(err, "unable to get provided contract address").Error(),
                        })
                }</span>
        }
        <span class="cov0" title="0">state, _, err := s.hmy.StateAndHeaderByNumber(ctx, ethRpc.LatestBlockNumber)
        if state == nil || err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.BlockNotFoundError, map[string]interface{}{
                        "message": "block state not found for latest block",
                })
        }</span>

        <span class="cov0" title="0">var estGasUsed uint64
        if !isStakingOperation(options.OperationType) </span><span class="cov0" title="0">{
                if options.OperationType == common.ContractCreationOperation </span><span class="cov0" title="0">{
                        estGasUsed, err = rpc.EstimateGas(ctx, s.hmy, rpc.CallArgs{From: senderAddr, Data: &amp;data}, nil)
                        estGasUsed *= 2 // HACK to account for imperfect contract creation estimation
                }</span> else<span class="cov0" title="0"> {
                        estGasUsed, err = rpc.EstimateGas(
                                ctx, s.hmy, rpc.CallArgs{From: senderAddr, To: &amp;contractAddress, Data: &amp;data}, nil,
                        )
                }</span>
        } else<span class="cov0" title="0"> {
                estGasUsed, err = vm.IntrinsicGas(data, false, false,
                        false, options.OperationType == common.CreateValidatorOperation)
                estGasUsed *= 2

        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.InvalidTransactionConstructionError, map[string]interface{}{
                        "message": errors.WithMessage(err, "invalid transaction data").Error(),
                })
        }</span>
        <span class="cov0" title="0">gasMul := float64(1)
        if options.GasPriceMultiplier != nil &amp;&amp; *options.GasPriceMultiplier &gt; 1 </span><span class="cov0" title="0">{
                gasMul = *options.GasPriceMultiplier
        }</span>
        <span class="cov0" title="0">sugNativeFee, sugNativePrice := getSuggestedNativeFeeAndPrice(gasMul, new(big.Int).SetUint64(estGasUsed))

        evmErrorMsg := ""
        evmReturn := hexutil.Bytes{}
        if len(data) &gt; 0 &amp;&amp; (options.OperationType == common.ContractCreationOperation ||
                options.OperationType == common.NativeTransferOperation) </span><span class="cov0" title="0">{
                gas := hexutil.Uint64(estGasUsed)
                callArgs := rpc.CallArgs{
                        From: senderAddr,
                        Data: &amp;data,
                        Gas:  &amp;gas,
                }
                if options.OperationType == common.NativeTransferOperation </span><span class="cov0" title="0">{
                        callArgs.To = &amp;contractAddress
                }</span>
                <span class="cov0" title="0">evmExe, err := rpc.DoEVMCall(
                        ctx, s.hmy, callArgs, ethRpc.LatestBlockNumber, rpc.CallTimeout,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, common.NewError(common.CatchAllError, map[string]interface{}{
                                "message": errors.WithMessage(err, "unable to execute EVM").Error(),
                        })
                }</span>
                <span class="cov0" title="0">if evmExe.VMErr != nil </span><span class="cov0" title="0">{
                        evmErrorMsg = evmExe.VMErr.Error()
                }</span>
                <span class="cov0" title="0">evmReturn = evmExe.ReturnData
                sugNativeFee, sugNativePrice = getSuggestedNativeFeeAndPrice(gasMul, new(big.Int).SetUint64(evmExe.UsedGas))</span>
        }

        <span class="cov0" title="0">metadata, err := types.MarshalMap(ConstructMetadata{
                Nonce:           nonce,
                GasPrice:        sugNativePrice,
                GasLimit:        estGasUsed,
                Transaction:     options.TransactionMetadata,
                ContractCode:    state.GetCode(contractAddress),
                EvmErrorMessage: evmErrorMsg,
                EvmReturn:       evmReturn,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, common.NewError(common.CatchAllError, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>
        <span class="cov0" title="0">return &amp;types.ConstructionMetadataResponse{
                Metadata:     metadata,
                SuggestedFee: sugNativeFee,
        }, nil</span>
}

// getSuggestedNativeFeeAndPrice ..
func getSuggestedNativeFeeAndPrice(
        gasMul float64, estGasUsed *big.Int,
) ([]*types.Amount, *big.Int) <span class="cov8" title="1">{
        if estGasUsed == nil </span><span class="cov8" title="1">{
                estGasUsed = big.NewInt(0).SetUint64(params.TxGas)
        }</span>
        <span class="cov8" title="1">if gasMul &lt; 1 </span><span class="cov8" title="1">{
                gasMul = 1
        }</span>
        <span class="cov8" title="1">gasPriceFloat := big.NewFloat(0).Mul(big.NewFloat(DefaultGasPrice), big.NewFloat(gasMul))
        gasPriceTruncated, _ := gasPriceFloat.Uint64()
        gasPrice := new(big.Int).SetUint64(gasPriceTruncated)
        return []*types.Amount{
                {
                        Value:    fmt.Sprintf("%v", new(big.Int).Mul(gasPrice, estGasUsed)),
                        Currency: &amp;common.NativeCurrency,
                },
        }, gasPrice</span>
}

// isStakingOperation ..
func isStakingOperation(op string) bool <span class="cov0" title="0">{
        for _, stakingOp := range common.StakingOperationTypes </span><span class="cov0" title="0">{
                if stakingOp == op </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package staking

import (
        "bytes"
        "math/big"
        "strings"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/accounts/abi"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var abiStaking abi.ABI
var abiMigration abi.ABI

func init() <span class="cov8" title="1">{
        // for commission rates =&gt; solidity does not support floats directly
        // so send commission rates as string
        StakingABIJSON := `
        [
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "delegatorAddress",
                "type": "address"
              }
            ],
            "name": "CollectRewards",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "delegatorAddress",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "validatorAddress",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              }
            ],
            "name": "Delegate",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "delegatorAddress",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "validatorAddress",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              }
            ],
            "name": "Undelegate",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          }
        ]
        `
        MigrationABIJSON := `
        [
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "from",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "to",
                "type": "address"
              }
            ],
            "name": "Migrate",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          }
        ]
        `
        abiStaking, _ = abi.JSON(strings.NewReader(StakingABIJSON))
        abiMigration, _ = abi.JSON(strings.NewReader(MigrationABIJSON))
}</span>

// contractCaller (and not Contract) is used here to avoid import cycle
func ParseStakeMsg(contractCaller common.Address, input []byte) (interface{}, error) <span class="cov8" title="1">{
        method, err := abiStaking.MethodById(input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">input = input[4:]                // drop the method selector
        args := map[string]interface{}{} // store into map
        if err = method.Inputs.UnpackIntoMap(args, input); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch method.Name </span>{
        case "Delegate":<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        // in case of assembly call, a contract will delegate its own balance
                        // in case of assembly delegatecall, contract.Caller() is msg.sender
                        // which means an EOA can
                        // (1) deploy a contract which receives delegations and amounts
                        // (2) call the contract, which then performs the tx on behalf of the EOA
                        address, err := ValidateContractAddress(contractCaller, args, "delegatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">validatorAddress, err := ParseAddressFromKey(args, "validatorAddress")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">amount, err := ParseBigIntFromKey(args, "amount")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.Delegate{
                                DelegatorAddress: address,
                                ValidatorAddress: validatorAddress,
                                Amount:           amount,
                        }
                        return stakeMsg, nil</span>
                }
        case "Undelegate":<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        // same validation as above
                        address, err := ValidateContractAddress(contractCaller, args, "delegatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">validatorAddress, err := ParseAddressFromKey(args, "validatorAddress")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // this type assertion is needed by Golang
                        <span class="cov8" title="1">amount, err := ParseBigIntFromKey(args, "amount")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.Undelegate{
                                DelegatorAddress: address,
                                ValidatorAddress: validatorAddress,
                                Amount:           amount,
                        }
                        return stakeMsg, nil</span>
                }
        case "CollectRewards":<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        // same validation as above
                        address, err := ValidateContractAddress(contractCaller, args, "delegatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.CollectRewards{
                                DelegatorAddress: address,
                        }
                        return stakeMsg, nil</span>
                }
        default:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        panic("[StakingPrecompiles] Cannot reach here")</span>
                }
        }
}

func ParseMigrationMsg(contractCaller common.Address, input []byte) (*stakingTypes.MigrationMsg, error) <span class="cov8" title="1">{
        method, err := abiMigration.MethodById(input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">input = input[4:]                // drop the method selector
        args := map[string]interface{}{} // store into map
        if err = method.Inputs.UnpackIntoMap(args, input); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch method.Name </span>{
        case "Migrate":<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        from, err := ValidateContractAddress(contractCaller, args, "from")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">to, err := ParseAddressFromKey(args, "to")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // no sanity check for migrating to same address, just do nothing
                        <span class="cov8" title="1">return &amp;stakingTypes.MigrationMsg{
                                From: from,
                                To:   to,
                        }, nil</span>
                }
        default:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        panic("[StakingPrecompiles] Cannot reach here")</span>
                }
        }
}

// used to ensure caller == delegatorAddress
func ValidateContractAddress(contractCaller common.Address, args map[string]interface{}, key string) (common.Address, error) <span class="cov8" title="1">{
        address, err := ParseAddressFromKey(args, key)
        if err != nil </span><span class="cov8" title="1">{
                return common.Address{}, err
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(contractCaller.Bytes(), address.Bytes()) </span><span class="cov8" title="1">{
                return common.Address{}, errors.Errorf(
                        "[StakingPrecompiles] Address mismatch, expected %s have %s",
                        contractCaller.String(), address.String(),
                )
        }</span> else<span class="cov8" title="1"> {
                return address, nil
        }</span>
}

// used for both delegatorAddress and validatorAddress
func ParseAddressFromKey(args map[string]interface{}, key string) (common.Address, error) <span class="cov8" title="1">{
        if address, ok := args[key].(common.Address); ok </span><span class="cov8" title="1">{
                return address, nil
        }</span> else<span class="cov8" title="1"> {
                return common.Address{}, errors.Errorf("Cannot parse address from %v", args[key])
        }</span>
}

// used for amounts
func ParseBigIntFromKey(args map[string]interface{}, key string) (*big.Int, error) <span class="cov8" title="1">{
        bigInt, ok := args[key].(*big.Int)
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf(
                        "Cannot parse BigInt from %v", args[key])
        }</span> else<span class="cov8" title="1"> {
                return bigInt, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package types

import (
        "bytes"
        "fmt"
        "math/big"

        "github.com/harmony-one/harmony/crypto/bls"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/numeric"
        "github.com/harmony-one/harmony/staking/effective"
        "github.com/pkg/errors"
)

// Directive says what kind of payload follows
type Directive byte

const (
        // DirectiveCreateValidator ...
        DirectiveCreateValidator Directive = iota
        // DirectiveEditValidator ...
        DirectiveEditValidator
        // DirectiveDelegate ...
        DirectiveDelegate
        // DirectiveUndelegate ...
        DirectiveUndelegate
        // DirectiveCollectRewards ...
        DirectiveCollectRewards
)

var (
        directiveNames = map[Directive]string{
                DirectiveCreateValidator: "CreateValidator",
                DirectiveEditValidator:   "EditValidator",
                DirectiveDelegate:        "Delegate",
                DirectiveUndelegate:      "Undelegate",
                DirectiveCollectRewards:  "CollectRewards",
        }
        // ErrInvalidStakingKind given when caller gives bad staking message kind
        ErrInvalidStakingKind = errors.New("bad staking kind")
)

func (d Directive) String() string <span class="cov8" title="1">{
        if name, ok := directiveNames[d]; ok </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Directive %+v", byte(d))</span>
}

// StakeMsg defines the interface of Stake Message
type StakeMsg interface {
        Type() Directive
        Copy() StakeMsg
}

// CreateValidator - type for creating a new validator
type CreateValidator struct {
        ValidatorAddress   common.Address `json:"validator-address"`
        Description        `json:"description"`
        CommissionRates    `json:"commission"`
        MinSelfDelegation  *big.Int                  `json:"min-self-delegation"`
        MaxTotalDelegation *big.Int                  `json:"max-total-delegation"`
        SlotPubKeys        []bls.SerializedPublicKey `json:"slot-pub-keys"`
        SlotKeySigs        []bls.SerializedSignature `json:"slot-key-sigs"`
        Amount             *big.Int                  `json:"amount"`
}

// Type of CreateValidator
func (v CreateValidator) Type() Directive <span class="cov8" title="1">{
        return DirectiveCreateValidator
}</span>

// Copy returns a deep copy of the CreateValidator as a StakeMsg interface
func (v CreateValidator) Copy() StakeMsg <span class="cov8" title="1">{
        cp := CreateValidator{
                ValidatorAddress: v.ValidatorAddress,
                Description:      v.Description,
                CommissionRates:  v.CommissionRates.Copy(),
        }

        if v.SlotPubKeys != nil </span><span class="cov8" title="1">{
                cp.SlotPubKeys = make([]bls.SerializedPublicKey, len(v.SlotPubKeys))
                copy(cp.SlotPubKeys, v.SlotPubKeys)
        }</span>
        <span class="cov8" title="1">if v.SlotKeySigs != nil </span><span class="cov8" title="1">{
                cp.SlotKeySigs = make([]bls.SerializedSignature, len(v.SlotKeySigs))
                copy(cp.SlotKeySigs, v.SlotKeySigs)
        }</span>
        <span class="cov8" title="1">if v.MinSelfDelegation != nil </span><span class="cov8" title="1">{
                cp.MinSelfDelegation = new(big.Int).Set(v.MinSelfDelegation)
        }</span>
        <span class="cov8" title="1">if v.MaxTotalDelegation != nil </span><span class="cov8" title="1">{
                cp.MaxTotalDelegation = new(big.Int).Set(v.MaxTotalDelegation)
        }</span>
        <span class="cov8" title="1">if v.Amount != nil </span><span class="cov8" title="1">{
                cp.Amount = new(big.Int).Set(v.Amount)
        }</span>
        <span class="cov8" title="1">return cp</span>
}

// EditValidator - type for edit existing validator
type EditValidator struct {
        ValidatorAddress   common.Address `json:"validator-address"`
        Description        `json:"description"`
        CommissionRate     *numeric.Dec             `json:"commission-rate" rlp:"nil"`
        MinSelfDelegation  *big.Int                 `json:"min-self-delegation" rlp:"nil"`
        MaxTotalDelegation *big.Int                 `json:"max-total-delegation" rlp:"nil"`
        SlotKeyToRemove    *bls.SerializedPublicKey `json:"slot-key-to_remove" rlp:"nil"`
        SlotKeyToAdd       *bls.SerializedPublicKey `json:"slot-key-to_add" rlp:"nil"`
        SlotKeyToAddSig    *bls.SerializedSignature `json:"slot-key-to-add-sig" rlp:"nil"`
        EPOSStatus         effective.Eligibility    `json:"epos-eligibility-status"`
}

// Type of EditValidator
func (v EditValidator) Type() Directive <span class="cov8" title="1">{
        return DirectiveEditValidator
}</span>

// Copy returns a deep copy of the EditValidator as a StakeMsg interface
func (v EditValidator) Copy() StakeMsg <span class="cov8" title="1">{
        cp := EditValidator{
                ValidatorAddress: v.ValidatorAddress,
                Description:      v.Description,
                EPOSStatus:       v.EPOSStatus,
        }
        if v.CommissionRate != nil </span><span class="cov8" title="1">{
                cr := v.CommissionRate.Copy()
                cp.CommissionRate = &amp;cr
        }</span>
        <span class="cov8" title="1">if v.MinSelfDelegation != nil </span><span class="cov8" title="1">{
                cp.MinSelfDelegation = new(big.Int).Set(v.MinSelfDelegation)
        }</span>
        <span class="cov8" title="1">if v.MaxTotalDelegation != nil </span><span class="cov8" title="1">{
                cp.MaxTotalDelegation = new(big.Int).Set(v.MaxTotalDelegation)
        }</span>
        <span class="cov8" title="1">if v.SlotKeyToRemove != nil </span><span class="cov8" title="1">{
                keyRem := *v.SlotKeyToRemove
                cp.SlotKeyToRemove = &amp;keyRem
        }</span>
        <span class="cov8" title="1">if v.SlotKeyToAdd != nil </span><span class="cov8" title="1">{
                keyAdd := *v.SlotKeyToAdd
                cp.SlotKeyToAdd = &amp;keyAdd
        }</span>
        <span class="cov8" title="1">if v.SlotKeyToAddSig != nil </span><span class="cov8" title="1">{
                sigAdd := *v.SlotKeyToAddSig
                cp.SlotKeyToAddSig = &amp;sigAdd
        }</span>
        <span class="cov8" title="1">return cp</span>
}

// Delegate - type for delegating to a validator
type Delegate struct {
        DelegatorAddress common.Address `json:"delegator_address"`
        ValidatorAddress common.Address `json:"validator_address"`
        Amount           *big.Int       `json:"amount"`
}

// Type of Delegate
func (v Delegate) Type() Directive <span class="cov8" title="1">{
        return DirectiveDelegate
}</span>

// Copy returns a deep copy of the Delegate as a StakeMsg interface
func (v Delegate) Copy() StakeMsg <span class="cov8" title="1">{
        cp := Delegate{
                DelegatorAddress: v.DelegatorAddress,
                ValidatorAddress: v.ValidatorAddress,
        }
        if v.Amount != nil </span><span class="cov8" title="1">{
                cp.Amount = new(big.Int).Set(v.Amount)
        }</span>
        <span class="cov8" title="1">return cp</span>
}

// Equals returns if v and s are equal
func (v Delegate) Equals(s Delegate) bool <span class="cov8" title="1">{
        if !bytes.Equal(v.DelegatorAddress.Bytes(), s.DelegatorAddress.Bytes()) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(v.ValidatorAddress.Bytes(), s.ValidatorAddress.Bytes()) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if v.Amount == nil </span><span class="cov0" title="0">{
                return s.Amount == nil
        }</span>
        <span class="cov8" title="1">return s.Amount != nil &amp;&amp; v.Amount.Cmp(s.Amount) == 0</span> // pointer
}

// Undelegate - type for removing delegation responsibility
type Undelegate struct {
        DelegatorAddress common.Address `json:"delegator_address"`
        ValidatorAddress common.Address `json:"validator_address"`
        Amount           *big.Int       `json:"amount"`
}

// Type of Undelegate
func (v Undelegate) Type() Directive <span class="cov8" title="1">{
        return DirectiveUndelegate
}</span>

// Copy returns a deep copy of the Undelegate as a StakeMsg interface
func (v Undelegate) Copy() StakeMsg <span class="cov8" title="1">{
        cp := Undelegate{
                DelegatorAddress: v.DelegatorAddress,
                ValidatorAddress: v.ValidatorAddress,
        }
        if v.Amount != nil </span><span class="cov8" title="1">{
                cp.Amount = new(big.Int).Set(v.Amount)
        }</span>
        <span class="cov8" title="1">return cp</span>
}

// Equals returns if v and s are equal
func (v Undelegate) Equals(s Undelegate) bool <span class="cov8" title="1">{
        if !bytes.Equal(v.DelegatorAddress.Bytes(), s.DelegatorAddress.Bytes()) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(v.ValidatorAddress.Bytes(), s.ValidatorAddress.Bytes()) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if v.Amount == nil </span><span class="cov0" title="0">{
                return s.Amount == nil
        }</span>
        <span class="cov8" title="1">return s.Amount != nil &amp;&amp; v.Amount.Cmp(s.Amount) == 0</span> // pointer
}

// CollectRewards - type for collecting token rewards
type CollectRewards struct {
        DelegatorAddress common.Address `json:"delegator_address"`
}

// Type of CollectRewards
func (v CollectRewards) Type() Directive <span class="cov8" title="1">{
        return DirectiveCollectRewards
}</span>

// Copy returns a deep copy of the CollectRewards as a StakeMsg interface
func (v CollectRewards) Copy() StakeMsg <span class="cov8" title="1">{
        return CollectRewards{
                DelegatorAddress: v.DelegatorAddress,
        }
}</span>

// Equals returns if v and s are equal
func (v CollectRewards) Equals(s CollectRewards) bool <span class="cov8" title="1">{
        return bytes.Equal(v.DelegatorAddress.Bytes(), s.DelegatorAddress.Bytes())
}</span>

// Migration Msg - type for switching delegation from one user to next
type MigrationMsg struct {
        From common.Address `json:"from" rlp:"nil"`
        To   common.Address `json:"to" rlp:"nil"`
}

func (v MigrationMsg) Copy() MigrationMsg <span class="cov0" title="0">{
        return MigrationMsg{
                From: v.From,
                To:   v.To,
        }
}</span>

func (v MigrationMsg) Equals(s MigrationMsg) bool <span class="cov8" title="1">{
        return v.From == s.From &amp;&amp; v.To == s.To
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
