
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/harmony-one/harmony/core/blockchain.go (25.9%)</option>
				
				<option value="file1">github.com/harmony-one/harmony/core/evm.go (65.1%)</option>
				
				<option value="file2">github.com/harmony-one/harmony/core/staking_verifier.go (98.5%)</option>
				
				<option value="file3">github.com/harmony-one/harmony/core/state_processor.go (47.8%)</option>
				
				<option value="file4">github.com/harmony-one/harmony/core/state_transition.go (69.4%)</option>
				
				<option value="file5">github.com/harmony-one/harmony/core/vm/contracts_write.go (82.0%)</option>
				
				<option value="file6">github.com/harmony-one/harmony/core/vm/evm.go (37.4%)</option>
				
				<option value="file7">github.com/harmony-one/harmony/crypto/bls/bls.go (74.4%)</option>
				
				<option value="file8">github.com/harmony-one/harmony/internal/params/config.go (60.4%)</option>
				
				<option value="file9">github.com/harmony-one/harmony/staking/precompile.go (94.6%)</option>
				
				<option value="file10">github.com/harmony-one/harmony/staking/types/validator.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

// Package core implements the Ethereum consensus protocol.
package core

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "math/big"
        "os"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/mclock"
        "github.com/ethereum/go-ethereum/common/prque"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/ethdb"
        "github.com/ethereum/go-ethereum/event"
        "github.com/ethereum/go-ethereum/metrics"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/consensus/reward"
        "github.com/harmony-one/harmony/consensus/votepower"
        "github.com/harmony-one/harmony/core/rawdb"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/numeric"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/shard/committee"
        "github.com/harmony-one/harmony/staking/apr"
        "github.com/harmony-one/harmony/staking/effective"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        lru "github.com/hashicorp/golang-lru"
        "github.com/pkg/errors"
)

var (
        // blockInsertTimer
        blockInsertTimer = metrics.NewRegisteredTimer("chain/inserts", nil)
        // ErrNoGenesis is the error when there is no genesis.
        ErrNoGenesis = errors.New("Genesis not found in chain")
        // errExceedMaxPendingSlashes ..
        errExceedMaxPendingSlashes = errors.New("exceeed max pending slashes")
        errNilEpoch                = errors.New("nil epoch for voting power computation")
)

const (
        bodyCacheLimit                     = 2048
        blockCacheLimit                    = 2048
        receiptsCacheLimit                 = 32
        maxFutureBlocks                    = 256
        maxTimeFutureBlocks                = 30
        badBlockLimit                      = 10
        triesInMemory                      = 128
        shardCacheLimit                    = 10
        commitsCacheLimit                  = 10
        epochCacheLimit                    = 10
        randomnessCacheLimit               = 10
        validatorCacheLimit                = 1024
        validatorStatsCacheLimit           = 1024
        validatorListCacheLimit            = 10
        validatorListByDelegatorCacheLimit = 1024
        pendingCrossLinksCacheLimit        = 2
        blockAccumulatorCacheLimit         = 256
        maxPendingSlashes                  = 512
        // BlockChainVersion ensures that an incompatible database forces a resync from scratch.
        BlockChainVersion = 3
        pendingCLCacheKey = "pendingCLs"
)

// CacheConfig contains the configuration values for the trie caching/pruning
// that's resident in a blockchain.
type CacheConfig struct {
        Disabled      bool          // Whether to disable trie write caching (archive node)
        TrieNodeLimit int           // Memory limit (MB) at which to flush the current in-memory trie to disk
        TrieTimeLimit time.Duration // Time limit after which to flush the current in-memory trie to disk
}

// BlockChain represents the canonical chain given a database with a genesis
// block. The Blockchain manages chain imports, reverts, chain reorganisations.
//
// Importing blocks in to the block chain happens according to the set of rules
// defined by the two stage validator. Processing of blocks is done using the
// Processor which processes the included transaction. The validation of the state
// is done in the second part of the validator. Failing results in aborting of
// the import.
//
// The BlockChain also helps in returning blocks from **any** chain included
// in the database as well as blocks that represents the canonical chain. It's
// important to note that GetBlock can return any block and does not need to be
// included in the canonical one where as GetBlockByNumber always represents the
// canonical chain.
type BlockChain struct {
        chainConfig *params.ChainConfig // Chain &amp; network configuration
        cacheConfig *CacheConfig        // Cache configuration for pruning

        db     ethdb.Database // Low level persistent database to store final content in
        triegc *prque.Prque   // Priority queue mapping block numbers to tries to gc
        gcproc time.Duration  // Accumulates canonical block processing for trie dumping

        hc            *HeaderChain
        rmLogsFeed    event.Feed
        chainFeed     event.Feed
        chainSideFeed event.Feed
        chainHeadFeed event.Feed
        logsFeed      event.Feed
        scope         event.SubscriptionScope
        genesisBlock  *types.Block

        mu                          sync.RWMutex // global mutex for locking chain operations
        chainmu                     sync.RWMutex // blockchain insertion lock
        procmu                      sync.RWMutex // block processor lock
        pendingCrossLinksMutex      sync.RWMutex // pending crosslinks lock
        pendingSlashingCandidatesMU sync.RWMutex // pending slashing candidates

        currentBlock     atomic.Value // Current head of the block chain
        currentFastBlock atomic.Value // Current head of the fast-sync chain (may be above the block chain!)

        stateCache                    state.Database // State database to reuse between imports (contains state cache)
        bodyCache                     *lru.Cache     // Cache for the most recent block bodies
        bodyRLPCache                  *lru.Cache     // Cache for the most recent block bodies in RLP encoded format
        receiptsCache                 *lru.Cache     // Cache for the most recent receipts per block
        blockCache                    *lru.Cache     // Cache for the most recent entire blocks
        futureBlocks                  *lru.Cache     // future blocks are blocks added for later processing
        shardStateCache               *lru.Cache
        lastCommitsCache              *lru.Cache
        epochCache                    *lru.Cache    // Cache epoch number → first block number
        randomnessCache               *lru.Cache    // Cache for vrf/vdf
        validatorSnapshotCache        *lru.Cache    // Cache for validator snapshot
        validatorStatsCache           *lru.Cache    // Cache for validator stats
        validatorListCache            *lru.Cache    // Cache of validator list
        validatorListByDelegatorCache *lru.Cache    // Cache of validator list by delegator
        pendingCrossLinksCache        *lru.Cache    // Cache of last pending crosslinks
        blockAccumulatorCache         *lru.Cache    // Cache of block accumulators
        quit                          chan struct{} // blockchain quit channel
        running                       int32         // running must be called atomically
        // procInterrupt must be atomically called
        procInterrupt int32          // interrupt signaler for block processing
        wg            sync.WaitGroup // chain processing wait group for shutting down

        engine                 consensus_engine.Engine
        processor              Processor // block processor interface
        validator              Validator // block and state validator interface
        vmConfig               vm.Config
        badBlocks              *lru.Cache              // Bad block cache
        shouldPreserve         func(*types.Block) bool // Function used to determine whether should preserve the given block.
        pendingSlashes         slash.Records
        maxGarbCollectedBlkNum int64
}

// NewBlockChain returns a fully initialised block chain using information
// available in the database. It initialises the default Ethereum validator and
// Processor.
func NewBlockChain(
        db ethdb.Database, cacheConfig *CacheConfig, chainConfig *params.ChainConfig,
        engine consensus_engine.Engine, vmConfig vm.Config,
        shouldPreserve func(block *types.Block) bool,
) (*BlockChain, error) <span class="cov8" title="1">{
        if cacheConfig == nil </span><span class="cov8" title="1">{
                cacheConfig = &amp;CacheConfig{
                        TrieNodeLimit: 256 * 1024 * 1024,
                        TrieTimeLimit: 2 * time.Minute,
                }
        }</span>
        <span class="cov8" title="1">bodyCache, _ := lru.New(bodyCacheLimit)
        bodyRLPCache, _ := lru.New(bodyCacheLimit)
        receiptsCache, _ := lru.New(receiptsCacheLimit)
        blockCache, _ := lru.New(blockCacheLimit)
        futureBlocks, _ := lru.New(maxFutureBlocks)
        badBlocks, _ := lru.New(badBlockLimit)
        shardCache, _ := lru.New(shardCacheLimit)
        commitsCache, _ := lru.New(commitsCacheLimit)
        epochCache, _ := lru.New(epochCacheLimit)
        randomnessCache, _ := lru.New(randomnessCacheLimit)
        validatorCache, _ := lru.New(validatorCacheLimit)
        validatorStatsCache, _ := lru.New(validatorStatsCacheLimit)
        validatorListCache, _ := lru.New(validatorListCacheLimit)
        validatorListByDelegatorCache, _ := lru.New(validatorListByDelegatorCacheLimit)
        pendingCrossLinksCache, _ := lru.New(pendingCrossLinksCacheLimit)
        blockAccumulatorCache, _ := lru.New(blockAccumulatorCacheLimit)

        bc := &amp;BlockChain{
                chainConfig:                   chainConfig,
                cacheConfig:                   cacheConfig,
                db:                            db,
                triegc:                        prque.New(nil),
                stateCache:                    state.NewDatabase(db),
                quit:                          make(chan struct{}),
                shouldPreserve:                shouldPreserve,
                bodyCache:                     bodyCache,
                bodyRLPCache:                  bodyRLPCache,
                receiptsCache:                 receiptsCache,
                blockCache:                    blockCache,
                futureBlocks:                  futureBlocks,
                shardStateCache:               shardCache,
                lastCommitsCache:              commitsCache,
                epochCache:                    epochCache,
                randomnessCache:               randomnessCache,
                validatorSnapshotCache:        validatorCache,
                validatorStatsCache:           validatorStatsCache,
                validatorListCache:            validatorListCache,
                validatorListByDelegatorCache: validatorListByDelegatorCache,
                pendingCrossLinksCache:        pendingCrossLinksCache,
                blockAccumulatorCache:         blockAccumulatorCache,
                engine:                        engine,
                vmConfig:                      vmConfig,
                badBlocks:                     badBlocks,
                pendingSlashes:                slash.Records{},
                maxGarbCollectedBlkNum:        -1,
        }
        bc.SetValidator(NewBlockValidator(chainConfig, bc, engine))
        bc.SetProcessor(NewStateProcessor(chainConfig, bc, engine))

        var err error
        bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">bc.genesisBlock = bc.GetBlockByNumber(0)
        if bc.genesisBlock == nil </span><span class="cov0" title="0">{
                return nil, ErrNoGenesis
        }</span>
        <span class="cov8" title="1">var nilBlock *types.Block
        bc.currentBlock.Store(nilBlock)
        bc.currentFastBlock.Store(nilBlock)
        if err := bc.loadLastState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Take ownership of this particular state
        <span class="cov8" title="1">go bc.update()
        return bc, nil</span>
}

// ValidateNewBlock validates new block.
func (bc *BlockChain) ValidateNewBlock(block *types.Block) error <span class="cov8" title="1">{
        state, err := state.New(bc.CurrentBlock().Root(), bc.stateCache)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // NOTE Order of mutating state here matters.
        // Process block using the parent state as reference point.
        <span class="cov8" title="1">receipts, cxReceipts, _, usedGas, _, err := bc.processor.Process(
                block, state, bc.vmConfig,
        )
        if err != nil </span><span class="cov0" title="0">{
                bc.reportBlock(block, receipts, err)
                return err
        }</span>

        // Verify all the hash roots (state, txns, receipts, cross-shard)
        <span class="cov8" title="1">if err := bc.Validator().ValidateState(
                block, state, receipts, cxReceipts, usedGas,
        ); err != nil </span><span class="cov0" title="0">{
                bc.reportBlock(block, receipts, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsEpochBlock returns whether this block is the first block of an epoch.
// by checking if the previous block is the last block of the previous epoch
func IsEpochBlock(block *types.Block) bool <span class="cov8" title="1">{
        if block.NumberU64() == 0 </span><span class="cov8" title="1">{
                // genesis block is the first epoch block
                return true
        }</span>
        <span class="cov8" title="1">return shard.Schedule.IsLastBlock(block.NumberU64() - 1)</span>
}

func (bc *BlockChain) getProcInterrupt() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;bc.procInterrupt) == 1
}</span>

// loadLastState loads the last known chain state from the database. This method
// assumes that the chain manager mutex is held.
func (bc *BlockChain) loadLastState() error <span class="cov8" title="1">{
        // Restore the last known head block
        head := rawdb.ReadHeadBlockHash(bc.db)
        if head == (common.Hash{}) </span><span class="cov0" title="0">{
                // Corrupt or empty database, init from scratch
                utils.Logger().Warn().Msg("Empty database, resetting chain")
                return bc.Reset()
        }</span>
        // Make sure the entire head block is available
        <span class="cov8" title="1">currentBlock := bc.GetBlockByHash(head)
        if currentBlock == nil </span><span class="cov0" title="0">{
                // Corrupt or empty database, init from scratch
                utils.Logger().Warn().Str("hash", head.Hex()).Msg("Head block missing, resetting chain")
                return bc.Reset()
        }</span>
        // Make sure the state associated with the block is available
        <span class="cov8" title="1">if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil </span><span class="cov0" title="0">{
                // Dangling block without a state associated, init from scratch
                utils.Logger().Warn().
                        Str("number", currentBlock.Number().String()).
                        Str("hash", currentBlock.Hash().Hex()).
                        Msg("Head state missing, repairing chain")
                if err := bc.repair(&amp;currentBlock); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // Everything seems to be fine, set as the head block
        <span class="cov8" title="1">bc.currentBlock.Store(currentBlock)

        // We don't need the following as we want the current header and block to be consistent
        // Restore the last known head header
        //currentHeader := currentBlock.Header()
        //if head := rawdb.ReadHeadHeaderHash(bc.db); head != (common.Hash{}) {
        //        if header := bc.GetHeaderByHash(head); header != nil {
        //                currentHeader = header
        //        }
        //}
        currentHeader := currentBlock.Header()
        if err := bc.hc.SetCurrentHeader(currentHeader); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "headerChain SetCurrentHeader")
        }</span>

        // Restore the last known head fast block
        <span class="cov8" title="1">bc.currentFastBlock.Store(currentBlock)
        if head := rawdb.ReadHeadFastBlockHash(bc.db); head != (common.Hash{}) </span><span class="cov0" title="0">{
                if block := bc.GetBlockByHash(head); block != nil </span><span class="cov0" title="0">{
                        bc.currentFastBlock.Store(block)
                }</span>
        }

        // Issue a status log for the user
        <span class="cov8" title="1">currentFastBlock := bc.CurrentFastBlock()

        headerTd := bc.GetTd(currentHeader.Hash(), currentHeader.Number().Uint64())
        blockTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
        fastTd := bc.GetTd(currentFastBlock.Hash(), currentFastBlock.NumberU64())

        utils.Logger().Info().
                Str("number", currentHeader.Number().String()).
                Str("hash", currentHeader.Hash().Hex()).
                Str("td", headerTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentHeader.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local header")
        utils.Logger().Info().
                Str("number", currentBlock.Number().String()).
                Str("hash", currentBlock.Hash().Hex()).
                Str("td", blockTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentBlock.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local full block")
        utils.Logger().Info().
                Str("number", currentFastBlock.Number().String()).
                Str("hash", currentFastBlock.Hash().Hex()).
                Str("td", fastTd.String()).
                Str("age", common.PrettyAge(time.Unix(currentFastBlock.Time().Int64(), 0)).String()).
                Msg("Loaded most recent local fast block")

        return nil</span>
}

// SetHead rewinds the local chain to a new head. In the case of headers, everything
// above the new head will be deleted and the new one set. In the case of blocks
// though, the head may be further rewound if block bodies are missing (non-archive
// nodes after a fast sync).
func (bc *BlockChain) SetHead(head uint64) error <span class="cov0" title="0">{
        utils.Logger().Warn().Uint64("target", head).Msg("Rewinding blockchain")

        bc.mu.Lock()
        defer bc.mu.Unlock()

        // Rewind the header chain, deleting all block bodies until then
        delFn := func(db rawdb.DatabaseDeleter, hash common.Hash, num uint64) error </span><span class="cov0" title="0">{
                return rawdb.DeleteBody(db, hash, num)
        }</span>
        <span class="cov0" title="0">if err := bc.hc.SetHead(head, delFn); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "headerChain SetHeader")
        }</span>
        <span class="cov0" title="0">currentHeader := bc.hc.CurrentHeader()

        // Clear out any stale content from the caches
        bc.bodyCache.Purge()
        bc.bodyRLPCache.Purge()
        bc.receiptsCache.Purge()
        bc.blockCache.Purge()
        bc.futureBlocks.Purge()
        bc.shardStateCache.Purge()

        // Rewind the block chain, ensuring we don't end up with a stateless head block
        if currentBlock := bc.CurrentBlock(); currentBlock != nil &amp;&amp; currentHeader.Number().Uint64() &lt; currentBlock.NumberU64() </span><span class="cov0" title="0">{
                bc.currentBlock.Store(bc.GetBlock(currentHeader.Hash(), currentHeader.Number().Uint64()))
        }</span>
        <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock != nil </span><span class="cov0" title="0">{
                if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil </span><span class="cov0" title="0">{
                        // Rewound state missing, rolled back to before pivot, reset to genesis
                        bc.currentBlock.Store(bc.genesisBlock)
                }</span>
        }
        // Rewind the fast block in a simpleton way to the target head
        <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock != nil &amp;&amp; currentHeader.Number().Uint64() &lt; currentFastBlock.NumberU64() </span><span class="cov0" title="0">{
                bc.currentFastBlock.Store(bc.GetBlock(currentHeader.Hash(), currentHeader.Number().Uint64()))
        }</span>
        // If either blocks reached nil, reset to the genesis state
        <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock == nil </span><span class="cov0" title="0">{
                bc.currentBlock.Store(bc.genesisBlock)
        }</span>
        <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock == nil </span><span class="cov0" title="0">{
                bc.currentFastBlock.Store(bc.genesisBlock)
        }</span>
        <span class="cov0" title="0">currentBlock := bc.CurrentBlock()
        currentFastBlock := bc.CurrentFastBlock()

        if err := rawdb.WriteHeadBlockHash(bc.db, currentBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WriteHeadFastBlockHash(bc.db, currentFastBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return bc.loadLastState()</span>
}

// ShardID returns the shard Id of the blockchain.
// TODO: use a better solution before resharding shuffle nodes to different shards
func (bc *BlockChain) ShardID() uint32 <span class="cov8" title="1">{
        return bc.CurrentBlock().ShardID()
}</span>

// GasLimit returns the gas limit of the current HEAD block.
func (bc *BlockChain) GasLimit() uint64 <span class="cov0" title="0">{
        return bc.CurrentBlock().GasLimit()
}</span>

// CurrentBlock retrieves the current head block of the canonical chain. The
// block is retrieved from the blockchain's internal cache.
func (bc *BlockChain) CurrentBlock() *types.Block <span class="cov8" title="1">{
        return bc.currentBlock.Load().(*types.Block)
}</span>

// CurrentFastBlock retrieves the current fast-sync head block of the canonical
// chain. The block is retrieved from the blockchain's internal cache.
func (bc *BlockChain) CurrentFastBlock() *types.Block <span class="cov8" title="1">{
        return bc.currentFastBlock.Load().(*types.Block)
}</span>

// SetProcessor sets the processor required for making state modifications.
func (bc *BlockChain) SetProcessor(processor Processor) <span class="cov8" title="1">{
        bc.procmu.Lock()
        defer bc.procmu.Unlock()
        bc.processor = processor
}</span>

// SetValidator sets the validator which is used to validate incoming blocks.
func (bc *BlockChain) SetValidator(validator Validator) <span class="cov8" title="1">{
        bc.procmu.Lock()
        defer bc.procmu.Unlock()
        bc.validator = validator
}</span>

// Validator returns the current validator.
func (bc *BlockChain) Validator() Validator <span class="cov8" title="1">{
        bc.procmu.RLock()
        defer bc.procmu.RUnlock()
        return bc.validator
}</span>

// Processor returns the current processor.
func (bc *BlockChain) Processor() Processor <span class="cov0" title="0">{
        bc.procmu.RLock()
        defer bc.procmu.RUnlock()
        return bc.processor
}</span>

// State returns a new mutable state based on the current HEAD block.
func (bc *BlockChain) State() (*state.DB, error) <span class="cov0" title="0">{
        return bc.StateAt(bc.CurrentBlock().Root())
}</span>

// StateAt returns a new mutable state based on a particular point in time.
func (bc *BlockChain) StateAt(root common.Hash) (*state.DB, error) <span class="cov8" title="1">{
        return state.New(root, bc.stateCache)
}</span>

// Reset purges the entire blockchain, restoring it to its genesis state.
func (bc *BlockChain) Reset() error <span class="cov0" title="0">{
        return bc.ResetWithGenesisBlock(bc.genesisBlock)
}</span>

// ResetWithGenesisBlock purges the entire blockchain, restoring it to the
// specified genesis state.
func (bc *BlockChain) ResetWithGenesisBlock(genesis *types.Block) error <span class="cov0" title="0">{
        // Dump the entire block chain and purge the caches
        if err := bc.SetHead(0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.mu.Lock()
        defer bc.mu.Unlock()

        // Prepare the genesis block and reinitialise the chain
        if err := rawdb.WriteBlock(bc.db, genesis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bc.genesisBlock = genesis
        if err := bc.insert(bc.genesisBlock); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.hc.SetGenesis(bc.genesisBlock.Header())
        if err := bc.hc.SetCurrentHeader(bc.genesisBlock.Header()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.currentBlock.Store(bc.genesisBlock)
        bc.currentFastBlock.Store(bc.genesisBlock)

        return nil</span>
}

// repair tries to repair the current blockchain by rolling back the current block
// until one with associated state is found. This is needed to fix incomplete db
// writes caused either by crashes/power outages, or simply non-committed tries.
//
// This method only rolls back the current block. The current header and current
// fast block are left intact.
func (bc *BlockChain) repair(head **types.Block) error <span class="cov0" title="0">{
        valsToRemove := map[common.Address]struct{}{}
        for </span><span class="cov0" title="0">{
                // Abort if we've rewound to a head block that does have associated state
                if _, err := state.New((*head).Root(), bc.stateCache); err == nil </span><span class="cov0" title="0">{
                        utils.Logger().Info().
                                Str("number", (*head).Number().String()).
                                Str("hash", (*head).Hash().Hex()).
                                Msg("Rewound blockchain to past state")
                        return bc.removeInValidatorList(valsToRemove)
                }</span>
                // Repair last commit sigs
                <span class="cov0" title="0">lastSig := (*head).Header().LastCommitSignature()
                sigAndBitMap := append(lastSig[:], (*head).Header().LastCommitBitmap()...)
                bc.WriteCommitSig((*head).NumberU64()-1, sigAndBitMap)

                // Otherwise rewind one block and recheck state availability there
                for _, stkTxn := range (*head).StakingTransactions() </span><span class="cov0" title="0">{
                        if stkTxn.StakingType() == staking.DirectiveCreateValidator </span><span class="cov0" title="0">{
                                if addr, err := stkTxn.SenderAddress(); err == nil </span><span class="cov0" title="0">{
                                        valsToRemove[addr] = struct{}{}
                                }</span> else<span class="cov0" title="0"> {
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">block := bc.GetBlock((*head).ParentHash(), (*head).NumberU64()-1)
                if block == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing block %d [%x]", (*head).NumberU64()-1, (*head).ParentHash())
                }</span>
                <span class="cov0" title="0">*head = block</span>
        }
}

// This func is used to remove the validator addresses from the validator list.
func (bc *BlockChain) removeInValidatorList(toRemove map[common.Address]struct{}) error <span class="cov0" title="0">{
        if len(toRemove) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">utils.Logger().Info().
                Interface("validators", toRemove).
                Msg("Removing validators from validator list")

        existingVals, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">newVals := []common.Address{}
        for _, addr := range existingVals </span><span class="cov0" title="0">{
                if _, ok := toRemove[addr]; !ok </span><span class="cov0" title="0">{
                        newVals = append(newVals, addr)
                }</span>
        }
        <span class="cov0" title="0">return bc.WriteValidatorList(bc.db, newVals)</span>
}

// Export writes the active chain to the given writer.
func (bc *BlockChain) Export(w io.Writer) error <span class="cov0" title="0">{
        return bc.ExportN(w, uint64(0), bc.CurrentBlock().NumberU64())
}</span>

// ExportN writes a subset of the active chain to the given writer.
func (bc *BlockChain) ExportN(w io.Writer, first uint64, last uint64) error <span class="cov0" title="0">{
        bc.mu.RLock()
        defer bc.mu.RUnlock()

        if first &gt; last </span><span class="cov0" title="0">{
                return fmt.Errorf("export failed: first (%d) is greater than last (%d)", first, last)
        }</span>
        <span class="cov0" title="0">utils.Logger().Info().Uint64("count", last-first+1).Msg("Exporting batch of blocks")

        start, reported := time.Now(), time.Now()
        for nr := first; nr &lt;= last; nr++ </span><span class="cov0" title="0">{
                block := bc.GetBlockByNumber(nr)
                if block == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("export failed on #%d: not found", nr)
                }</span>
                <span class="cov0" title="0">if err := block.EncodeRLP(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if time.Since(reported) &gt;= statsReportLimit </span><span class="cov0" title="0">{
                        utils.Logger().Info().
                                Uint64("exported", block.NumberU64()-first).
                                Str("elapsed", common.PrettyDuration(time.Since(start)).String()).
                                Msg("Exporting blocks")
                        reported = time.Now()
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// writeHeadBlock writes a new head block
func (bc *BlockChain) writeHeadBlock(block *types.Block) error <span class="cov8" title="1">{
        // If the block is on a side chain or an unknown one, force other heads onto it too
        updateHeads := rawdb.ReadCanonicalHash(bc.db, block.NumberU64()) != block.Hash()

        // Add the block to the canonical chain number scheme and mark as the head
        batch := bc.ChainDb().NewBatch()
        if err := rawdb.WriteCanonicalHash(batch, block.Hash(), block.NumberU64()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WriteHeadBlockHash(batch, block.Hash()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bc.currentBlock.Store(block)

        // If the block is better than our head or is on a different chain, force update heads
        if updateHeads </span><span class="cov8" title="1">{
                if err := bc.hc.SetCurrentHeader(block.Header()); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "HeaderChain SetCurrentHeader")
                }</span>
                <span class="cov8" title="1">if err := rawdb.WriteHeadFastBlockHash(bc.db, block.Hash()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">bc.currentFastBlock.Store(block)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// insert injects a new head block into the current block chain. This method
// assumes that the block is indeed a true head. It will also reset the head
// header and the head fast sync block to this very same block if they are older
// or if they are on a different side chain.
//
// Note, this function assumes that the `mu` mutex is held!
func (bc *BlockChain) insert(block *types.Block) error <span class="cov0" title="0">{
        return bc.writeHeadBlock(block)
}</span>

// Genesis retrieves the chain's genesis block.
func (bc *BlockChain) Genesis() *types.Block <span class="cov0" title="0">{
        return bc.genesisBlock
}</span>

// GetBody retrieves a block body (transactions and uncles) from the database by
// hash, caching it if found.
func (bc *BlockChain) GetBody(hash common.Hash) *types.Body <span class="cov0" title="0">{
        // Short circuit if the body's already in the cache, retrieve otherwise
        if cached, ok := bc.bodyCache.Get(hash); ok </span><span class="cov0" title="0">{
                body := cached.(*types.Body)
                return body
        }</span>
        <span class="cov0" title="0">number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">body := rawdb.ReadBody(bc.db, hash, *number)
        if body == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Cache the found body for next time and return
        <span class="cov0" title="0">bc.bodyCache.Add(hash, body)
        return body</span>
}

// GetBodyRLP retrieves a block body in RLP encoding from the database by hash,
// caching it if found.
func (bc *BlockChain) GetBodyRLP(hash common.Hash) rlp.RawValue <span class="cov0" title="0">{
        // Short circuit if the body's already in the cache, retrieve otherwise
        if cached, ok := bc.bodyRLPCache.Get(hash); ok </span><span class="cov0" title="0">{
                return cached.(rlp.RawValue)
        }</span>
        <span class="cov0" title="0">number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">body := rawdb.ReadBodyRLP(bc.db, hash, *number)
        if len(body) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Cache the found body for next time and return
        <span class="cov0" title="0">bc.bodyRLPCache.Add(hash, body)
        return body</span>
}

// HasBlock checks if a block is fully present in the database or not.
func (bc *BlockChain) HasBlock(hash common.Hash, number uint64) bool <span class="cov0" title="0">{
        if bc.blockCache.Contains(hash) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return rawdb.HasBody(bc.db, hash, number)</span>
}

// HasState checks if state trie is fully present in the database or not.
func (bc *BlockChain) HasState(hash common.Hash) bool <span class="cov8" title="1">{
        _, err := bc.stateCache.OpenTrie(hash)
        return err == nil
}</span>

// HasBlockAndState checks if a block and associated state trie is fully present
// in the database or not, caching it if present.
func (bc *BlockChain) HasBlockAndState(hash common.Hash, number uint64) bool <span class="cov8" title="1">{
        // Check first that the block itself is known
        block := bc.GetBlock(hash, number)
        if block == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return bc.HasState(block.Root())</span>
}

// GetBlock retrieves a block from the database by hash and number,
// caching it if found.
func (bc *BlockChain) GetBlock(hash common.Hash, number uint64) *types.Block <span class="cov8" title="1">{
        // Short circuit if the block's already in the cache, retrieve otherwise
        if block, ok := bc.blockCache.Get(hash); ok </span><span class="cov8" title="1">{
                return block.(*types.Block)
        }</span>
        <span class="cov8" title="1">block := rawdb.ReadBlock(bc.db, hash, number)
        if block == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Cache the found block for next time and return
        <span class="cov8" title="1">bc.blockCache.Add(block.Hash(), block)
        return block</span>
}

// GetBlockByHash retrieves a block from the database by hash, caching it if found.
func (bc *BlockChain) GetBlockByHash(hash common.Hash) *types.Block <span class="cov8" title="1">{
        number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return bc.GetBlock(hash, *number)</span>
}

// GetBlockByNumber retrieves a block from the database by number, caching it
// (associated with its hash) if found.
func (bc *BlockChain) GetBlockByNumber(number uint64) *types.Block <span class="cov8" title="1">{
        hash := rawdb.ReadCanonicalHash(bc.db, number)
        if hash == (common.Hash{}) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return bc.GetBlock(hash, number)</span>
}

// GetReceiptsByHash retrieves the receipts for all transactions in a given block.
func (bc *BlockChain) GetReceiptsByHash(hash common.Hash) types.Receipts <span class="cov0" title="0">{
        if receipts, ok := bc.receiptsCache.Get(hash); ok </span><span class="cov0" title="0">{
                return receipts.(types.Receipts)
        }</span>

        <span class="cov0" title="0">number := rawdb.ReadHeaderNumber(bc.db, hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">receipts := rawdb.ReadReceipts(bc.db, hash, *number)
        bc.receiptsCache.Add(hash, receipts)
        return receipts</span>
}

// GetBlocksFromHash returns the block corresponding to hash and up to n-1 ancestors.
// [deprecated by eth/62]
func (bc *BlockChain) GetBlocksFromHash(hash common.Hash, n int) (blocks []*types.Block) <span class="cov0" title="0">{
        number := bc.hc.GetBlockNumber(hash)
        if number == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                block := bc.GetBlock(hash, *number)
                if block == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">blocks = append(blocks, block)
                hash = block.ParentHash()
                *number--</span>
        }
        <span class="cov0" title="0">return</span>
}

// GetUnclesInChain retrieves all the uncles from a given block backwards until
// a specific distance is reached.
func (bc *BlockChain) GetUnclesInChain(b *types.Block, length int) []*block.Header <span class="cov0" title="0">{
        uncles := []*block.Header{}
        for i := 0; b != nil &amp;&amp; i &lt; length; i++ </span><span class="cov0" title="0">{
                uncles = append(uncles, b.Uncles()...)
                b = bc.GetBlock(b.ParentHash(), b.NumberU64()-1)
        }</span>
        <span class="cov0" title="0">return uncles</span>
}

// TrieNode retrieves a blob of data associated with a trie node (or code hash)
// either from ephemeral in-memory cache, or from persistent storage.
func (bc *BlockChain) TrieNode(hash common.Hash) ([]byte, error) <span class="cov0" title="0">{
        return bc.stateCache.TrieDB().Node(hash)
}</span>

// Stop stops the blockchain service. If any imports are currently in progress
// it will abort them using the procInterrupt.
func (bc *BlockChain) Stop() <span class="cov0" title="0">{
        if !atomic.CompareAndSwapInt32(&amp;bc.running, 0, 1) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := bc.SavePendingCrossLinks(); err != nil </span><span class="cov0" title="0">{
                utils.Logger().Error().Err(err).Msg("Failed to save pending cross links")
        }</span>

        // Unsubscribe all subscriptions registered from blockchain
        <span class="cov0" title="0">bc.scope.Close()
        close(bc.quit)
        atomic.StoreInt32(&amp;bc.procInterrupt, 1)

        bc.wg.Wait()

        // Ensure the state of a recent block is also stored to disk before exiting.
        // We're writing three different states to catch different restart scenarios:
        //  - HEAD:     So we don't need to reprocess any blocks in the general case
        //  - HEAD-1:   So we don't do large reorgs if our HEAD becomes an uncle
        //  - HEAD-127: So we have a hard limit on the number of blocks reexecuted
        if !bc.cacheConfig.Disabled </span><span class="cov0" title="0">{
                triedb := bc.stateCache.TrieDB()

                for _, offset := range []uint64{0, 1, triesInMemory - 1} </span><span class="cov0" title="0">{
                        if number := bc.CurrentBlock().NumberU64(); number &gt; offset </span><span class="cov0" title="0">{
                                recent := bc.GetHeaderByNumber(number - offset)
                                if recent != nil </span><span class="cov0" title="0">{
                                        utils.Logger().Info().
                                                Str("block", recent.Number().String()).
                                                Str("hash", recent.Hash().Hex()).
                                                Str("root", recent.Root().Hex()).
                                                Msg("Writing cached state to disk")
                                        if err := triedb.Commit(recent.Root(), true); err != nil </span><span class="cov0" title="0">{
                                                utils.Logger().Error().Err(err).Msg("Failed to commit recent state trie")
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">for !bc.triegc.Empty() </span><span class="cov0" title="0">{
                        triedb.Dereference(bc.triegc.PopItem().(common.Hash))
                }</span>
                <span class="cov0" title="0">if size, _ := triedb.Size(); size != 0 </span><span class="cov0" title="0">{
                        utils.Logger().Error().Msg("Dangling trie nodes after full cleanup")
                }</span>
        }
        <span class="cov0" title="0">utils.Logger().Info().Msg("Blockchain manager stopped")</span>
}

func (bc *BlockChain) procFutureBlocks() <span class="cov8" title="1">{
        blocks := make([]*types.Block, 0, bc.futureBlocks.Len())
        for _, hash := range bc.futureBlocks.Keys() </span><span class="cov0" title="0">{
                if block, exist := bc.futureBlocks.Peek(hash); exist </span><span class="cov0" title="0">{
                        blocks = append(blocks, block.(*types.Block))
                }</span>
        }
        <span class="cov8" title="1">if len(blocks) &gt; 0 </span><span class="cov0" title="0">{
                types.BlockBy(types.Number).Sort(blocks)

                // Insert one by one as chain insertion needs contiguous ancestry between blocks
                for i := range blocks </span><span class="cov0" title="0">{
                        bc.InsertChain(blocks[i:i+1], true /* verifyHeaders */)
                }</span>
        }
}

// WriteStatus status of write
type WriteStatus byte

// Constants for WriteStatus
const (
        NonStatTy WriteStatus = iota
        CanonStatTy
        SideStatTy
)

// Rollback is designed to remove a chain of links from the database that aren't
// certain enough to be valid.
func (bc *BlockChain) Rollback(chain []common.Hash) error <span class="cov0" title="0">{
        bc.mu.Lock()
        defer bc.mu.Unlock()

        valsToRemove := map[common.Address]struct{}{}
        for i := len(chain) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                hash := chain[i]

                currentHeader := bc.hc.CurrentHeader()
                if currentHeader != nil &amp;&amp; currentHeader.Hash() == hash </span><span class="cov0" title="0">{
                        parentHeader := bc.GetHeader(currentHeader.ParentHash(), currentHeader.Number().Uint64()-1)
                        if parentHeader != nil </span><span class="cov0" title="0">{
                                if err := bc.hc.SetCurrentHeader(parentHeader); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "HeaderChain SetCurrentHeader")
                                }</span>
                        }
                }
                <span class="cov0" title="0">if currentFastBlock := bc.CurrentFastBlock(); currentFastBlock != nil &amp;&amp; currentFastBlock.Hash() == hash </span><span class="cov0" title="0">{
                        newFastBlock := bc.GetBlock(currentFastBlock.ParentHash(), currentFastBlock.NumberU64()-1)
                        if newFastBlock != nil </span><span class="cov0" title="0">{
                                bc.currentFastBlock.Store(newFastBlock)
                                rawdb.WriteHeadFastBlockHash(bc.db, newFastBlock.Hash())
                        }</span>
                }
                <span class="cov0" title="0">if currentBlock := bc.CurrentBlock(); currentBlock != nil &amp;&amp; currentBlock.Hash() == hash </span><span class="cov0" title="0">{
                        newBlock := bc.GetBlock(currentBlock.ParentHash(), currentBlock.NumberU64()-1)
                        if newBlock != nil </span><span class="cov0" title="0">{
                                bc.currentBlock.Store(newBlock)
                                if err := rawdb.WriteHeadBlockHash(bc.db, newBlock.Hash()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">for _, stkTxn := range currentBlock.StakingTransactions() </span><span class="cov0" title="0">{
                                        if stkTxn.StakingType() == staking.DirectiveCreateValidator </span><span class="cov0" title="0">{
                                                if addr, err := stkTxn.SenderAddress(); err == nil </span><span class="cov0" title="0">{
                                                        valsToRemove[addr] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">return bc.removeInValidatorList(valsToRemove)</span>
}

// SetReceiptsData computes all the non-consensus fields of the receipts
func SetReceiptsData(config *params.ChainConfig, block *types.Block, receipts types.Receipts) error <span class="cov0" title="0">{
        signer := types.MakeSigner(config, block.Epoch())
        ethSigner := types.NewEIP155Signer(config.EthCompatibleChainID)

        transactions, stakingTransactions, logIndex := block.Transactions(), block.StakingTransactions(), uint(0)
        if len(transactions)+len(stakingTransactions) != len(receipts) </span><span class="cov0" title="0">{
                return errors.New("transaction+stakingTransactions and receipt count mismatch")
        }</span>

        // The used gas can be calculated based on previous receipts
        <span class="cov0" title="0">if len(receipts) &gt; 0 &amp;&amp; len(transactions) &gt; 0 </span><span class="cov0" title="0">{
                receipts[0].GasUsed = receipts[0].CumulativeGasUsed
        }</span>
        <span class="cov0" title="0">for j := 1; j &lt; len(transactions); j++ </span><span class="cov0" title="0">{
                // The transaction hash can be retrieved from the transaction itself
                receipts[j].TxHash = transactions[j].Hash()
                receipts[j].GasUsed = receipts[j].CumulativeGasUsed - receipts[j-1].CumulativeGasUsed
                // The contract address can be derived from the transaction itself
                if transactions[j].To() == nil </span><span class="cov0" title="0">{
                        // Deriving the signer is expensive, only do if it's actually needed
                        var from common.Address
                        if transactions[j].IsEthCompatible() </span><span class="cov0" title="0">{
                                from, _ = types.Sender(ethSigner, transactions[j])
                        }</span> else<span class="cov0" title="0"> {
                                from, _ = types.Sender(signer, transactions[j])
                        }</span>
                        <span class="cov0" title="0">receipts[j].ContractAddress = crypto.CreateAddress(from, transactions[j].Nonce())</span>
                }
                // The derived log fields can simply be set from the block and transaction
                <span class="cov0" title="0">for k := 0; k &lt; len(receipts[j].Logs); k++ </span><span class="cov0" title="0">{
                        receipts[j].Logs[k].BlockNumber = block.NumberU64()
                        receipts[j].Logs[k].BlockHash = block.Hash()
                        receipts[j].Logs[k].TxHash = receipts[j].TxHash
                        receipts[j].Logs[k].TxIndex = uint(j)
                        receipts[j].Logs[k].Index = logIndex
                        logIndex++
                }</span>
        }

        // The used gas can be calculated based on previous receipts
        <span class="cov0" title="0">if len(receipts) &gt; len(transactions) &amp;&amp; len(stakingTransactions) &gt; 0 </span><span class="cov0" title="0">{
                receipts[len(transactions)].GasUsed = receipts[len(transactions)].CumulativeGasUsed
        }</span>
        // in a block, txns are processed before staking txns
        <span class="cov0" title="0">for j := len(transactions) + 1; j &lt; len(transactions)+len(stakingTransactions); j++ </span><span class="cov0" title="0">{
                // The transaction hash can be retrieved from the staking transaction itself
                receipts[j].TxHash = stakingTransactions[j].Hash()
                receipts[j].GasUsed = receipts[j].CumulativeGasUsed - receipts[j-1].CumulativeGasUsed
                // The derived log fields can simply be set from the block and transaction
                for k := 0; k &lt; len(receipts[j].Logs); k++ </span><span class="cov0" title="0">{
                        receipts[j].Logs[k].BlockNumber = block.NumberU64()
                        receipts[j].Logs[k].BlockHash = block.Hash()
                        receipts[j].Logs[k].TxHash = receipts[j].TxHash
                        receipts[j].Logs[k].TxIndex = uint(j) + uint(len(transactions))
                        receipts[j].Logs[k].Index = logIndex
                        logIndex++
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// InsertReceiptChain attempts to complete an already existing header chain with
// transaction and receipt data.
func (bc *BlockChain) InsertReceiptChain(blockChain types.Blocks, receiptChain []types.Receipts) (int, error) <span class="cov0" title="0">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        // Do a sanity check that the provided chain is actually ordered and linked
        for i := 1; i &lt; len(blockChain); i++ </span><span class="cov0" title="0">{
                if blockChain[i].NumberU64() != blockChain[i-1].NumberU64()+1 || blockChain[i].ParentHash() != blockChain[i-1].Hash() </span><span class="cov0" title="0">{
                        utils.Logger().Error().
                                Str("number", blockChain[i].Number().String()).
                                Str("hash", blockChain[i].Hash().Hex()).
                                Str("parent", blockChain[i].ParentHash().Hex()).
                                Str("prevnumber", blockChain[i-1].Number().String()).
                                Str("prevhash", blockChain[i-1].Hash().Hex()).
                                Msg("Non contiguous receipt insert")
                        return 0, fmt.Errorf("non contiguous insert: item %d is #%d [%x…], item %d is #%d [%x…] (parent [%x…])", i-1, blockChain[i-1].NumberU64(),
                                blockChain[i-1].Hash().Bytes()[:4], i, blockChain[i].NumberU64(), blockChain[i].Hash().Bytes()[:4], blockChain[i].ParentHash().Bytes()[:4])
                }</span>
        }

        <span class="cov0" title="0">var (
                stats = struct{ processed, ignored int32 }{}
                start = time.Now()
                bytes = 0
                batch = bc.db.NewBatch()
        )
        for i, block := range blockChain </span><span class="cov0" title="0">{
                receipts := receiptChain[i]
                // Short circuit insertion if shutting down or processing failed
                if atomic.LoadInt32(&amp;bc.procInterrupt) == 1 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                // Short circuit if the owner header is unknown
                <span class="cov0" title="0">if !bc.HasHeader(block.Hash(), block.NumberU64()) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("containing header #%d [%x…] unknown", block.Number(), block.Hash().Bytes()[:4])
                }</span>
                // Skip if the entire data is already known
                <span class="cov0" title="0">if bc.HasBlock(block.Hash(), block.NumberU64()) </span><span class="cov0" title="0">{
                        stats.ignored++
                        continue</span>
                }
                // Compute all the non-consensus fields of the receipts
                <span class="cov0" title="0">if err := SetReceiptsData(bc.chainConfig, block, receipts); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to set receipts data: %v", err)
                }</span>
                // Write all the data out into the database
                <span class="cov0" title="0">if err := rawdb.WriteBody(batch, block.Hash(), block.NumberU64(), block.Body()); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteReceipts(batch, block.Hash(), block.NumberU64(), receipts); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteBlockTxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WriteBlockStxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">stats.processed++

                if batch.ValueSize() &gt;= ethdb.IdealBatchSize </span><span class="cov0" title="0">{
                        if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">bytes += batch.ValueSize()
                        batch.Reset()</span>
                }
        }
        <span class="cov0" title="0">if batch.ValueSize() &gt; 0 </span><span class="cov0" title="0">{
                bytes += batch.ValueSize()
                if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        // Update the head fast sync block if better
        <span class="cov0" title="0">bc.mu.Lock()
        head := blockChain[len(blockChain)-1]
        if td := bc.GetTd(head.Hash(), head.NumberU64()); td != nil </span><span class="cov0" title="0">{ // Rewind may have occurred, skip in that case
                currentFastBlock := bc.CurrentFastBlock()
                if bc.GetTd(currentFastBlock.Hash(), currentFastBlock.NumberU64()).Cmp(td) &lt; 0 </span><span class="cov0" title="0">{
                        rawdb.WriteHeadFastBlockHash(bc.db, head.Hash())
                        bc.currentFastBlock.Store(head)
                }</span>
        }
        <span class="cov0" title="0">bc.mu.Unlock()

        utils.Logger().Info().
                Int32("count", stats.processed).
                Str("elapsed", common.PrettyDuration(time.Since(start)).String()).
                Str("age", common.PrettyAge(time.Unix(head.Time().Int64(), 0)).String()).
                Str("head", head.Number().String()).
                Str("hash", head.Hash().Hex()).
                Str("size", common.StorageSize(bytes).String()).
                Int32("ignored", stats.ignored).
                Msg("Imported new block receipts")

        return 0, nil</span>
}

var lastWrite uint64

// WriteBlockWithoutState writes only the block and its metadata to the database,
// but does not write any state. This is used to construct competing side forks
// up to the point where they exceed the canonical total difficulty.
func (bc *BlockChain) WriteBlockWithoutState(block *types.Block, td *big.Int) (err error) <span class="cov0" title="0">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        if err := bc.hc.WriteTd(block.Hash(), block.NumberU64(), td); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WriteBlock(bc.db, block); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WriteBlockWithState writes the block and all associated state to the database.
func (bc *BlockChain) WriteBlockWithState(
        block *types.Block, receipts []*types.Receipt,
        cxReceipts []*types.CXReceipt,
        paid reward.Reader,
        state *state.DB,
) (status WriteStatus, err error) <span class="cov8" title="1">{
        bc.wg.Add(1)
        defer bc.wg.Done()

        // Make sure no inconsistent state is leaked during insertion
        bc.mu.Lock()
        defer bc.mu.Unlock()

        currentBlock := bc.CurrentBlock()
        if currentBlock == nil || block.ParentHash() != currentBlock.Hash() </span><span class="cov0" title="0">{
                return NonStatTy, errors.New("Hash of parent block doesn't match the current block hash")
        }</span>

        // Commit state object changes to in-memory trie
        <span class="cov8" title="1">root, err := state.Commit(bc.chainConfig.IsS3(block.Epoch()))
        if err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>

        // Flush trie state into disk if it's archival node or the block is epoch block
        <span class="cov8" title="1">triedb := bc.stateCache.TrieDB()
        if bc.cacheConfig.Disabled || block.IsLastBlockInEpoch() </span><span class="cov0" title="0">{
                if err := triedb.Commit(root, false); err != nil </span><span class="cov0" title="0">{
                        if isUnrecoverableErr(err) </span><span class="cov0" title="0">{
                                fmt.Printf("Unrecoverable error when committing triedb: %v\nExitting\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">return NonStatTy, err</span>
                }
        } else<span class="cov8" title="1"> {
                // Full but not archive node, do proper garbage collection
                triedb.Reference(root, common.Hash{}) // metadata reference to keep trie alive
                bc.triegc.Push(root, -int64(block.NumberU64()))

                if current := block.NumberU64(); current &gt; triesInMemory </span><span class="cov0" title="0">{
                        // If we exceeded our memory allowance, flush matured singleton nodes to disk
                        var (
                                nodes, imgs = triedb.Size()
                                limit       = common.StorageSize(bc.cacheConfig.TrieNodeLimit) * 1024 * 1024
                        )
                        if nodes &gt; limit || imgs &gt; 4*1024*1024 </span><span class="cov0" title="0">{
                                triedb.Cap(limit - ethdb.IdealBatchSize)
                        }</span>
                        // Find the next state trie we need to commit
                        <span class="cov0" title="0">header := bc.GetHeaderByNumber(current - triesInMemory)
                        if header != nil </span><span class="cov0" title="0">{
                                chosen := header.Number().Uint64()

                                // If we exceeded out time allowance, flush an entire trie to disk
                                if bc.gcproc &gt; bc.cacheConfig.TrieTimeLimit </span><span class="cov0" title="0">{
                                        // If we're exceeding limits but haven't reached a large enough memory gap,
                                        // warn the user that the system is becoming unstable.
                                        if chosen &lt; lastWrite+triesInMemory &amp;&amp; bc.gcproc &gt;= 2*bc.cacheConfig.TrieTimeLimit </span><span class="cov0" title="0">{
                                                utils.Logger().Info().
                                                        Dur("time", bc.gcproc).
                                                        Dur("allowance", bc.cacheConfig.TrieTimeLimit).
                                                        Float64("optimum", float64(chosen-lastWrite)/triesInMemory).
                                                        Msg("State in memory for too long, committing")
                                        }</span>
                                        // Flush an entire trie and restart the counters
                                        <span class="cov0" title="0">triedb.Commit(header.Root(), true)
                                        lastWrite = chosen
                                        bc.gcproc = 0</span>
                                }
                                // Garbage collect anything below our required write retention
                                <span class="cov0" title="0">for !bc.triegc.Empty() </span><span class="cov0" title="0">{
                                        root, number := bc.triegc.Pop()
                                        if uint64(-number) &gt; chosen </span><span class="cov0" title="0">{
                                                bc.triegc.Push(root, number)
                                                break</span>
                                        }
                                        <span class="cov0" title="0">if -number &gt; bc.maxGarbCollectedBlkNum </span><span class="cov0" title="0">{
                                                bc.maxGarbCollectedBlkNum = -number
                                        }</span>
                                        <span class="cov0" title="0">triedb.Dereference(root.(common.Hash))</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">batch := bc.db.NewBatch()
        // Write the raw block
        if err := rawdb.WriteBlock(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>

        // Write offchain data
        <span class="cov8" title="1">if status, err := bc.CommitOffChainData(
                batch, block, receipts,
                cxReceipts, paid, state,
        ); err != nil </span><span class="cov0" title="0">{
                return status, err
        }</span>

        // Write the positional metadata for transaction/receipt lookups and preimages
        <span class="cov8" title="1">if err := rawdb.WriteBlockTxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WriteBlockStxLookUpEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WriteCxLookupEntries(batch, block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>
        <span class="cov8" title="1">if err := rawdb.WritePreimages(batch, block.NumberU64(), state.Preimages()); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, err
        }</span>

        <span class="cov8" title="1">if err := batch.Write(); err != nil </span><span class="cov0" title="0">{
                if isUnrecoverableErr(err) </span><span class="cov0" title="0">{
                        fmt.Printf("Unrecoverable error when writing leveldb: %v\nExitting\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return NonStatTy, err</span>
        }

        // Update current block
        <span class="cov8" title="1">if err := bc.writeHeadBlock(block); err != nil </span><span class="cov0" title="0">{
                return NonStatTy, errors.Wrap(err, "writeHeadBlock")
        }</span>

        <span class="cov8" title="1">bc.futureBlocks.Remove(block.Hash())
        return CanonStatTy, nil</span>
}

// GetMaxGarbageCollectedBlockNumber ..
func (bc *BlockChain) GetMaxGarbageCollectedBlockNumber() int64 <span class="cov0" title="0">{
        return bc.maxGarbCollectedBlkNum
}</span>

// InsertChain attempts to insert the given batch of blocks in to the canonical
// chain or, otherwise, create a fork. If an error is returned it will return
// the index number of the failing block as well an error describing what went
// wrong.
//
// After insertion is done, all accumulated events will be fired.
func (bc *BlockChain) InsertChain(chain types.Blocks, verifyHeaders bool) (int, error) <span class="cov8" title="1">{
        n, events, logs, err := bc.insertChain(chain, verifyHeaders)
        bc.PostChainEvents(events, logs)
        return n, err
}</span>

// insertChain will execute the actual chain insertion and event aggregation. The
// only reason this method exists as a separate one is to make locking cleaner
// with deferred statements.
func (bc *BlockChain) insertChain(chain types.Blocks, verifyHeaders bool) (int, []interface{}, []*types.Log, error) <span class="cov8" title="1">{
        // Sanity check that we have something meaningful to import
        if len(chain) == 0 </span><span class="cov0" title="0">{
                return 0, nil, nil, nil
        }</span>
        // Do a sanity check that the provided chain is actually ordered and linked
        <span class="cov8" title="1">for i := 1; i &lt; len(chain); i++ </span><span class="cov0" title="0">{
                if chain[i].NumberU64() != chain[i-1].NumberU64()+1 || chain[i].ParentHash() != chain[i-1].Hash() </span><span class="cov0" title="0">{
                        // Chain broke ancestry, log a message (programming error) and skip insertion
                        utils.Logger().Error().
                                Str("number", chain[i].Number().String()).
                                Str("hash", chain[i].Hash().Hex()).
                                Str("parent", chain[i].ParentHash().Hex()).
                                Str("prevnumber", chain[i-1].Number().String()).
                                Str("prevhash", chain[i-1].Hash().Hex()).
                                Msg("insertChain: non contiguous block insert")

                        return 0, nil, nil, fmt.Errorf("non contiguous insert: item %d is #%d [%x…], item %d is #%d [%x…] (parent [%x…])", i-1, chain[i-1].NumberU64(),
                                chain[i-1].Hash().Bytes()[:4], i, chain[i].NumberU64(), chain[i].Hash().Bytes()[:4], chain[i].ParentHash().Bytes()[:4])
                }</span>
        }
        // Pre-checks passed, start the full block imports
        <span class="cov8" title="1">bc.wg.Add(1)
        defer bc.wg.Done()

        bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        // A queued approach to delivering events. This is generally
        // faster than direct delivery and requires much less mutex
        // acquiring.
        var (
                stats         = insertStats{startTime: mclock.Now()}
                events        = make([]interface{}, 0, len(chain))
                lastCanon     *types.Block
                coalescedLogs []*types.Log
        )

        var verifyHeadersResults &lt;-chan error

        // If the block header chain has not been verified, conduct header verification here.
        if verifyHeaders </span><span class="cov8" title="1">{
                headers := make([]*block.Header, len(chain))
                seals := make([]bool, len(chain))

                for i, block := range chain </span><span class="cov8" title="1">{
                        headers[i] = block.Header()
                        seals[i] = true
                }</span>
                // Note that VerifyHeaders verifies headers in the chain in parallel
                <span class="cov8" title="1">abort, results := bc.Engine().VerifyHeaders(bc, headers, seals)
                verifyHeadersResults = results
                defer close(abort)</span>
        }

        // Start a parallel signature recovery (signer will fluke on fork transition, minimal perf loss)
        //senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[0].Number()), chain)

        // Iterate over the blocks and insert when the verifier permits
        <span class="cov8" title="1">for i, block := range chain </span><span class="cov8" title="1">{
                // If the chain is terminating, stop processing blocks
                if atomic.LoadInt32(&amp;bc.procInterrupt) == 1 </span><span class="cov0" title="0">{
                        utils.Logger().Debug().Msg("Premature abort during blocks processing")
                        break</span>
                }
                // Wait for the block's verification to complete
                <span class="cov8" title="1">bstart := time.Now()

                var err error
                if verifyHeaders </span><span class="cov8" title="1">{
                        err = &lt;-verifyHeadersResults
                }</span>
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        err = bc.Validator().ValidateBody(block)
                }</span>
                <span class="cov8" title="1">switch </span>{
                case err == ErrKnownBlock:<span class="cov0" title="0">
                        // Block and state both already known. However if the current block is below
                        // this number we did a rollback and we should reimport it nonetheless.
                        if bc.CurrentBlock().NumberU64() &gt;= block.NumberU64() </span><span class="cov0" title="0">{
                                stats.ignored++
                                continue</span>
                        }

                case err == consensus_engine.ErrFutureBlock:<span class="cov0" title="0">
                        // Allow up to MaxFuture second in the future blocks. If this limit is exceeded
                        // the chain is discarded and processed at a later time if given.
                        max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)
                        if block.Time().Cmp(max) &gt; 0 </span><span class="cov0" title="0">{
                                return i, events, coalescedLogs, fmt.Errorf("future block: %v &gt; %v", block.Time(), max)
                        }</span>
                        <span class="cov0" title="0">bc.futureBlocks.Add(block.Hash(), block)
                        stats.queued++
                        continue</span>

                case err == consensus_engine.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()):<span class="cov0" title="0">
                        bc.futureBlocks.Add(block.Hash(), block)
                        stats.queued++
                        continue</span>

                case err == consensus_engine.ErrPrunedAncestor:<span class="cov0" title="0">
                        // TODO: add fork choice mechanism
                        // Block competing with the canonical chain, store in the db, but don't process
                        // until the competitor TD goes above the canonical TD
                        //currentBlock := bc.CurrentBlock()
                        //localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
                        //externTd := new(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()-1), block.Difficulty())
                        //if localTd.Cmp(externTd) &gt; 0 {
                        //        if err = bc.WriteBlockWithoutState(block, externTd); err != nil {
                        //                return i, events, coalescedLogs, err
                        //        }
                        //        continue
                        //}
                        // Competitor chain beat canonical, gather all blocks from the common ancestor
                        var winner []*types.Block

                        parent := bc.GetBlock(block.ParentHash(), block.NumberU64()-1)
                        for parent != nil &amp;&amp; !bc.HasState(parent.Root()) </span><span class="cov0" title="0">{
                                winner = append(winner, parent)
                                parent = bc.GetBlock(parent.ParentHash(), parent.NumberU64()-1)
                        }</span>
                        <span class="cov0" title="0">for j := 0; j &lt; len(winner)/2; j++ </span><span class="cov0" title="0">{
                                winner[j], winner[len(winner)-1-j] = winner[len(winner)-1-j], winner[j]
                        }</span>
                        // Prune in case non-empty winner chain
                        <span class="cov0" title="0">if len(winner) &gt; 0 </span><span class="cov0" title="0">{
                                // Import all the pruned blocks to make the state available
                                bc.chainmu.Unlock()
                                _, evs, logs, err := bc.insertChain(winner, true /* verifyHeaders */)
                                bc.chainmu.Lock()
                                events, coalescedLogs = evs, logs

                                if err != nil </span><span class="cov0" title="0">{
                                        return i, events, coalescedLogs, err
                                }</span>
                        }

                case err != nil:<span class="cov0" title="0">
                        bc.reportBlock(block, nil, err)
                        return i, events, coalescedLogs, err</span>
                }

                // Create a new statedb using the parent block and report an
                // error if it fails.
                <span class="cov8" title="1">var parent *types.Block
                if i == 0 </span><span class="cov8" title="1">{
                        parent = bc.GetBlock(block.ParentHash(), block.NumberU64()-1)
                }</span> else<span class="cov0" title="0"> {
                        parent = chain[i-1]
                }</span>
                <span class="cov8" title="1">state, err := state.New(parent.Root(), bc.stateCache)
                if err != nil </span><span class="cov0" title="0">{
                        return i, events, coalescedLogs, err
                }</span>

                // Process block using the parent state as reference point.
                <span class="cov8" title="1">receipts, cxReceipts, logs, usedGas, payout, err := bc.processor.Process(
                        block, state, bc.vmConfig,
                )
                if err != nil </span><span class="cov0" title="0">{
                        bc.reportBlock(block, receipts, err)
                        return i, events, coalescedLogs, err
                }</span>

                // Validate the state using the default validator
                <span class="cov8" title="1">if err := bc.Validator().ValidateState(
                        block, state, receipts, cxReceipts, usedGas,
                ); err != nil </span><span class="cov0" title="0">{
                        bc.reportBlock(block, receipts, err)
                        return i, events, coalescedLogs, err
                }</span>
                <span class="cov8" title="1">proctime := time.Since(bstart)

                // Write the block to the chain and get the status.
                status, err := bc.WriteBlockWithState(
                        block, receipts, cxReceipts, payout, state,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return i, events, coalescedLogs, err
                }</span>
                <span class="cov8" title="1">logger := utils.Logger().With().
                        Str("number", block.Number().String()).
                        Str("hash", block.Hash().Hex()).
                        Int("uncles", len(block.Uncles())).
                        Int("txs", len(block.Transactions())).
                        Int("stakingTxs", len(block.StakingTransactions())).
                        Uint64("gas", block.GasUsed()).
                        Str("elapsed", common.PrettyDuration(time.Since(bstart)).String()).
                        Logger()

                switch status </span>{
                case CanonStatTy:<span class="cov8" title="1">
                        logger.Info().Msg("Inserted new block")
                        coalescedLogs = append(coalescedLogs, logs...)
                        blockInsertTimer.UpdateSince(bstart)
                        events = append(events, ChainEvent{block, block.Hash(), logs})
                        lastCanon = block

                        // Only count canonical blocks for GC processing time
                        bc.gcproc += proctime</span>
                }

                <span class="cov8" title="1">stats.processed++
                stats.usedGas += usedGas
                cache, _ := bc.stateCache.TrieDB().Size()
                stats.report(chain, i, cache)</span>
        }
        // Append a single chain head event if we've progressed the chain
        <span class="cov8" title="1">if lastCanon != nil &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() </span><span class="cov8" title="1">{
                events = append(events, ChainHeadEvent{lastCanon})
        }</span>

        <span class="cov8" title="1">return 0, events, coalescedLogs, nil</span>
}

// insertStats tracks and reports on block insertion.
type insertStats struct {
        queued, processed, ignored int
        usedGas                    uint64
        lastIndex                  int
        startTime                  mclock.AbsTime
}

// statsReportLimit is the time limit during import and export after which we
// always print out progress. This avoids the user wondering what's going on.
const statsReportLimit = 8 * time.Second

// report prints statistics if some number of blocks have been processed
// or more than a few seconds have passed since the last message.
func (st *insertStats) report(chain []*types.Block, index int, cache common.StorageSize) <span class="cov8" title="1">{
        // Fetch the timings for the batch
        var (
                now     = mclock.Now()
                elapsed = time.Duration(now) - time.Duration(st.startTime)
        )
        // If we're at the last block of the batch or report period reached, log
        if index == len(chain)-1 || elapsed &gt;= statsReportLimit </span><span class="cov8" title="1">{
                var (
                        end = chain[index]
                        txs = countTransactions(chain[st.lastIndex : index+1])
                )

                context := utils.Logger().With().
                        Int("blocks", st.processed).
                        Int("txs", txs).
                        Float64("mgas", float64(st.usedGas)/1000000).
                        Str("elapsed", common.PrettyDuration(elapsed).String()).
                        Float64("mgasps", float64(st.usedGas)*1000/float64(elapsed)).
                        Str("number", end.Number().String()).
                        Str("hash", end.Hash().Hex()).
                        Str("cache", cache.String())

                if timestamp := time.Unix(end.Time().Int64(), 0); time.Since(timestamp) &gt; time.Minute </span><span class="cov0" title="0">{
                        context = context.Str("age", common.PrettyAge(timestamp).String())
                }</span>

                <span class="cov8" title="1">if st.queued &gt; 0 </span><span class="cov0" title="0">{
                        context = context.Int("queued", st.queued)
                }</span>
                <span class="cov8" title="1">if st.ignored &gt; 0 </span><span class="cov0" title="0">{
                        context = context.Int("ignored", st.ignored)
                }</span>

                <span class="cov8" title="1">logger := context.Logger()
                logger.Info().Msg("Imported new chain segment")

                *st = insertStats{startTime: now, lastIndex: index + 1}</span>
        }
}

func countTransactions(chain []*types.Block) (c int) <span class="cov8" title="1">{
        for _, b := range chain </span><span class="cov8" title="1">{
                c += len(b.Transactions())
        }</span>
        <span class="cov8" title="1">return c</span>
}

// PostChainEvents iterates over the events generated by a chain insertion and
// posts them into the event feed.
// TODO: Should not expose PostChainEvents. The chain events should be posted in WriteBlock.
func (bc *BlockChain) PostChainEvents(events []interface{}, logs []*types.Log) <span class="cov8" title="1">{
        // post event logs for further processing
        if logs != nil </span><span class="cov0" title="0">{
                bc.logsFeed.Send(logs)
        }</span>
        <span class="cov8" title="1">for _, event := range events </span><span class="cov8" title="1">{
                switch ev := event.(type) </span>{
                case ChainEvent:<span class="cov8" title="1">
                        bc.chainFeed.Send(ev)</span>

                case ChainHeadEvent:<span class="cov8" title="1">
                        bc.chainHeadFeed.Send(ev)</span>

                case ChainSideEvent:<span class="cov0" title="0">
                        bc.chainSideFeed.Send(ev)</span>
                }
        }
}

func (bc *BlockChain) update() <span class="cov8" title="1">{
        futureTimer := time.NewTicker(5 * time.Second)
        defer futureTimer.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-futureTimer.C:<span class="cov8" title="1">
                        bc.procFutureBlocks()</span>
                case &lt;-bc.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// BadBlock ..
type BadBlock struct {
        Block  *types.Block
        Reason error
}

// MarshalJSON ..
func (b BadBlock) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(struct {
                Block  *block.Header `json:"header"`
                Reason string        `json:"error-cause"`
        }{
                b.Block.Header(),
                b.Reason.Error(),
        })
}</span>

// BadBlocks returns a list of the last 'bad blocks' that
// the client has seen on the network
func (bc *BlockChain) BadBlocks() []BadBlock <span class="cov0" title="0">{
        blocks := make([]BadBlock, bc.badBlocks.Len())
        for _, hash := range bc.badBlocks.Keys() </span><span class="cov0" title="0">{
                if blk, exist := bc.badBlocks.Peek(hash); exist </span><span class="cov0" title="0">{
                        blocks = append(blocks, blk.(BadBlock))
                }</span>
        }
        <span class="cov0" title="0">return blocks</span>
}

// addBadBlock adds a bad block to the bad-block LRU cache
func (bc *BlockChain) addBadBlock(block *types.Block, reason error) <span class="cov0" title="0">{
        bc.badBlocks.Add(block.Hash(), BadBlock{block, reason})
}</span>

// reportBlock logs a bad block error.
func (bc *BlockChain) reportBlock(
        block *types.Block, receipts types.Receipts, err error,
) <span class="cov0" title="0">{
        bc.addBadBlock(block, err)
        var receiptString string
        for _, receipt := range receipts </span><span class="cov0" title="0">{
                receiptString += fmt.Sprintf("\t%v\n", receipt)
        }</span>
        <span class="cov0" title="0">utils.Logger().Error().Msgf(`
########## BAD BLOCK #########
Chain config: %v

Number: %v
Epoch: %v
NumTxn: %v
NumStkTxn: %v
Hash: 0x%x
%v

Error: %v
##############################
`, bc.chainConfig,
                block.Number(),
                block.Epoch(),
                len(block.Transactions()),
                len(block.StakingTransactions()),
                block.Hash(),
                receiptString,
                err,
        )
        for i, tx := range block.StakingTransactions() </span><span class="cov0" title="0">{
                utils.Logger().Error().
                        Msgf("StakingTxn %d: %s, %v", i, tx.StakingType().String(), tx.StakingMessage())
        }</span>
}

// InsertHeaderChain attempts to insert the given header chain in to the local
// chain, possibly creating a reorg. If an error is returned, it will return the
// index number of the failing header as well an error describing what went wrong.
//
// The verify parameter can be used to fine tune whether nonce verification
// should be done or not. The reason behind the optional check is because some
// of the header retrieval mechanisms already need to verify nonces, as well as
// because nonces can be verified sparsely, not needing to check each.
func (bc *BlockChain) InsertHeaderChain(chain []*block.Header, checkFreq int) (int, error) <span class="cov0" title="0">{
        start := time.Now()
        if i, err := bc.hc.ValidateHeaderChain(chain, checkFreq); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>

        // Make sure only one thread manipulates the chain at once
        <span class="cov0" title="0">bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        bc.wg.Add(1)
        defer bc.wg.Done()

        whFunc := func(header *block.Header) error </span><span class="cov0" title="0">{
                bc.mu.Lock()
                defer bc.mu.Unlock()

                _, err := bc.hc.WriteHeader(header)
                return err
        }</span>

        <span class="cov0" title="0">return bc.hc.InsertHeaderChain(chain, whFunc, start)</span>
}

// CurrentHeader retrieves the current head header of the canonical chain. The
// header is retrieved from the HeaderChain's internal cache.
func (bc *BlockChain) CurrentHeader() *block.Header <span class="cov8" title="1">{
        return bc.hc.CurrentHeader()
}</span>

// GetTd retrieves a block's total difficulty in the canonical chain from the
// database by hash and number, caching it if found.
func (bc *BlockChain) GetTd(hash common.Hash, number uint64) *big.Int <span class="cov8" title="1">{
        return bc.hc.GetTd(hash, number)
}</span>

// GetTdByHash retrieves a block's total difficulty in the canonical chain from the
// database by hash, caching it if found.
func (bc *BlockChain) GetTdByHash(hash common.Hash) *big.Int <span class="cov0" title="0">{
        return bc.hc.GetTdByHash(hash)
}</span>

// GetHeader retrieves a block header from the database by hash and number,
// caching it if found.
func (bc *BlockChain) GetHeader(hash common.Hash, number uint64) *block.Header <span class="cov8" title="1">{
        return bc.hc.GetHeader(hash, number)
}</span>

// GetHeaderByHash retrieves a block header from the database by hash, caching it if
// found.
func (bc *BlockChain) GetHeaderByHash(hash common.Hash) *block.Header <span class="cov8" title="1">{
        return bc.hc.GetHeaderByHash(hash)
}</span>

// HasHeader checks if a block header is present in the database or not, caching
// it if present.
func (bc *BlockChain) HasHeader(hash common.Hash, number uint64) bool <span class="cov0" title="0">{
        return bc.hc.HasHeader(hash, number)
}</span>

// GetBlockHashesFromHash retrieves a number of block hashes starting at a given
// hash, fetching towards the genesis block.
func (bc *BlockChain) GetBlockHashesFromHash(hash common.Hash, max uint64) []common.Hash <span class="cov0" title="0">{
        return bc.hc.GetBlockHashesFromHash(hash, max)
}</span>

// GetAncestor retrieves the Nth ancestor of a given block. It assumes that either the given block or
// a close ancestor of it is canonical. maxNonCanonical points to a downwards counter limiting the
// number of blocks to be individually checked before we reach the canonical chain.
//
// Note: ancestor == 0 returns the same block, 1 returns its parent and so on.
func (bc *BlockChain) GetAncestor(hash common.Hash, number, ancestor uint64, maxNonCanonical *uint64) (common.Hash, uint64) <span class="cov0" title="0">{
        bc.chainmu.Lock()
        defer bc.chainmu.Unlock()

        return bc.hc.GetAncestor(hash, number, ancestor, maxNonCanonical)
}</span>

// GetHeaderByNumber retrieves a block header from the database by number,
// caching it (associated with its hash) if found.
func (bc *BlockChain) GetHeaderByNumber(number uint64) *block.Header <span class="cov8" title="1">{
        return bc.hc.GetHeaderByNumber(number)
}</span>

// Config retrieves the blockchain's chain configuration.
func (bc *BlockChain) Config() *params.ChainConfig <span class="cov8" title="1">{ return bc.chainConfig }</span>

// Engine retrieves the blockchain's consensus engine.
func (bc *BlockChain) Engine() consensus_engine.Engine <span class="cov8" title="1">{ return bc.engine }</span>

// SubscribeRemovedLogsEvent registers a subscription of RemovedLogsEvent.
func (bc *BlockChain) SubscribeRemovedLogsEvent(ch chan&lt;- RemovedLogsEvent) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.rmLogsFeed.Subscribe(ch))
}</span>

// SubscribeChainEvent registers a subscription of ChainEvent.
func (bc *BlockChain) SubscribeChainEvent(ch chan&lt;- ChainEvent) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.chainFeed.Subscribe(ch))
}</span>

// SubscribeChainHeadEvent registers a subscription of ChainHeadEvent.
func (bc *BlockChain) SubscribeChainHeadEvent(ch chan&lt;- ChainHeadEvent) event.Subscription <span class="cov8" title="1">{
        return bc.scope.Track(bc.chainHeadFeed.Subscribe(ch))
}</span>

// SubscribeChainSideEvent registers a subscription of ChainSideEvent.
func (bc *BlockChain) SubscribeChainSideEvent(ch chan&lt;- ChainSideEvent) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.chainSideFeed.Subscribe(ch))
}</span>

// SubscribeLogsEvent registers a subscription of []*types.Log.
func (bc *BlockChain) SubscribeLogsEvent(ch chan&lt;- []*types.Log) event.Subscription <span class="cov0" title="0">{
        return bc.scope.Track(bc.logsFeed.Subscribe(ch))
}</span>

// ReadShardState retrieves sharding state given the epoch number.
func (bc *BlockChain) ReadShardState(epoch *big.Int) (*shard.State, error) <span class="cov8" title="1">{
        cacheKey := string(epoch.Bytes())
        if cached, ok := bc.shardStateCache.Get(cacheKey); ok </span><span class="cov8" title="1">{
                shardState := cached.(*shard.State)
                return shardState, nil
        }</span>
        <span class="cov8" title="1">shardState, err := rawdb.ReadShardState(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), rawdb.MsgNoShardStateFromDB) &amp;&amp;
                        shard.Schedule.IsSkippedEpoch(bc.ShardID(), epoch) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("epoch skipped on chain: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">bc.shardStateCache.Add(cacheKey, shardState)
        return shardState, nil</span>
}

// WriteShardStateBytes saves the given sharding state under the given epoch number.
func (bc *BlockChain) WriteShardStateBytes(db rawdb.DatabaseWriter,
        epoch *big.Int, shardState []byte,
) (*shard.State, error) <span class="cov8" title="1">{
        decodeShardState, err := shard.DecodeWrapper(shardState)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = rawdb.WriteShardStateBytes(db, epoch, shardState)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cacheKey := string(epoch.Bytes())
        bc.shardStateCache.Add(cacheKey, decodeShardState)
        return decodeShardState, nil</span>
}

// ReadCommitSig retrieves the commit signature on a block.
func (bc *BlockChain) ReadCommitSig(blockNum uint64) ([]byte, error) <span class="cov0" title="0">{
        if cached, ok := bc.lastCommitsCache.Get(blockNum); ok </span><span class="cov0" title="0">{
                lastCommits := cached.([]byte)
                return lastCommits, nil
        }</span>
        <span class="cov0" title="0">lastCommits, err := rawdb.ReadBlockCommitSig(bc.db, blockNum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return lastCommits, nil</span>
}

// WriteCommitSig saves the commits signatures signed on a block.
func (bc *BlockChain) WriteCommitSig(blockNum uint64, lastCommits []byte) error <span class="cov0" title="0">{
        err := rawdb.WriteBlockCommitSig(bc.db, blockNum, lastCommits)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.lastCommitsCache.Add(blockNum, lastCommits)
        return nil</span>
}

// GetVdfByNumber retrieves the rand seed given the block number, return 0 if not exist
func (bc *BlockChain) GetVdfByNumber(number uint64) []byte <span class="cov0" title="0">{
        header := bc.GetHeaderByNumber(number)
        if header == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>

        <span class="cov0" title="0">return header.Vdf()</span>
}

// GetVrfByNumber retrieves the randomness preimage given the block number, return 0 if not exist
func (bc *BlockChain) GetVrfByNumber(number uint64) []byte <span class="cov0" title="0">{
        header := bc.GetHeaderByNumber(number)
        if header == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return header.Vrf()</span>
}

// ChainDb returns the database
func (bc *BlockChain) ChainDb() ethdb.Database <span class="cov8" title="1">{ return bc.db }</span>

// GetEpochBlockNumber returns the first block number of the given epoch.
func (bc *BlockChain) GetEpochBlockNumber(epoch *big.Int) (*big.Int, error) <span class="cov0" title="0">{
        // Try cache first
        cacheKey := string(epoch.Bytes())
        if cachedValue, ok := bc.epochCache.Get(cacheKey); ok </span><span class="cov0" title="0">{
                return (&amp;big.Int{}).SetBytes([]byte(cachedValue.(string))), nil
        }</span>
        <span class="cov0" title="0">blockNum, err := rawdb.ReadEpochBlockNumber(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(
                        err, "cannot read epoch block number from database",
                )
        }</span>
        <span class="cov0" title="0">cachedValue := []byte(blockNum.Bytes())
        bc.epochCache.Add(cacheKey, cachedValue)
        return blockNum, nil</span>
}

// StoreEpochBlockNumber stores the given epoch-first block number.
func (bc *BlockChain) StoreEpochBlockNumber(
        epoch *big.Int, blockNum *big.Int,
) error <span class="cov0" title="0">{
        cacheKey := string(epoch.Bytes())
        cachedValue := []byte(blockNum.Bytes())
        bc.epochCache.Add(cacheKey, cachedValue)
        if err := rawdb.WriteEpochBlockNumber(bc.db, epoch, blockNum); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        err, "cannot write epoch block number to database",
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadEpochVrfBlockNums retrieves block numbers with valid VRF for the specified epoch
func (bc *BlockChain) ReadEpochVrfBlockNums(epoch *big.Int) ([]uint64, error) <span class="cov0" title="0">{
        vrfNumbers := []uint64{}
        if cached, ok := bc.randomnessCache.Get("vrf-" + string(epoch.Bytes())); ok </span><span class="cov0" title="0">{
                encodedVrfNumbers := cached.([]byte)
                if err := rlp.DecodeBytes(encodedVrfNumbers, &amp;vrfNumbers); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return vrfNumbers, nil</span>
        }

        <span class="cov0" title="0">encodedVrfNumbers, err := rawdb.ReadEpochVrfBlockNums(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := rlp.DecodeBytes(encodedVrfNumbers, &amp;vrfNumbers); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return vrfNumbers, nil</span>
}

// WriteEpochVrfBlockNums saves block numbers with valid VRF for the specified epoch
func (bc *BlockChain) WriteEpochVrfBlockNums(epoch *big.Int, vrfNumbers []uint64) error <span class="cov0" title="0">{
        encodedVrfNumbers, err := rlp.EncodeToBytes(vrfNumbers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = rawdb.WriteEpochVrfBlockNums(bc.db, epoch, encodedVrfNumbers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bc.randomnessCache.Add("vrf-"+string(epoch.Bytes()), encodedVrfNumbers)
        return nil</span>
}

// ReadEpochVdfBlockNum retrieves block number with valid VDF for the specified epoch
func (bc *BlockChain) ReadEpochVdfBlockNum(epoch *big.Int) (*big.Int, error) <span class="cov0" title="0">{
        if cached, ok := bc.randomnessCache.Get("vdf-" + string(epoch.Bytes())); ok </span><span class="cov0" title="0">{
                encodedVdfNumber := cached.([]byte)
                return new(big.Int).SetBytes(encodedVdfNumber), nil
        }</span>

        <span class="cov0" title="0">encodedVdfNumber, err := rawdb.ReadEpochVdfBlockNum(bc.db, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return new(big.Int).SetBytes(encodedVdfNumber), nil</span>
}

// WriteEpochVdfBlockNum saves block number with valid VDF for the specified epoch
func (bc *BlockChain) WriteEpochVdfBlockNum(epoch *big.Int, blockNum *big.Int) error <span class="cov0" title="0">{
        err := rawdb.WriteEpochVdfBlockNum(bc.db, epoch, blockNum.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bc.randomnessCache.Add("vdf-"+string(epoch.Bytes()), blockNum.Bytes())
        return nil</span>
}

// WriteCrossLinks saves the hashes of crosslinks by shardID and blockNum combination key
func (bc *BlockChain) WriteCrossLinks(batch rawdb.DatabaseWriter, cls []types.CrossLink) error <span class="cov0" title="0">{
        var err error
        for i := 0; i &lt; len(cls); i++ </span><span class="cov0" title="0">{
                cl := cls[i]
                err = rawdb.WriteCrossLinkShardBlock(batch, cl.ShardID(), cl.BlockNum(), cl.Serialize())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// DeleteCrossLinks removes the hashes of crosslinks by shardID and blockNum combination key
func (bc *BlockChain) DeleteCrossLinks(cls []types.CrossLink) error <span class="cov0" title="0">{
        var err error
        for i := 0; i &lt; len(cls); i++ </span><span class="cov0" title="0">{
                cl := cls[i]
                err = rawdb.DeleteCrossLinkShardBlock(bc.db, cl.ShardID(), cl.BlockNum())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// ReadCrossLink retrieves crosslink given shardID and blockNum.
func (bc *BlockChain) ReadCrossLink(shardID uint32, blockNum uint64) (*types.CrossLink, error) <span class="cov0" title="0">{
        bytes, err := rawdb.ReadCrossLinkShardBlock(bc.db, shardID, blockNum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">crossLink, err := types.DeserializeCrossLink(bytes)

        return crossLink, err</span>
}

// LastContinuousCrossLink saves the last crosslink of a shard
// This function will update the latest crosslink in the sense that
// any previous block's crosslink is received up to this point
// there is no missing hole between genesis to this crosslink of given shardID
func (bc *BlockChain) LastContinuousCrossLink(batch rawdb.DatabaseWriter, shardID uint32) error <span class="cov0" title="0">{
        oldLink, err := bc.ReadShardLastCrossLink(shardID)
        if oldLink == nil || err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">newLink := oldLink
        // Starting from last checkpoint, keeping reading immediate next crosslink until there is a gap
        for i := oldLink.BlockNum() + 1; ; i++ </span><span class="cov0" title="0">{
                tmp, err := bc.ReadCrossLink(shardID, i)
                if err == nil &amp;&amp; tmp != nil &amp;&amp; tmp.BlockNum() == i </span><span class="cov0" title="0">{
                        newLink = tmp
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">if newLink.BlockNum() &gt; oldLink.BlockNum() </span><span class="cov0" title="0">{
                utils.Logger().Debug().Msgf("LastContinuousCrossLink: latest checkpoint blockNum %d", newLink.BlockNum())
                return rawdb.WriteShardLastCrossLink(batch, shardID, newLink.Serialize())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadShardLastCrossLink retrieves the last crosslink of a shard.
func (bc *BlockChain) ReadShardLastCrossLink(shardID uint32) (*types.CrossLink, error) <span class="cov0" title="0">{
        bytes, err := rawdb.ReadShardLastCrossLink(bc.db, shardID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return types.DeserializeCrossLink(bytes)</span>
}

func (bc *BlockChain) writeSlashes(processed slash.Records) error <span class="cov0" title="0">{
        bytes, err := rlp.EncodeToBytes(processed)
        if err != nil </span><span class="cov0" title="0">{
                const msg = "failed to encode slashing candidates"
                utils.Logger().Error().Msg(msg)
                return err
        }</span>
        <span class="cov0" title="0">if err := rawdb.WritePendingSlashingCandidates(bc.db, bytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFromPendingSlashingCandidates ..
func (bc *BlockChain) DeleteFromPendingSlashingCandidates(
        processed slash.Records,
) error <span class="cov0" title="0">{
        bc.pendingSlashingCandidatesMU.Lock()
        defer bc.pendingSlashingCandidatesMU.Unlock()
        current := bc.ReadPendingSlashingCandidates()
        bc.pendingSlashes = processed.SetDifference(current)
        return bc.writeSlashes(bc.pendingSlashes)
}</span>

// ReadPendingSlashingCandidates retrieves pending slashing candidates
func (bc *BlockChain) ReadPendingSlashingCandidates() slash.Records <span class="cov0" title="0">{
        if !bc.Config().IsStaking(bc.CurrentHeader().Epoch()) </span><span class="cov0" title="0">{
                return slash.Records{}
        }</span>
        <span class="cov0" title="0">return append(bc.pendingSlashes[0:0], bc.pendingSlashes...)</span>
}

// ReadPendingCrossLinks retrieves pending crosslinks
func (bc *BlockChain) ReadPendingCrossLinks() ([]types.CrossLink, error) <span class="cov0" title="0">{
        cls := []types.CrossLink{}
        bytes := []byte{}
        if cached, ok := bc.pendingCrossLinksCache.Get(pendingCLCacheKey); ok </span><span class="cov0" title="0">{
                cls = cached.([]types.CrossLink)
                return cls, nil
        }</span> else<span class="cov0" title="0"> {
                by, err := rawdb.ReadPendingCrossLinks(bc.db)
                if err != nil || len(by) == 0 </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">bytes = by</span>
        }
        <span class="cov0" title="0">if err := rlp.DecodeBytes(bytes, &amp;cls); err != nil </span><span class="cov0" title="0">{
                utils.Logger().Error().Err(err).Msg("Invalid pending crosslink RLP decoding")
                return nil, err
        }</span>

        <span class="cov0" title="0">bc.pendingCrossLinksCache.Add(pendingCLCacheKey, cls)
        return cls, nil</span>
}

// CachePendingCrossLinks caches the pending crosslinks in memory
func (bc *BlockChain) CachePendingCrossLinks(crossLinks []types.CrossLink) error <span class="cov0" title="0">{
        // deduplicate crosslinks if any
        m := map[uint32]map[uint64]types.CrossLink{}
        for _, cl := range crossLinks </span><span class="cov0" title="0">{
                if _, ok := m[cl.ShardID()]; !ok </span><span class="cov0" title="0">{
                        m[cl.ShardID()] = map[uint64]types.CrossLink{}
                }</span>
                <span class="cov0" title="0">m[cl.ShardID()][cl.BlockNum()] = cl</span>
        }

        <span class="cov0" title="0">cls := []types.CrossLink{}
        for _, m1 := range m </span><span class="cov0" title="0">{
                for _, cl := range m1 </span><span class="cov0" title="0">{
                        cls = append(cls, cl)
                }</span>
        }
        <span class="cov0" title="0">utils.Logger().Debug().Msgf("[CachePendingCrossLinks] Before Dedup has %d cls, after Dedup has %d cls", len(crossLinks), len(cls))

        bc.pendingCrossLinksCache.Add(pendingCLCacheKey, cls)
        return nil</span>
}

// SavePendingCrossLinks saves the pending crosslinks in db
func (bc *BlockChain) SavePendingCrossLinks() error <span class="cov0" title="0">{
        if cached, ok := bc.pendingCrossLinksCache.Get(pendingCLCacheKey); ok </span><span class="cov0" title="0">{
                cls := cached.([]types.CrossLink)
                bytes, err := rlp.EncodeToBytes(cls)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := rawdb.WritePendingCrossLinks(bc.db, bytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// AddPendingSlashingCandidates appends pending slashing candidates
func (bc *BlockChain) AddPendingSlashingCandidates(
        candidates slash.Records,
) error <span class="cov0" title="0">{
        bc.pendingSlashingCandidatesMU.Lock()
        defer bc.pendingSlashingCandidatesMU.Unlock()
        current := bc.ReadPendingSlashingCandidates()

        state, err := bc.State()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">valid := slash.Records{}
        for i := range candidates </span><span class="cov0" title="0">{
                if err := slash.Verify(bc, state, &amp;candidates[i]); err == nil </span><span class="cov0" title="0">{
                        valid = append(valid, candidates[i])
                }</span>
        }

        <span class="cov0" title="0">pendingSlashes := append(
                bc.pendingSlashes, current.SetDifference(valid)...,
        )

        if l, c := len(pendingSlashes), len(current); l &gt; maxPendingSlashes </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        errExceedMaxPendingSlashes, "current %d with-additional %d", c, l,
                )
        }</span>
        <span class="cov0" title="0">bc.pendingSlashes = pendingSlashes
        return bc.writeSlashes(bc.pendingSlashes)</span>
}

// AddPendingCrossLinks appends pending crosslinks
func (bc *BlockChain) AddPendingCrossLinks(pendingCLs []types.CrossLink) (int, error) <span class="cov0" title="0">{
        bc.pendingCrossLinksMutex.Lock()
        defer bc.pendingCrossLinksMutex.Unlock()

        cls, err := bc.ReadPendingCrossLinks()
        if err != nil || len(cls) == 0 </span><span class="cov0" title="0">{
                err := bc.CachePendingCrossLinks(pendingCLs)
                return len(pendingCLs), err
        }</span>
        <span class="cov0" title="0">cls = append(cls, pendingCLs...)
        err = bc.CachePendingCrossLinks(cls)
        return len(cls), err</span>
}

// DeleteFromPendingCrossLinks delete pending crosslinks that already committed (i.e. passed in the params)
func (bc *BlockChain) DeleteFromPendingCrossLinks(crossLinks []types.CrossLink) (int, error) <span class="cov0" title="0">{
        bc.pendingCrossLinksMutex.Lock()
        defer bc.pendingCrossLinksMutex.Unlock()

        cls, err := bc.ReadPendingCrossLinks()
        if err != nil || len(cls) == 0 </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">m := map[uint32]map[uint64]struct{}{}
        for _, cl := range crossLinks </span><span class="cov0" title="0">{
                if _, ok := m[cl.ShardID()]; !ok </span><span class="cov0" title="0">{
                        m[cl.ShardID()] = map[uint64]struct{}{}
                }</span>
                <span class="cov0" title="0">m[cl.ShardID()][cl.BlockNum()] = struct{}{}</span>
        }

        <span class="cov0" title="0">pendingCLs := []types.CrossLink{}

        for _, cl := range cls </span><span class="cov0" title="0">{
                if _, ok := m[cl.ShardID()]; ok </span><span class="cov0" title="0">{
                        if _, ok1 := m[cl.ShardID()][cl.BlockNum()]; ok1 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">pendingCLs = append(pendingCLs, cl)</span>
        }
        <span class="cov0" title="0">err = bc.CachePendingCrossLinks(pendingCLs)
        return len(pendingCLs), err</span>
}

// IsSameLeaderAsPreviousBlock retrieves a block from the database by number, caching it
func (bc *BlockChain) IsSameLeaderAsPreviousBlock(block *types.Block) bool <span class="cov0" title="0">{
        if IsEpochBlock(block) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">previousHeader := bc.GetHeaderByNumber(block.NumberU64() - 1)
        if previousHeader == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return block.Coinbase() == previousHeader.Coinbase()</span>
}

// GetVMConfig returns the block chain VM config.
func (bc *BlockChain) GetVMConfig() *vm.Config <span class="cov0" title="0">{
        return &amp;bc.vmConfig
}</span>

// ReadCXReceipts retrieves the cross shard transaction receipts of a given shard
func (bc *BlockChain) ReadCXReceipts(shardID uint32, blockNum uint64, blockHash common.Hash) (types.CXReceipts, error) <span class="cov0" title="0">{
        cxs, err := rawdb.ReadCXReceipts(bc.db, shardID, blockNum, blockHash)
        if err != nil || len(cxs) == 0 </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cxs, nil</span>
}

// CXMerkleProof calculates the cross shard transaction merkle proof of a given destination shard
func (bc *BlockChain) CXMerkleProof(toShardID uint32, block *types.Block) (*types.CXMerkleProof, error) <span class="cov0" title="0">{
        proof := &amp;types.CXMerkleProof{BlockNum: block.Number(), BlockHash: block.Hash(), ShardID: block.ShardID(), CXReceiptHash: block.Header().OutgoingReceiptHash(), CXShardHashes: []common.Hash{}, ShardIDs: []uint32{}}

        epoch := block.Header().Epoch()
        shardingConfig := shard.Schedule.InstanceForEpoch(epoch)
        shardNum := int(shardingConfig.NumShards())

        for i := 0; i &lt; shardNum; i++ </span><span class="cov0" title="0">{
                receipts, err := bc.ReadCXReceipts(uint32(i), block.NumberU64(), block.Hash())
                if err != nil || len(receipts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        hash := types.DeriveSha(receipts)
                        proof.CXShardHashes = append(proof.CXShardHashes, hash)
                        proof.ShardIDs = append(proof.ShardIDs, uint32(i))
                }</span>
        }
        <span class="cov0" title="0">if len(proof.ShardIDs) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return proof, nil</span>
}

// WriteCXReceiptsProofSpent mark the CXReceiptsProof list with given unspent status
// true: unspent, false: spent
func (bc *BlockChain) WriteCXReceiptsProofSpent(db rawdb.DatabaseWriter, cxps []*types.CXReceiptsProof) error <span class="cov8" title="1">{
        for _, cxp := range cxps </span><span class="cov0" title="0">{
                if err := rawdb.WriteCXReceiptsProofSpent(db, cxp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// IsSpent checks whether a CXReceiptsProof is unspent
func (bc *BlockChain) IsSpent(cxp *types.CXReceiptsProof) bool <span class="cov0" title="0">{
        shardID := cxp.MerkleProof.ShardID
        blockNum := cxp.MerkleProof.BlockNum.Uint64()
        by, _ := rawdb.ReadCXReceiptsProofSpent(bc.db, shardID, blockNum)
        return by == rawdb.SpentByte
}</span>

// ReadTxLookupEntry returns where the given transaction resides in the chain,
// as a (block hash, block number, index in transaction list) triple.
// returns 0, 0 if not found
func (bc *BlockChain) ReadTxLookupEntry(txID common.Hash) (common.Hash, uint64, uint64) <span class="cov0" title="0">{
        return rawdb.ReadTxLookupEntry(bc.db, txID)
}</span>

// ReadValidatorInformationAtRoot reads staking
// information of given validatorWrapper at a specific state root
func (bc *BlockChain) ReadValidatorInformationAtRoot(
        addr common.Address, root common.Hash,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        state, err := bc.StateAt(root)
        if err != nil || state == nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "at root: %s", root.Hex())
        }</span>
        <span class="cov0" title="0">return bc.ReadValidatorInformationAtState(addr, state)</span>
}

// ReadValidatorInformationAtState reads staking
// information of given validatorWrapper at a specific state root
func (bc *BlockChain) ReadValidatorInformationAtState(
        addr common.Address, state *state.DB,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        if state == nil </span><span class="cov0" title="0">{
                return nil, errors.New("empty state")
        }</span>
        <span class="cov0" title="0">wrapper, err := state.ValidatorWrapper(addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return wrapper, nil</span>
}

// ReadValidatorInformation reads staking information of given validator address
func (bc *BlockChain) ReadValidatorInformation(
        addr common.Address,
) (*staking.ValidatorWrapper, error) <span class="cov0" title="0">{
        return bc.ReadValidatorInformationAtRoot(addr, bc.CurrentBlock().Root())
}</span>

// ReadValidatorSnapshotAtEpoch reads the snapshot
// staking validator information of given validator address
func (bc *BlockChain) ReadValidatorSnapshotAtEpoch(
        epoch *big.Int,
        addr common.Address,
) (*staking.ValidatorSnapshot, error) <span class="cov0" title="0">{
        return rawdb.ReadValidatorSnapshot(bc.db, addr, epoch)
}</span>

// ReadValidatorSnapshot reads the snapshot staking information of given validator address
func (bc *BlockChain) ReadValidatorSnapshot(
        addr common.Address,
) (*staking.ValidatorSnapshot, error) <span class="cov8" title="1">{
        epoch := bc.CurrentBlock().Epoch()
        key := addr.Hex() + epoch.String()
        if cached, ok := bc.validatorSnapshotCache.Get(key); ok </span><span class="cov8" title="1">{
                return cached.(*staking.ValidatorSnapshot), nil
        }</span>
        <span class="cov0" title="0">vs, err := rawdb.ReadValidatorSnapshot(bc.db, addr, epoch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bc.validatorSnapshotCache.Add(key, vs)
        return vs, nil</span>
}

// WriteValidatorSnapshot writes the snapshot of provided validator
func (bc *BlockChain) WriteValidatorSnapshot(
        batch rawdb.DatabaseWriter, snapshot *staking.ValidatorSnapshot,
) error <span class="cov8" title="1">{
        // Batch write the current data as snapshot
        if err := rawdb.WriteValidatorSnapshot(batch, snapshot.Validator, snapshot.Epoch); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update cache
        <span class="cov8" title="1">key := snapshot.Validator.Address.Hex() + snapshot.Epoch.String()
        bc.validatorSnapshotCache.Add(key, snapshot)
        return nil</span>
}

// ReadValidatorStats reads the stats of a validator
func (bc *BlockChain) ReadValidatorStats(
        addr common.Address,
) (*staking.ValidatorStats, error) <span class="cov0" title="0">{
        return rawdb.ReadValidatorStats(bc.db, addr)
}</span>

// UpdateValidatorVotingPower writes the voting power for the committees
func (bc *BlockChain) UpdateValidatorVotingPower(
        batch rawdb.DatabaseWriter,
        block *types.Block,
        newEpochSuperCommittee, currentEpochSuperCommittee *shard.State,
        state *state.DB,
) (map[common.Address]*staking.ValidatorStats, error) <span class="cov0" title="0">{
        if newEpochSuperCommittee == nil </span><span class="cov0" title="0">{
                return nil, shard.ErrSuperCommitteeNil
        }</span>

        <span class="cov0" title="0">validatorStats := map[common.Address]*staking.ValidatorStats{}

        existing, replacing :=
                currentEpochSuperCommittee.StakedValidators(),
                newEpochSuperCommittee.StakedValidators()

        // TODO could also keep track of the BLS keys which
        // lost a slot because just losing slots doesn't mean that the
        // validator was booted, just that some of their keys lost slots
        for currentValidator := range existing.LookupSet </span><span class="cov0" title="0">{
                if _, keptSlot := replacing.LookupSet[currentValidator]; !keptSlot </span><span class="cov0" title="0">{
                        // NOTE Think carefully about when time comes to delete offchain things
                        // TODO Someone: collect and then delete every 30 epochs
                        // rawdb.DeleteValidatorSnapshot(
                        //         bc.db, currentValidator, currentEpochSuperCommittee.Epoch,
                        // )
                        // rawdb.DeleteValidatorStats(bc.db, currentValidator)
                        stats, err := rawdb.ReadValidatorStats(bc.db, currentValidator)
                        if err != nil </span><span class="cov0" title="0">{
                                stats = staking.NewEmptyStats()
                        }</span>
                        // This means it's already in staking epoch
                        <span class="cov0" title="0">if currentEpochSuperCommittee.Epoch != nil </span><span class="cov0" title="0">{
                                wrapper, err := state.ValidatorWrapper(currentValidator)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">if slash.IsBanned(wrapper) </span><span class="cov0" title="0">{
                                        stats.BootedStatus = effective.BannedForDoubleSigning
                                }</span> else<span class="cov0" title="0"> if wrapper.Status == effective.Inactive </span><span class="cov0" title="0">{
                                        stats.BootedStatus = effective.TurnedInactiveOrInsufficientUptime
                                }</span> else<span class="cov0" title="0"> {
                                        stats.BootedStatus = effective.LostEPoSAuction
                                }</span>

                                // compute APR for the exiting validators
                                <span class="cov0" title="0">if err := bc.ComputeAndUpdateAPR(
                                        block, currentEpochSuperCommittee.Epoch, wrapper, stats,
                                ); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">validatorStats[currentValidator] = stats</span>
                }
        }

        <span class="cov0" title="0">rosters := make([]*votepower.Roster, len(newEpochSuperCommittee.Shards))
        for i := range newEpochSuperCommittee.Shards </span><span class="cov0" title="0">{
                subCommittee := &amp;newEpochSuperCommittee.Shards[i]
                if newEpochSuperCommittee.Epoch == nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(
                                errNilEpoch,
                                "block epoch %v current-committee-epoch %v",
                                block.Epoch(),
                                currentEpochSuperCommittee.Epoch,
                        )
                }</span>
                <span class="cov0" title="0">roster, err := votepower.Compute(subCommittee, newEpochSuperCommittee.Epoch)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rosters[i] = roster</span>
        }

        <span class="cov0" title="0">networkWide := votepower.AggregateRosters(rosters)
        for key, value := range networkWide </span><span class="cov0" title="0">{
                stats, err := rawdb.ReadValidatorStats(bc.db, key)
                if err != nil </span><span class="cov0" title="0">{
                        stats = staking.NewEmptyStats()
                }</span>
                <span class="cov0" title="0">total := numeric.ZeroDec()
                for i := range value </span><span class="cov0" title="0">{
                        total = total.Add(value[i].EffectiveStake)
                }</span>
                <span class="cov0" title="0">stats.TotalEffectiveStake = total
                earningWrapping := make([]staking.VoteWithCurrentEpochEarning, len(value))
                for i := range value </span><span class="cov0" title="0">{
                        earningWrapping[i] = staking.VoteWithCurrentEpochEarning{
                                Vote:   value[i],
                                Earned: big.NewInt(0),
                        }
                }</span>
                <span class="cov0" title="0">stats.MetricsPerShard = earningWrapping

                // fetch raw-stake from snapshot and update per-key metrics
                if snapshot, err := bc.ReadValidatorSnapshotAtEpoch(
                        newEpochSuperCommittee.Epoch, key,
                ); err == nil </span><span class="cov0" title="0">{
                        wrapper := snapshot.Validator
                        spread := numeric.ZeroDec()
                        if len(wrapper.SlotPubKeys) &gt; 0 </span><span class="cov0" title="0">{
                                spread = numeric.NewDecFromBigInt(wrapper.TotalDelegation()).
                                        QuoInt64(int64(len(wrapper.SlotPubKeys)))
                        }</span>
                        <span class="cov0" title="0">for i := range stats.MetricsPerShard </span><span class="cov0" title="0">{
                                stats.MetricsPerShard[i].Vote.RawStake = spread
                        }</span>
                }

                // This means it's already in staking epoch, and
                // compute APR for validators in current committee only
                <span class="cov0" title="0">if currentEpochSuperCommittee.Epoch != nil </span><span class="cov0" title="0">{
                        if _, ok := existing.LookupSet[key]; ok </span><span class="cov0" title="0">{
                                wrapper, err := state.ValidatorWrapper(key)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">if err := bc.ComputeAndUpdateAPR(
                                        block, currentEpochSuperCommittee.Epoch, wrapper, stats,
                                ); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                }
                <span class="cov0" title="0">validatorStats[key] = stats</span>
        }

        <span class="cov0" title="0">return validatorStats, nil</span>
}

// ComputeAndUpdateAPR ...
func (bc *BlockChain) ComputeAndUpdateAPR(
        block *types.Block, now *big.Int,
        wrapper *staking.ValidatorWrapper, stats *staking.ValidatorStats,
) error <span class="cov0" title="0">{
        if aprComputed, err := apr.ComputeForValidator(
                bc, block, wrapper,
        ); err != nil </span><span class="cov0" title="0">{
                if errors.Cause(err) == apr.ErrInsufficientEpoch </span><span class="cov0" title="0">{
                        utils.Logger().Info().Err(err).Msg("apr could not be computed")
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // only insert if APR for current epoch does not exists
                aprEntry := staking.APREntry{now, *aprComputed}
                l := len(stats.APRs)
                // first time inserting apr for validator or
                // apr for current epoch does not exists
                // check the last entry's epoch, if not same, insert
                if l == 0 || stats.APRs[l-1].Epoch.Cmp(now) != 0 </span><span class="cov0" title="0">{
                        stats.APRs = append(stats.APRs, aprEntry)
                }</span>
                // if history is more than staking.APRHistoryLength, pop front
                <span class="cov0" title="0">if l &gt; staking.APRHistoryLength </span><span class="cov0" title="0">{
                        stats.APRs = stats.APRs[1:]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// UpdateValidatorSnapshots updates the content snapshot of all validators
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateValidatorSnapshots(
        batch rawdb.DatabaseWriter, epoch *big.Int, state *state.DB, newValidators []common.Address,
) error <span class="cov0" title="0">{
        // Note this is reading the validator list from last block.
        // It's fine since the new validators from this block is already snapshot when created.
        allValidators, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allValidators = append(allValidators, newValidators...)

        // Read all validator's current data and snapshot them
        for i := range allValidators </span><span class="cov0" title="0">{
                // The snapshot will be captured in the state after the last epoch block is finalized
                validator, err := state.ValidatorWrapper(allValidators[i])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">snapshot := &amp;staking.ValidatorSnapshot{validator, epoch}
                if err := bc.WriteValidatorSnapshot(batch, snapshot); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ReadValidatorList reads the addresses of current all validators
func (bc *BlockChain) ReadValidatorList() ([]common.Address, error) <span class="cov8" title="1">{
        if cached, ok := bc.validatorListCache.Get("validatorList"); ok </span><span class="cov0" title="0">{
                by := cached.([]byte)
                m := []common.Address{}
                if err := rlp.DecodeBytes(by, &amp;m); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        }
        <span class="cov8" title="1">return rawdb.ReadValidatorList(bc.db)</span>
}

// WriteValidatorList writes the list of validator addresses to database
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) WriteValidatorList(
        db rawdb.DatabaseWriter, addrs []common.Address,
) error <span class="cov0" title="0">{
        if err := rawdb.WriteValidatorList(db, addrs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bytes, err := rlp.EncodeToBytes(addrs)
        if err == nil </span><span class="cov0" title="0">{
                bc.validatorListCache.Add("validatorList", bytes)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadDelegationsByDelegator reads the addresses of validators delegated by a delegator
func (bc *BlockChain) ReadDelegationsByDelegator(
        delegator common.Address,
) (m staking.DelegationIndexes, err error) <span class="cov8" title="1">{
        rawResult := staking.DelegationIndexes{}
        if cached, ok := bc.validatorListByDelegatorCache.Get(string(delegator.Bytes())); ok </span><span class="cov8" title="1">{
                by := cached.([]byte)
                if err := rlp.DecodeBytes(by, &amp;rawResult); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                if rawResult, err = rawdb.ReadDelegationsByDelegator(bc.db, delegator); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">blockNum := bc.CurrentBlock().Number()
        for _, index := range rawResult </span><span class="cov8" title="1">{
                if index.BlockNum.Cmp(blockNum) &lt;= 0 </span><span class="cov8" title="1">{
                        m = append(m, index)
                }</span> else<span class="cov0" title="0"> {
                        // Filter out index that's created beyond current height of chain.
                        // This only happens when there is a chain rollback.
                        utils.Logger().Warn().Msgf("Future delegation index encountered. Skip: %+v", index)
                }</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

// ReadDelegationsByDelegatorAt reads the addresses of validators delegated by a delegator at a given block
func (bc *BlockChain) ReadDelegationsByDelegatorAt(
        delegator common.Address, blockNum *big.Int,
) (m staking.DelegationIndexes, err error) <span class="cov0" title="0">{
        rawResult := staking.DelegationIndexes{}
        if cached, ok := bc.validatorListByDelegatorCache.Get(string(delegator.Bytes())); ok </span><span class="cov0" title="0">{
                by := cached.([]byte)
                if err := rlp.DecodeBytes(by, &amp;rawResult); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                if rawResult, err = rawdb.ReadDelegationsByDelegator(bc.db, delegator); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">for _, index := range rawResult </span><span class="cov0" title="0">{
                if index.BlockNum.Cmp(blockNum) &lt;= 0 </span><span class="cov0" title="0">{
                        m = append(m, index)
                }</span> else<span class="cov0" title="0"> {
                        // Filter out index that's created beyond current height of chain.
                        // This only happens when there is a chain rollback.
                        utils.Logger().Warn().Msgf("Future delegation index encountered. Skip: %+v", index)
                }</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

// writeDelegationsByDelegator writes the list of validator addresses to database
func (bc *BlockChain) writeDelegationsByDelegator(
        batch rawdb.DatabaseWriter,
        delegator common.Address,
        indices []staking.DelegationIndex,
) error <span class="cov8" title="1">{
        if err := rawdb.WriteDelegationsByDelegator(
                batch, delegator, indices,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">bytes, err := rlp.EncodeToBytes(indices)
        if err == nil </span><span class="cov8" title="1">{
                bc.validatorListByDelegatorCache.Add(string(delegator.Bytes()), bytes)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateStakingMetaData updates the metadata of validators and delegations,
// including the full validator list and delegation indexes.
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateStakingMetaData(
        batch rawdb.DatabaseWriter, block *types.Block,
        state *state.DB, epoch, newEpoch *big.Int,
) (newValidators []common.Address, err error) <span class="cov8" title="1">{
        newValidators, newDelegations, err := bc.prepareStakingMetaData(block, state)
        if err != nil </span><span class="cov0" title="0">{
                utils.Logger().Warn().Msgf("oops, prepareStakingMetaData failed, err: %+v", err)
                return newValidators, err
        }</span>

        <span class="cov8" title="1">if len(newValidators) &gt; 0 </span><span class="cov0" title="0">{
                list, err := bc.ReadValidatorList()
                if err != nil </span><span class="cov0" title="0">{
                        return newValidators, err
                }</span>

                <span class="cov0" title="0">valMap := map[common.Address]struct{}{}
                for _, addr := range list </span><span class="cov0" title="0">{
                        valMap[addr] = struct{}{}
                }</span>

                <span class="cov0" title="0">newAddrs := []common.Address{}
                for _, addr := range newValidators </span><span class="cov0" title="0">{
                        if _, ok := valMap[addr]; !ok </span><span class="cov0" title="0">{
                                newAddrs = append(newAddrs, addr)
                        }</span>

                        // Update validator snapshot for the new validator
                        <span class="cov0" title="0">validator, err := state.ValidatorWrapper(addr)
                        if err != nil </span><span class="cov0" title="0">{
                                return newValidators, err
                        }</span>

                        <span class="cov0" title="0">if err := bc.WriteValidatorSnapshot(batch, &amp;staking.ValidatorSnapshot{validator, epoch}); err != nil </span><span class="cov0" title="0">{
                                return newValidators, err
                        }</span>
                        // For validator created at exactly the last block of an epoch, we should create the snapshot
                        // for next epoch too.
                        <span class="cov0" title="0">if newEpoch.Cmp(epoch) &gt; 0 </span><span class="cov0" title="0">{
                                if err := bc.WriteValidatorSnapshot(batch, &amp;staking.ValidatorSnapshot{validator, newEpoch}); err != nil </span><span class="cov0" title="0">{
                                        return newValidators, err
                                }</span>
                        }
                }

                // Update validator list
                <span class="cov0" title="0">list = append(list, newAddrs...)
                if err = bc.WriteValidatorList(batch, list); err != nil </span><span class="cov0" title="0">{
                        return newValidators, err
                }</span>
        }

        <span class="cov8" title="1">for addr, delegations := range newDelegations </span><span class="cov0" title="0">{
                if err := bc.writeDelegationsByDelegator(batch, addr, delegations); err != nil </span><span class="cov0" title="0">{
                        return newValidators, err
                }</span>
        }
        <span class="cov8" title="1">return newValidators, nil</span>
}

// prepareStakingMetaData prepare the updates of validator's
// and the delegator's meta data according to staking transaction.
// The following return values are cached end state to be written to DB.
// The reason for the cached state is to solve the issue that batch DB changes
// won't be reflected immediately so the intermediary state can't be read from DB.
// newValidators - the addresses of the newly created validators
// newDelegations - the map of delegator address and their updated delegation indexes
func (bc *BlockChain) prepareStakingMetaData(
        block *types.Block, state *state.DB,
) ([]common.Address,
        map[common.Address]staking.DelegationIndexes,
        error,
) <span class="cov8" title="1">{
        var newValidators []common.Address
        newDelegations := map[common.Address]staking.DelegationIndexes{}
        blockNum := block.Number()
        txHashToStakeMsgs := GetTxHashToStakeMsgs()
        for _, txn := range block.Transactions() </span><span class="cov8" title="1">{
                if stakeMsgs, ok := txHashToStakeMsgs[txn.Hash().Hex()]; ok </span><span class="cov8" title="1">{
                        for _, stakeMsg := range stakeMsgs </span><span class="cov8" title="1">{
                                if createValidator, ok := stakeMsg.(*staking.CreateValidator); ok </span><span class="cov8" title="1">{
                                        if err := processCreateValidatorMetadata(createValidator,
                                                &amp;newValidators,
                                                newDelegations,
                                                bc,
                                                blockNum); err != nil </span><span class="cov0" title="0">{
                                                        return nil, nil, err
                                                }</span>
                                } else<span class="cov8" title="1"> if delegate, ok := stakeMsg.(*staking.Delegate); ok </span><span class="cov8" title="1">{
                                        if err := processDelegateMetadata(delegate,
                                                newValidators,
                                                newDelegations,
                                                state,
                                                bc,
                                                blockNum); err != nil </span><span class="cov0" title="0">{
                                                        return nil, nil, err
                                                }</span>
                                }
                        }
                        // delete the temporary entry later
                        <span class="cov8" title="1">delete(txHashToStakeMsgs, txn.Hash().Hex())</span>
                }
        }
        <span class="cov8" title="1">for _, txn := range block.StakingTransactions() </span><span class="cov8" title="1">{
                payload, err := txn.RLPEncodeStakeMsg()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">decodePayload, err := staking.RLPDecodeStakeMsg(payload, txn.StakingType())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">switch txn.StakingType() </span>{
                        case staking.DirectiveCreateValidator:<span class="cov8" title="1">
                                createValidator := decodePayload.(*staking.CreateValidator)
                                if err := processCreateValidatorMetadata(createValidator,
                                        &amp;newValidators,
                                        newDelegations,
                                        bc,
                                        blockNum); err != nil </span><span class="cov0" title="0">{
                                                return nil, nil, err
                                        }</span>
                        case staking.DirectiveEditValidator:<span class="cov0" title="0"></span>
                        case staking.DirectiveDelegate:<span class="cov8" title="1">
                                delegate := decodePayload.(*staking.Delegate)
                                if err := processDelegateMetadata(delegate,
                                        newValidators,
                                        newDelegations,
                                        state,
                                        bc,
                                        blockNum); err != nil </span><span class="cov0" title="0">{
                                                return nil, nil, err
                                        }</span>

                        case staking.DirectiveUndelegate:<span class="cov0" title="0"></span>
                        case staking.DirectiveCollectRewards:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov8" title="1">return newValidators, newDelegations, nil</span>
}

func processCreateValidatorMetadata(createValidator *staking.CreateValidator,
        newValidators *[]common.Address,
        newDelegations map[common.Address]staking.DelegationIndexes,
        bc *BlockChain, blockNum *big.Int,
) (err error) <span class="cov8" title="1">{
        newList, appended := utils.AppendIfMissing(
                *newValidators, createValidator.ValidatorAddress,
        )
        if !appended </span><span class="cov0" title="0">{
                return errValidatorExist
        }</span>
        <span class="cov8" title="1">*newValidators = newList

        // Add self delegation into the index
        selfIndex := staking.DelegationIndex{
                createValidator.ValidatorAddress,
                uint64(0),
                blockNum,
        }
        delegations, ok := newDelegations[createValidator.ValidatorAddress]
        if !ok </span><span class="cov8" title="1">{
                // If the cache doesn't have it, load it from DB for the first time.
                delegations, err = bc.ReadDelegationsByDelegator(createValidator.ValidatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">delegations = append(delegations, selfIndex)
        newDelegations[createValidator.ValidatorAddress] = delegations
        return nil</span>
}

func processDelegateMetadata(delegate *staking.Delegate,
        newValidators []common.Address,
        newDelegations map[common.Address]staking.DelegationIndexes,
        state *state.DB, bc *BlockChain, blockNum *big.Int,
) (err error) <span class="cov8" title="1">{
        delegations, ok := newDelegations[delegate.DelegatorAddress]
        if !ok </span><span class="cov0" title="0">{
                // If the cache doesn't have it, load it from DB for the first time.
                delegations, err = bc.ReadDelegationsByDelegator(delegate.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if delegations, err = bc.addDelegationIndex(
                delegations, delegate.DelegatorAddress, delegate.ValidatorAddress, state, blockNum,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">newDelegations[delegate.DelegatorAddress] = delegations
        return nil</span>
}

// ReadBlockRewardAccumulator must only be called on beaconchain
// Note that block rewards are only for staking era.
func (bc *BlockChain) ReadBlockRewardAccumulator(number uint64) (*big.Int, error) <span class="cov0" title="0">{
        if !bc.chainConfig.IsStaking(shard.Schedule.CalcEpochNumber(number)) </span><span class="cov0" title="0">{
                return big.NewInt(0), nil
        }</span>
        <span class="cov0" title="0">if cached, ok := bc.blockAccumulatorCache.Get(number); ok </span><span class="cov0" title="0">{
                return cached.(*big.Int), nil
        }</span>
        <span class="cov0" title="0">return rawdb.ReadBlockRewardAccumulator(bc.db, number)</span>
}

// WriteBlockRewardAccumulator directly writes the BlockRewardAccumulator value
// Note: this should only be called once during staking launch.
func (bc *BlockChain) WriteBlockRewardAccumulator(
        batch rawdb.DatabaseWriter, reward *big.Int, number uint64,
) error <span class="cov8" title="1">{
        if err := rawdb.WriteBlockRewardAccumulator(
                batch, reward, number,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">bc.blockAccumulatorCache.Add(number, reward)
        return nil</span>
}

// UpdateBlockRewardAccumulator ..
// Note: this should only be called within the blockchain insert process.
func (bc *BlockChain) UpdateBlockRewardAccumulator(
        batch rawdb.DatabaseWriter, diff *big.Int, number uint64,
) error <span class="cov0" title="0">{
        current, err := bc.ReadBlockRewardAccumulator(number - 1)
        if err != nil </span><span class="cov0" title="0">{
                // one-off fix for pangaea, return after pangaea enter staking.
                current = big.NewInt(0)
                bc.WriteBlockRewardAccumulator(batch, current, number)
        }</span>
        <span class="cov0" title="0">return bc.WriteBlockRewardAccumulator(batch, new(big.Int).Add(current, diff), number)</span>
}

// Note this should read from the state of current block in concern (root == newBlock.root)
func (bc *BlockChain) addDelegationIndex(
        delegations staking.DelegationIndexes,
        delegatorAddress, validatorAddress common.Address, state *state.DB, blockNum *big.Int,
) (staking.DelegationIndexes, error) <span class="cov8" title="1">{
        // If there is an existing delegation, just return
        validatorAddressBytes := validatorAddress.Bytes()
        for _, delegation := range delegations </span><span class="cov8" title="1">{
                if bytes.Equal(delegation.ValidatorAddress[:], validatorAddressBytes[:]) </span><span class="cov8" title="1">{
                        return delegations, nil
                }</span>
        }

        // Found the delegation from state and add the delegation index
        // Note this should read from the state of current block in concern
        <span class="cov0" title="0">wrapper, err := state.ValidatorWrapper(validatorAddress)
        if err != nil </span><span class="cov0" title="0">{
                return delegations, err
        }</span>
        <span class="cov0" title="0">for i := range wrapper.Delegations </span><span class="cov0" title="0">{
                if bytes.Equal(
                        wrapper.Delegations[i].DelegatorAddress[:], delegatorAddress[:],
                ) </span><span class="cov0" title="0">{
                        // TODO(audit): change the way of indexing if we allow delegation deletion.
                        delegations = append(delegations, staking.DelegationIndex{
                                validatorAddress,
                                uint64(i),
                                blockNum,
                        })
                }</span>
        }
        <span class="cov0" title="0">return delegations, nil</span>
}

// ValidatorCandidates returns the up to date validator candidates for next epoch
func (bc *BlockChain) ValidatorCandidates() []common.Address <span class="cov0" title="0">{
        list, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov0" title="0">{
                return make([]common.Address, 0)
        }</span>
        <span class="cov0" title="0">return list</span>
}

// DelegatorsInformation returns up to date information of delegators of a given validator address
func (bc *BlockChain) DelegatorsInformation(addr common.Address) []*staking.Delegation <span class="cov0" title="0">{
        return make([]*staking.Delegation, 0)
}</span>

// GetECDSAFromCoinbase retrieve corresponding ecdsa address from Coinbase Address
// TODO: optimize this func by adding cache etc.
func (bc *BlockChain) GetECDSAFromCoinbase(header *block.Header) (common.Address, error) <span class="cov8" title="1">{
        // backward compatibility: before isStaking epoch, coinbase address is the ecdsa address
        coinbase := header.Coinbase()
        isStaking := bc.Config().IsStaking(header.Epoch())
        if !isStaking </span><span class="cov8" title="1">{
                return coinbase, nil
        }</span>

        <span class="cov0" title="0">shardState, err := bc.ReadShardState(header.Epoch())
        if err != nil </span><span class="cov0" title="0">{
                return common.Address{}, errors.Wrapf(
                        err, "cannot read shard state",
                )
        }</span>

        <span class="cov0" title="0">committee, err := shardState.FindCommitteeByID(header.ShardID())
        if err != nil </span><span class="cov0" title="0">{
                return common.Address{}, errors.Wrapf(
                        err, "cannot find shard in the shard state",
                )
        }</span>
        <span class="cov0" title="0">for _, member := range committee.Slots </span><span class="cov0" title="0">{
                // After staking the coinbase address will be the address of bls public key
                if bytes.Equal(member.EcdsaAddress[:], coinbase[:]) </span><span class="cov0" title="0">{
                        return member.EcdsaAddress, nil
                }</span>

                <span class="cov0" title="0">if utils.GetAddressFromBLSPubKeyBytes(member.BLSPublicKey[:]) == coinbase </span><span class="cov0" title="0">{
                        return member.EcdsaAddress, nil
                }</span>
        }
        <span class="cov0" title="0">return common.Address{}, errors.Errorf(
                "cannot find corresponding ECDSA Address for coinbase %s",
                header.Coinbase().Hash().Hex(),
        )</span>
}

// SuperCommitteeForNextEpoch ...
// isVerify=true means validators use it to verify
// isVerify=false means leader is to propose
func (bc *BlockChain) SuperCommitteeForNextEpoch(
        beacon consensus_engine.ChainReader,
        header *block.Header,
        isVerify bool,
) (*shard.State, error) <span class="cov0" title="0">{
        var (
                nextCommittee = new(shard.State)
                err           error
                beaconEpoch   = new(big.Int)
                shardState    = shard.State{}
        )
        switch header.ShardID() </span>{
        case shard.BeaconChainShardID:<span class="cov0" title="0">
                if shard.Schedule.IsLastBlock(header.Number().Uint64()) </span><span class="cov0" title="0">{
                        nextCommittee, err = committee.WithStakingEnabled.Compute(
                                new(big.Int).Add(header.Epoch(), common.Big1),
                                beacon,
                        )
                }</span>
        default:<span class="cov0" title="0">
                // TODO: needs to make sure beacon chain sync works.
                if isVerify </span><span class="cov0" title="0">{
                        //verify
                        shardState, err = header.GetShardState()
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;shard.State{}, err
                        }</span>
                        // before staking epoch
                        <span class="cov0" title="0">if shardState.Epoch == nil </span><span class="cov0" title="0">{
                                beaconEpoch = new(big.Int).Add(header.Epoch(), common.Big1)
                        }</span> else<span class="cov0" title="0"> { // after staking epoch
                                beaconEpoch = shardState.Epoch
                        }</span>
                } else<span class="cov0" title="0"> {
                        //propose
                        beaconEpoch = beacon.CurrentHeader().Epoch()
                }</span>
                <span class="cov0" title="0">utils.Logger().Debug().Msgf("[SuperCommitteeCalculation] isVerify: %+v, realBeaconEpoch:%+v, beaconEpoch: %+v, headerEpoch:%+v, shardStateEpoch:%+v",
                        isVerify, beacon.CurrentHeader().Epoch(), beaconEpoch, header.Epoch(), shardState.Epoch)
                nextEpoch := new(big.Int).Add(header.Epoch(), common.Big1)
                if bc.Config().IsStaking(nextEpoch) </span><span class="cov0" title="0">{
                        // If next epoch is staking epoch, I should wait and listen for beacon chain for epoch changes
                        switch beaconEpoch.Cmp(header.Epoch()) </span>{
                        case 1:<span class="cov0" title="0">
                                // If beacon chain is bigger than shard chain in epoch, it means I should catch up with beacon chain now
                                nextCommittee, err = committee.WithStakingEnabled.ReadFromDB(
                                        beaconEpoch, beacon,
                                )

                                utils.Logger().Debug().
                                        Uint64("blockNum", header.Number().Uint64()).
                                        Uint64("myCurEpoch", header.Epoch().Uint64()).
                                        Uint64("beaconEpoch", beaconEpoch.Uint64()).
                                        Msg("Propose new epoch as beacon chain's epoch")</span>
                        case 0:<span class="cov0" title="0"></span>
                                // If it's same epoch, no need to propose new shard state (new epoch change)
                        case -1:<span class="cov0" title="0"></span>
                                // If beacon chain is behind, shard chain should wait for the beacon chain by not changing epochs.
                        }
                } else<span class="cov0" title="0"> {
                        if bc.Config().IsStaking(beaconEpoch) </span><span class="cov0" title="0">{
                                // If I am not even in the last epoch before staking epoch and beacon chain is already in staking epoch,
                                // I should just catch up with beacon chain's epoch
                                nextCommittee, err = committee.WithStakingEnabled.ReadFromDB(
                                        beaconEpoch, beacon,
                                )

                                utils.Logger().Debug().
                                        Uint64("blockNum", header.Number().Uint64()).
                                        Uint64("myCurEpoch", header.Epoch().Uint64()).
                                        Uint64("beaconEpoch", beaconEpoch.Uint64()).
                                        Msg("Propose entering staking along with beacon chain's epoch")
                        }</span> else<span class="cov0" title="0"> {
                                // If I are not in staking nor has beacon chain proposed a staking-based shard state,
                                // do pre-staking committee calculation
                                if shard.Schedule.IsLastBlock(header.Number().Uint64()) </span><span class="cov0" title="0">{
                                        nextCommittee, err = committee.WithStakingEnabled.Compute(
                                                nextEpoch,
                                                bc,
                                        )
                                }</span>
                        }
                }

        }
        <span class="cov0" title="0">return nextCommittee, err</span>
}

var (
        leveldbErrSpec         = "leveldb"
        tooManyOpenFilesErrStr = "Too many open files"
)

// isUnrecoverableErr check whether the input error is not recoverable.
// When writing db, there could be some possible errors from storage level (leveldb).
// Known possible leveldb errors are:
//  1. Leveldb is already closed. (leveldb.ErrClosed)
//  2. ldb file missing from disk. (leveldb.ErrNotFound)
//  3. Corrupted db data. (leveldb.errors.ErrCorrupted)
//  4. OS error when open file (too many open files, ...)
//  5. OS error when write file (read-only, not enough disk space, ...)
// Among all the above leveldb errors, only `too many open files` error is known to be recoverable,
// thus the unrecoverable errors refers to error that is
//  1. The error is from the lower storage level (from module leveldb)
//  2. The error is not too many files error.
func isUnrecoverableErr(err error) bool <span class="cov0" title="0">{
        isLeveldbErr := strings.Contains(err.Error(), leveldbErrSpec)
        isTooManyOpenFiles := strings.Contains(err.Error(), tooManyOpenFilesErrStr)
        return isLeveldbErr &amp;&amp; !isTooManyOpenFiles
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "bytes"
        "sort"
        "errors"
        "math/big"

        "github.com/harmony-one/harmony/internal/params"
        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
        staking "github.com/harmony-one/harmony/staking"
)

// ChainContext supports retrieving headers and consensus parameters from the
// current blockchain to be used during transaction processing.
type ChainContext interface {
        // Engine retrieves the chain's consensus engine.
        Engine() consensus_engine.Engine

        // GetHeader returns the hash corresponding to their hash.
        GetHeader(common.Hash, uint64) *block.Header

        // ReadDelegationsByDelegator returns the validators list of a delegator
        ReadDelegationsByDelegator(common.Address) (stakingTypes.DelegationIndexes, error)

        // ReadValidatorSnapshot returns the snapshot of validator at the beginning of current epoch.
        ReadValidatorSnapshot(common.Address) (*stakingTypes.ValidatorSnapshot, error)

        // ReadValidatorList returns the list of all validators
        ReadValidatorList() ([]common.Address, error)

        // Config returns chain config
        Config() *params.ChainConfig

        ShardID() uint32        // this is implemented by blockchain.go already
}

// NewEVMContext creates a new context for use in the EVM.
func NewEVMContext(msg Message, header *block.Header, chain ChainContext, author *common.Address) vm.Context <span class="cov8" title="1">{
        // If we don't have an explicit author (i.e. not mining), extract from the header
        var beneficiary common.Address
        if author == nil </span><span class="cov8" title="1">{
                beneficiary = common.Address{} // Ignore error, we're past header validation
        }</span> else<span class="cov8" title="1"> {
                beneficiary = *author
        }</span>
        <span class="cov8" title="1">vrf := common.Hash{}
        if len(header.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                vrfAndProof := header.Vrf()
                copy(vrf[:], vrfAndProof[:32])
        }</span>
        <span class="cov8" title="1">return vm.Context{
                CanTransfer:                         CanTransfer,
                Transfer:                            Transfer,
                IsValidator:                         IsValidator,
                GetHash:                             GetHashFn(header, chain),
                GetVRF:                              GetVRFFn(header, chain),
                CreateValidator:         CreateValidatorFn(header, chain),
                EditValidator:                 EditValidatorFn(header, chain),
                Delegate:                                 DelegateFn(header, chain),
                Undelegate:                         UndelegateFn(header, chain),
                CollectRewards:         CollectRewardsFn(header, chain),
                Origin:                              msg.From(),
                Coinbase:                            beneficiary,
                BlockNumber:                         header.Number(),
                EpochNumber:                         header.Epoch(),
                VRF:                                 vrf,
                Time:                                header.Time(),
                GasLimit:                            header.GasLimit(),
                GasPrice:                            new(big.Int).Set(msg.GasPrice()),
                ShardID:                                        chain.ShardID(),
        }</span>
}

// HandleStakeMsgFn returns a function which accepts
// (1) the chain state database
// (2) the processed staking parameters
// the function can then be called through the EVM context
func CreateValidatorFn(ref *block.Header, chain ChainContext) vm.CreateValidatorFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, createValidator *stakingTypes.CreateValidator) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndCreateValidatorFromMsg(
                        db, chain, ref.Epoch(), ref.Number(), createValidator,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := db.UpdateValidatorWrapper(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">db.SetValidatorFlag(createValidator.ValidatorAddress)
                db.SubBalance(createValidator.ValidatorAddress, createValidator.Amount)
                return nil</span>
        }
}

func EditValidatorFn(ref *block.Header, chain ChainContext) vm.EditValidatorFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, editValidator *stakingTypes.EditValidator) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndEditValidatorFromMsg(
                        db, chain, ref.Epoch(), ref.Number(), editValidator,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return db.UpdateValidatorWrapper(wrapper.Address, wrapper)</span>
        }
}

func DelegateFn(ref *block.Header, chain ChainContext) vm.DelegateFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, delegate *stakingTypes.Delegate) error </span><span class="cov8" title="1">{
                delegations, err := chain.ReadDelegationsByDelegator(delegate.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers, balanceToBeDeducted, fromLockedTokens, err := VerifyAndDelegateFromMsg(
                        db, ref.Epoch(), delegate, delegations, chain.Config())
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, wrapper := range updatedValidatorWrappers </span><span class="cov8" title="1">{
                        if err := db.UpdateValidatorWrapper(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">db.SubBalance(delegate.DelegatorAddress, balanceToBeDeducted)

                if len(fromLockedTokens) &gt; 0 </span><span class="cov8" title="1">{
                        sortedKeys := []common.Address{}
                        for key := range fromLockedTokens </span><span class="cov8" title="1">{
                                sortedKeys = append(sortedKeys, key)
                        }</span>
                        <span class="cov8" title="1">sort.SliceStable(sortedKeys, func(i, j int) bool </span><span class="cov0" title="0">{
                                return bytes.Compare(sortedKeys[i][:], sortedKeys[j][:]) &lt; 0
                        }</span>)
                        // Add log if everything is good
                        <span class="cov8" title="1">for _, key := range sortedKeys </span><span class="cov8" title="1">{
                                redelegatedToken, ok := fromLockedTokens[key]
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.New("Key missing for delegation receipt")
                                }</span>
                                <span class="cov8" title="1">encodedRedelegationData := []byte{}
                                addrBytes := key.Bytes()
                                encodedRedelegationData = append(encodedRedelegationData, addrBytes...)
                                encodedRedelegationData = append(encodedRedelegationData, redelegatedToken.Bytes()...)
                                // The data field format is:
                                // [first 20 bytes]: Validator address from which the locked token is used for redelegation.
                                // [rest of the bytes]: the bigInt serialized bytes for the token amount.
                                db.AddLog(&amp;types.Log{
                                        Address:     delegate.DelegatorAddress,
                                        Topics:      []common.Hash{staking.DelegateTopic},
                                        Data:        encodedRedelegationData,
                                        BlockNumber: ref.Number().Uint64(),
                                })</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }
}

func UndelegateFn(ref *block.Header, chain ChainContext) vm.UndelegateFunc <span class="cov8" title="1">{
        // moved from state_transition.go to here, with some modifications
        return func(db vm.StateDB, undelegate *stakingTypes.Undelegate) error </span><span class="cov8" title="1">{
                wrapper, err := VerifyAndUndelegateFromMsg(db, ref.Epoch(), undelegate)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return db.UpdateValidatorWrapper(wrapper.Address, wrapper)</span>
        }
}

func CollectRewardsFn(ref *block.Header, chain ChainContext) vm.CollectRewardsFunc <span class="cov8" title="1">{
        return func(db vm.StateDB, collectRewards *stakingTypes.CollectRewards) error </span><span class="cov8" title="1">{
                if chain == nil </span><span class="cov0" title="0">{
                        return errors.New("[CollectRewards] No chain context provided")
                }</span>
                <span class="cov8" title="1">delegations, err := chain.ReadDelegationsByDelegator(collectRewards.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers, totalRewards, err := VerifyAndCollectRewardsFromDelegation(
                        db, delegations,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, wrapper := range updatedValidatorWrappers </span><span class="cov8" title="1">{
                        if err := db.UpdateValidatorWrapper(wrapper.Address, wrapper); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">db.AddBalance(collectRewards.DelegatorAddress, totalRewards)

                // Add log if everything is good
                db.AddLog(&amp;types.Log{
                        Address:     collectRewards.DelegatorAddress,
                        Topics:      []common.Hash{staking.CollectRewardsTopic},
                        Data:        totalRewards.Bytes(),
                        BlockNumber: ref.Number().Uint64(),
                })

                return nil</span>
        }
}

// GetHashFn returns a GetHashFunc which retrieves header hashes by number
func GetHashFn(ref *block.Header, chain ChainContext) func(n uint64) common.Hash <span class="cov8" title="1">{
        var cache map[uint64]common.Hash

        return func(n uint64) common.Hash </span><span class="cov0" title="0">{
                // If there's no hash cache yet, make one
                if cache == nil </span><span class="cov0" title="0">{
                        cache = map[uint64]common.Hash{
                                ref.Number().Uint64() - 1: ref.ParentHash(),
                        }
                }</span>
                // Try to fulfill the request from the cache
                <span class="cov0" title="0">if hash, ok := cache[n]; ok </span><span class="cov0" title="0">{
                        return hash
                }</span>
                // Not cached, iterate the blocks and cache the hashes
                <span class="cov0" title="0">for header := chain.GetHeader(ref.ParentHash(), ref.Number().Uint64()-1); header != nil; header = chain.GetHeader(header.ParentHash(), header.Number().Uint64()-1) </span><span class="cov0" title="0">{
                        cache[header.Number().Uint64()-1] = header.ParentHash()
                        if n == header.Number().Uint64()-1 </span><span class="cov0" title="0">{
                                return header.ParentHash()
                        }</span>
                }
                <span class="cov0" title="0">return common.Hash{}</span>
        }
}

// GetVRFFn returns a GetVRFFn which retrieves header vrf by number
func GetVRFFn(ref *block.Header, chain ChainContext) func(n uint64) common.Hash <span class="cov8" title="1">{
        var cache map[uint64]common.Hash

        return func(n uint64) common.Hash </span><span class="cov0" title="0">{
                // If there's no hash cache yet, make one
                if cache == nil </span><span class="cov0" title="0">{
                        curVRF := common.Hash{}
                        if len(ref.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                                vrfAndProof := ref.Vrf()
                                copy(curVRF[:], vrfAndProof[:32])
                        }</span>

                        <span class="cov0" title="0">cache = map[uint64]common.Hash{
                                ref.Number().Uint64(): curVRF,
                        }</span>
                }
                // Try to fulfill the request from the cache
                <span class="cov0" title="0">if hash, ok := cache[n]; ok </span><span class="cov0" title="0">{
                        return hash
                }</span>
                // Not cached, iterate the blocks and cache the hashes
                <span class="cov0" title="0">for header := chain.GetHeader(ref.ParentHash(), ref.Number().Uint64()-1); header != nil; header = chain.GetHeader(header.ParentHash(), header.Number().Uint64()-1) </span><span class="cov0" title="0">{

                        curVRF := common.Hash{}
                        if len(header.Vrf()) &gt;= 32 </span><span class="cov0" title="0">{
                                vrfAndProof := header.Vrf()
                                copy(curVRF[:], vrfAndProof[:32])
                        }</span>

                        <span class="cov0" title="0">cache[header.Number().Uint64()] = curVRF

                        if n == header.Number().Uint64() </span><span class="cov0" title="0">{
                                return curVRF
                        }</span>
                }
                <span class="cov0" title="0">return common.Hash{}</span>
        }
}

// CanTransfer checks whether there are enough funds in the address' account to make a transfer.
// This does not take the necessary gas in to account to make the transfer valid.
func CanTransfer(db vm.StateDB, addr common.Address, amount *big.Int) bool <span class="cov8" title="1">{
        return db.GetBalance(addr).Cmp(amount) &gt;= 0
}</span>

// IsValidator determines whether it is a validator address or not
func IsValidator(db vm.StateDB, addr common.Address) bool <span class="cov8" title="1">{
        return db.IsValidator(addr)
}</span>

// Transfer subtracts amount from sender and adds amount to recipient using the given Db
func Transfer(db vm.StateDB, sender, recipient common.Address, amount *big.Int, txType types.TransactionType) <span class="cov8" title="1">{
        if txType == types.SameShardTx || txType == types.SubtractionOnly </span><span class="cov8" title="1">{
                db.SubBalance(sender, amount)
        }</span>
        <span class="cov8" title="1">if txType == types.SameShardTx </span><span class="cov8" title="1">{
                db.AddBalance(recipient, amount)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "bytes"
        "math/big"
        "github.com/harmony-one/harmony/staking/availability"

        "github.com/harmony-one/harmony/internal/params"

        "github.com/harmony-one/harmony/crypto/bls"

        "github.com/ethereum/go-ethereum/common"
        "github.com/harmony-one/harmony/common/denominations"
        "github.com/harmony-one/harmony/core/vm"
        common2 "github.com/harmony-one/harmony/internal/common"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/staking/effective"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var (
        errStateDBIsMissing    = errors.New("no stateDB was provided")
        errChainContextMissing = errors.New("no chain context was provided")
        errEpochMissing        = errors.New("no epoch was provided")
        errBlockNumMissing     = errors.New("no block number was provided")
)

func checkDuplicateFields(
        bc ChainContext, state vm.StateDB,
        validator common.Address, identity string, blsKeys []bls.SerializedPublicKey,
) error <span class="cov8" title="1">{
        addrs, err := bc.ReadValidatorList()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">checkIdentity := identity != ""
        checkBlsKeys := len(blsKeys) != 0

        blsKeyMap := map[bls.SerializedPublicKey]struct{}{}
        for _, key := range blsKeys </span><span class="cov8" title="1">{
                blsKeyMap[key] = struct{}{}
        }</span>

        <span class="cov8" title="1">for _, addr := range addrs </span><span class="cov8" title="1">{
                if !bytes.Equal(validator.Bytes(), addr.Bytes()) </span><span class="cov8" title="1">{
                        wrapper, err := state.ValidatorWrapperCopy(addr)

                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if checkIdentity &amp;&amp; wrapper.Identity == identity </span><span class="cov8" title="1">{
                                return errors.Wrapf(errDupIdentity, "duplicate identity %s", identity)
                        }</span>
                        <span class="cov8" title="1">if checkBlsKeys </span><span class="cov8" title="1">{
                                for _, existingKey := range wrapper.SlotPubKeys </span><span class="cov8" title="1">{
                                        if _, ok := blsKeyMap[existingKey]; ok </span><span class="cov8" title="1">{
                                                return errors.Wrapf(errDupBlsKey, "duplicate bls key %x", existingKey)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// TODO: add unit tests to check staking msg verification

// VerifyAndCreateValidatorFromMsg verifies the create validator message using
// the stateDB, epoch, &amp; blocknumber and returns the validatorWrapper created
// in the process.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndCreateValidatorFromMsg(
        stateDB vm.StateDB, chainContext ChainContext, epoch *big.Int, blockNum *big.Int, msg *staking.CreateValidator,
) (*staking.ValidatorWrapper, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if chainContext == nil </span><span class="cov8" title="1">{
                return nil, errChainContextMissing
        }</span>
        <span class="cov8" title="1">if epoch == nil </span><span class="cov8" title="1">{
                return nil, errEpochMissing
        }</span>
        <span class="cov8" title="1">if blockNum == nil </span><span class="cov8" title="1">{
                return nil, errBlockNumMissing
        }</span>
        <span class="cov8" title="1">if msg.Amount.Sign() == -1 </span><span class="cov8" title="1">{
                return nil, errNegativeAmount
        }</span>
        <span class="cov8" title="1">if stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, errors.Wrapf(
                        errValidatorExist, common2.MustAddressToBech32(msg.ValidatorAddress),
                )
        }</span>
        <span class="cov8" title="1">if err := checkDuplicateFields(
                chainContext, stateDB,
                msg.ValidatorAddress,
                msg.Identity,
                msg.SlotPubKeys); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !CanTransfer(stateDB, msg.ValidatorAddress, msg.Amount) </span><span class="cov8" title="1">{
                return nil, errInsufficientBalanceForStake
        }</span>
        <span class="cov8" title="1">v, err := staking.CreateValidatorFromNewMsg(msg, blockNum, epoch)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wrapper := &amp;staking.ValidatorWrapper{}
        wrapper.Validator = *v
        wrapper.Delegations = []staking.Delegation{
                staking.NewDelegation(v.Address, msg.Amount),
        }
        wrapper.Counters.NumBlocksSigned = big.NewInt(0)
        wrapper.Counters.NumBlocksToSign = big.NewInt(0)
        wrapper.BlockReward = big.NewInt(0)
        // if there is a contract at this address, its code should be retained
        // so far there has been no writing to this address, so the code is available
        // via a simple call
        wrapper.ContractCode = stateDB.GetCode(msg.ValidatorAddress)
        if err := wrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return wrapper, nil</span>
}

// VerifyAndEditValidatorFromMsg verifies the edit validator message using
// the stateDB, chainContext and returns the edited validatorWrapper.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndEditValidatorFromMsg(
        stateDB vm.StateDB, chainContext ChainContext,
        epoch, blockNum *big.Int, msg *staking.EditValidator,
) (*staking.ValidatorWrapper, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if chainContext == nil </span><span class="cov8" title="1">{
                return nil, errChainContextMissing
        }</span>
        <span class="cov8" title="1">if blockNum == nil </span><span class="cov8" title="1">{
                return nil, errBlockNumMissing
        }</span>
        <span class="cov8" title="1">if !stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, errValidatorNotExist
        }</span>
        <span class="cov8" title="1">newBlsKeys := []bls.SerializedPublicKey{}
        if msg.SlotKeyToAdd != nil </span><span class="cov8" title="1">{
                newBlsKeys = append(newBlsKeys, *msg.SlotKeyToAdd)
        }</span>
        <span class="cov8" title="1">if err := checkDuplicateFields(
                chainContext, stateDB,
                msg.ValidatorAddress,
                msg.Identity,
                newBlsKeys); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wrapper, err := stateDB.ValidatorWrapperCopy(msg.ValidatorAddress)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := staking.UpdateValidatorFromEditMsg(&amp;wrapper.Validator, msg, epoch); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">newRate := wrapper.Validator.Rate
        if newRate.GT(wrapper.Validator.MaxRate) </span><span class="cov8" title="1">{
                return nil, errCommissionRateChangeTooHigh
        }</span>

        <span class="cov8" title="1">if chainContext.Config().IsMinCommissionRate(epoch) &amp;&amp; newRate.LT(availability.MinCommissionRate) </span><span class="cov8" title="1">{
                firstEpoch := stateDB.GetValidatorFirstElectionEpoch(msg.ValidatorAddress)
                promoPeriod := chainContext.Config().MinCommissionPromoPeriod.Int64()
                if firstEpoch.Uint64() != 0 &amp;&amp; big.NewInt(0).Sub(epoch, firstEpoch).Int64() &gt;= promoPeriod </span><span class="cov8" title="1">{
                        return nil, errCommissionRateChangeTooLow
                }</span>
        }

        <span class="cov8" title="1">snapshotValidator, err := chainContext.ReadValidatorSnapshot(wrapper.Address)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.WithMessage(err, "validator snapshot not found.")
        }</span>
        <span class="cov8" title="1">rateAtBeginningOfEpoch := snapshotValidator.Validator.Rate

        if rateAtBeginningOfEpoch.IsNil() ||
                (!newRate.IsNil() &amp;&amp; !rateAtBeginningOfEpoch.Equal(newRate)) </span><span class="cov8" title="1">{
                wrapper.Validator.UpdateHeight = blockNum
        }</span>

        <span class="cov8" title="1">if newRate.Sub(rateAtBeginningOfEpoch).Abs().GT(
                wrapper.Validator.MaxChangeRate,
        ) </span><span class="cov8" title="1">{
                return nil, errCommissionRateChangeTooFast
        }</span>
        <span class="cov8" title="1">if err := wrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return wrapper, nil</span>
}

const oneThousand = 1000
const oneHundred = 100

var (
        oneAsBigInt             = big.NewInt(denominations.One)
        minimumDelegation       = new(big.Int).Mul(oneAsBigInt, big.NewInt(oneThousand))
        minimumDelegationV2     = new(big.Int).Mul(oneAsBigInt, big.NewInt(oneHundred))
        errDelegationTooSmall   = errors.New("minimum delegation amount for a delegator has to be greater than or equal to 1000 ONE")
        errDelegationTooSmallV2 = errors.New("minimum delegation amount for a delegator has to be greater than or equal to 100 ONE")
)

// VerifyAndDelegateFromMsg verifies the delegate message using the stateDB
// and returns the balance to be deducted by the delegator as well as the
// validatorWrapper with the delegation applied to it.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndDelegateFromMsg(
        stateDB vm.StateDB, epoch *big.Int, msg *staking.Delegate, delegations []staking.DelegationIndex, chainConfig *params.ChainConfig,
) ([]*staking.ValidatorWrapper, *big.Int, map[common.Address]*big.Int, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, nil, nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if !stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, nil, nil, errValidatorNotExist
        }</span>
        <span class="cov8" title="1">if msg.Amount.Sign() == -1 </span><span class="cov8" title="1">{
                return nil, nil, nil, errNegativeAmount
        }</span>
        <span class="cov8" title="1">if msg.Amount.Cmp(minimumDelegation) &lt; 0 </span><span class="cov8" title="1">{
                if chainConfig.IsMinDelegation100(epoch) </span><span class="cov8" title="1">{
                        if msg.Amount.Cmp(minimumDelegationV2) &lt; 0 </span><span class="cov8" title="1">{
                                return nil, nil, nil, errDelegationTooSmallV2
                        }</span>
                } else<span class="cov8" title="1"> {
                        return nil, nil, nil, errDelegationTooSmall
                }</span>
        }

        <span class="cov8" title="1">updatedValidatorWrappers := []*staking.ValidatorWrapper{}
        delegateBalance := big.NewInt(0).Set(msg.Amount)
        fromLockedTokens := map[common.Address]*big.Int{}

        var delegateeWrapper *staking.ValidatorWrapper
        if chainConfig.IsRedelegation(epoch) </span><span class="cov8" title="1">{
                // Check if we can use tokens in undelegation to delegate (redelegate)
                for i := range delegations </span><span class="cov8" title="1">{
                        delegationIndex := &amp;delegations[i]
                        wrapper, err := stateDB.ValidatorWrapperCopy(delegationIndex.ValidatorAddress)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, err
                        }</span>
                        <span class="cov8" title="1">if uint64(len(wrapper.Delegations)) &lt;= delegationIndex.Index </span><span class="cov8" title="1">{
                                utils.Logger().Warn().
                                        Str("validator", delegationIndex.ValidatorAddress.String()).
                                        Uint64("delegation index", delegationIndex.Index).
                                        Int("delegations length", len(wrapper.Delegations)).
                                        Msg("Delegation index out of bound")
                                return nil, nil, nil, errors.New("Delegation index out of bound")
                        }</span>

                        <span class="cov8" title="1">delegation := &amp;wrapper.Delegations[delegationIndex.Index]

                        startBalance := big.NewInt(0).Set(delegateBalance)
                        // Start from the oldest undelegated tokens
                        curIndex := 0
                        for ; curIndex &lt; len(delegation.Undelegations); curIndex++ </span><span class="cov8" title="1">{
                                if delegation.Undelegations[curIndex].Epoch.Cmp(epoch) &gt;= 0 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">if delegation.Undelegations[curIndex].Amount.Cmp(delegateBalance) &lt;= 0 </span><span class="cov8" title="1">{
                                        delegateBalance.Sub(delegateBalance, delegation.Undelegations[curIndex].Amount)
                                }</span> else<span class="cov8" title="1"> {
                                        delegation.Undelegations[curIndex].Amount.Sub(
                                                delegation.Undelegations[curIndex].Amount, delegateBalance,
                                        )
                                        delegateBalance = big.NewInt(0)
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if startBalance.Cmp(delegateBalance) &gt; 0 </span><span class="cov8" title="1">{
                                // Used undelegated token for redelegation
                                delegation.Undelegations = delegation.Undelegations[curIndex:]
                                if err := wrapper.SanityCheck(); err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, nil, err
                                }</span>

                                <span class="cov8" title="1">if bytes.Equal(delegationIndex.ValidatorAddress[:], msg.ValidatorAddress[:]) </span><span class="cov8" title="1">{
                                        delegateeWrapper = wrapper
                                }</span>
                                <span class="cov8" title="1">updatedValidatorWrappers = append(updatedValidatorWrappers, wrapper)
                                fromLockedTokens[delegationIndex.ValidatorAddress] = big.NewInt(0).Sub(startBalance, delegateBalance)</span>
                        }
                }
        }

        <span class="cov8" title="1">if delegateeWrapper == nil </span><span class="cov8" title="1">{
                var err error
                delegateeWrapper, err = stateDB.ValidatorWrapperCopy(msg.ValidatorAddress)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, nil, err
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers = append(updatedValidatorWrappers, delegateeWrapper)</span>
        }

        // Add to existing delegation if any
        <span class="cov8" title="1">found := false
        for i := range delegateeWrapper.Delegations </span><span class="cov8" title="1">{
                delegation := &amp;delegateeWrapper.Delegations[i]
                if bytes.Equal(delegation.DelegatorAddress.Bytes(), msg.DelegatorAddress.Bytes()) </span><span class="cov8" title="1">{
                        delegation.Amount.Add(delegation.Amount, msg.Amount)
                        if err := delegateeWrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                                return nil, nil, nil, err
                        }</span>
                        <span class="cov8" title="1">found = true</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                // Add new delegation
                delegateeWrapper.Delegations = append(
                        delegateeWrapper.Delegations, staking.NewDelegation(
                                msg.DelegatorAddress, msg.Amount,
                        ),
                )
                if err := delegateeWrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                        return nil, nil, nil, err
                }</span>
        }

        <span class="cov8" title="1">if delegateBalance.Cmp(big.NewInt(0)) == 0 </span><span class="cov8" title="1">{
                // delegation fully from undelegated tokens, no need to deduct from balance.
                return updatedValidatorWrappers, big.NewInt(0), fromLockedTokens, nil
        }</span>

        // Still need to deduct tokens from balance for delegation
        // Check if there is enough liquid token to delegate
        <span class="cov8" title="1">if !CanTransfer(stateDB, msg.DelegatorAddress, delegateBalance) </span><span class="cov8" title="1">{
                return nil, nil, nil, errors.Wrapf(
                        errInsufficientBalanceForStake, "totalRedelegatable: %v, balance: %v; trying to stake %v",
                        big.NewInt(0).Sub(msg.Amount, delegateBalance), stateDB.GetBalance(msg.DelegatorAddress), msg.Amount)
        }</span>

        <span class="cov8" title="1">return updatedValidatorWrappers, delegateBalance, fromLockedTokens, nil</span>
}

// VerifyAndUndelegateFromMsg verifies the undelegate validator message
// using the stateDB &amp; chainContext and returns the edited validatorWrapper
// with the undelegation applied to it.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndUndelegateFromMsg(
        stateDB vm.StateDB, epoch *big.Int, msg *staking.Undelegate,
) (*staking.ValidatorWrapper, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">if epoch == nil </span><span class="cov8" title="1">{
                return nil, errEpochMissing
        }</span>

        <span class="cov8" title="1">if msg.Amount.Sign() == -1 </span><span class="cov8" title="1">{
                return nil, errNegativeAmount
        }</span>

        <span class="cov8" title="1">if !stateDB.IsValidator(msg.ValidatorAddress) </span><span class="cov8" title="1">{
                return nil, errValidatorNotExist
        }</span>

        <span class="cov8" title="1">wrapper, err := stateDB.ValidatorWrapperCopy(msg.ValidatorAddress)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for i := range wrapper.Delegations </span><span class="cov8" title="1">{
                delegation := &amp;wrapper.Delegations[i]
                if bytes.Equal(delegation.DelegatorAddress.Bytes(), msg.DelegatorAddress.Bytes()) </span><span class="cov8" title="1">{
                        if err := delegation.Undelegate(epoch, msg.Amount); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if err := wrapper.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                                // allow self delegation to go below min self delegation
                                // but set the status to inactive
                                if errors.Cause(err) == staking.ErrInvalidSelfDelegation </span><span class="cov8" title="1">{
                                        wrapper.Status = effective.Inactive
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, err
                                }</span>
                        }
                        <span class="cov8" title="1">return wrapper, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, errNoDelegationToUndelegate</span>
}

// VerifyAndCollectRewardsFromDelegation verifies and collects rewards
// from the given delegation slice using the stateDB. It returns all of the
// edited validatorWrappers and the sum total of the rewards.
//
// Note that this function never updates the stateDB, it only reads from stateDB.
func VerifyAndCollectRewardsFromDelegation(
        stateDB vm.StateDB, delegations []staking.DelegationIndex,
) ([]*staking.ValidatorWrapper, *big.Int, error) <span class="cov8" title="1">{
        if stateDB == nil </span><span class="cov8" title="1">{
                return nil, nil, errStateDBIsMissing
        }</span>
        <span class="cov8" title="1">updatedValidatorWrappers := []*staking.ValidatorWrapper{}
        totalRewards := big.NewInt(0)
        for i := range delegations </span><span class="cov8" title="1">{
                delegation := &amp;delegations[i]
                wrapper, err := stateDB.ValidatorWrapperCopy(delegation.ValidatorAddress)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if uint64(len(wrapper.Delegations)) &gt; delegation.Index </span><span class="cov8" title="1">{
                        delegation := &amp;wrapper.Delegations[delegation.Index]
                        if delegation.Reward.Cmp(common.Big0) &gt; 0 </span><span class="cov8" title="1">{
                                totalRewards.Add(totalRewards, delegation.Reward)
                                delegation.Reward.SetUint64(0)
                        }</span>
                } else<span class="cov8" title="1"> {
                        utils.Logger().Warn().
                                Str("validator", delegation.ValidatorAddress.String()).
                                Uint64("delegation index", delegation.Index).
                                Int("delegations length", len(wrapper.Delegations)).
                                Msg("Delegation index out of bound")
                        return nil, nil, errors.New("Delegation index out of bound")
                }</span>
                <span class="cov8" title="1">updatedValidatorWrappers = append(updatedValidatorWrappers, wrapper)</span>
        }
        <span class="cov8" title="1">if totalRewards.Int64() == 0 </span><span class="cov8" title="1">{
                return nil, nil, errNoRewardsToCollect
        }</span>
        <span class="cov8" title="1">return updatedValidatorWrappers, totalRewards, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "math/big"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/block"
        consensus_engine "github.com/harmony-one/harmony/consensus/engine"
        "github.com/harmony-one/harmony/consensus/reward"
        "github.com/harmony-one/harmony/core/state"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/params"
        "github.com/harmony-one/harmony/internal/utils"
        "github.com/harmony-one/harmony/shard"
        "github.com/harmony-one/harmony/staking/slash"
        staking "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var TxHashToStakeMsgs map[string][]staking.StakeMsg

func init() <span class="cov8" title="1">{
        TxHashToStakeMsgs = make(map[string][]staking.StakeMsg)
}</span>

func GetTxHashToStakeMsgs() map[string][]staking.StakeMsg <span class="cov8" title="1">{
        return TxHashToStakeMsgs
}</span>

// StateProcessor is a basic Processor, which takes care of transitioning
// state from one point to another.
//
// StateProcessor implements Processor.
type StateProcessor struct {
        config *params.ChainConfig     // Chain configuration options
        bc     *BlockChain             // Canonical block chain
        engine consensus_engine.Engine // Consensus engine used for block rewards
}

// NewStateProcessor initialises a new StateProcessor.
func NewStateProcessor(
        config *params.ChainConfig, bc *BlockChain, engine consensus_engine.Engine,
) *StateProcessor <span class="cov8" title="1">{
        return &amp;StateProcessor{
                config: config,
                bc:     bc,
                engine: engine,
        }
}</span>

// Process processes the state changes according to the Ethereum rules by running
// the transaction messages using the statedb and applying any rewards to both
// the processor (coinbase) and any included uncles.
//
// Process returns the receipts and logs accumulated during the process and
// returns the amount of gas that was used in the process. If any of the
// transactions failed to execute due to insufficient gas it will return an error.
func (p *StateProcessor) Process(
        block *types.Block, statedb *state.DB, cfg vm.Config,
) (
        types.Receipts, types.CXReceipts,
        []*types.Log, uint64, reward.Reader, error,
) <span class="cov8" title="1">{
        var (
                receipts types.Receipts
                outcxs   types.CXReceipts
                incxs    = block.IncomingReceipts()
                usedGas  = new(uint64)
                header   = block.Header()
                allLogs  []*types.Log
                gp       = new(GasPool).AddGas(block.GasLimit())
        )

        beneficiary, err := p.bc.GetECDSAFromCoinbase(header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, 0, nil, err
        }</span>

        <span class="cov8" title="1">startTime := time.Now()
        // Iterate over and process the individual transactions
        for i, tx := range block.Transactions() </span><span class="cov0" title="0">{
                statedb.Prepare(tx.Hash(), block.Hash(), i)
                receipt, cxReceipt, _, err := ApplyTransaction(
                        p.config, p.bc, &amp;beneficiary, gp, statedb, header, tx, usedGas, cfg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, 0, nil, err
                }</span>
                <span class="cov0" title="0">receipts = append(receipts, receipt)
                if cxReceipt != nil </span><span class="cov0" title="0">{
                        outcxs = append(outcxs, cxReceipt)
                }</span>
                <span class="cov0" title="0">allLogs = append(allLogs, receipt.Logs...)</span>
        }
        <span class="cov8" title="1">utils.Logger().Debug().Int64("elapsed time", time.Now().Sub(startTime).Milliseconds()).Msg("Process Normal Txns")

        startTime = time.Now()
        // Iterate over and process the staking transactions
        L := len(block.Transactions())
        for i, tx := range block.StakingTransactions() </span><span class="cov0" title="0">{
                statedb.Prepare(tx.Hash(), block.Hash(), i+L)
                receipt, _, err := ApplyStakingTransaction(
                        p.config, p.bc, &amp;beneficiary, gp, statedb, header, tx, usedGas, cfg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, 0, nil, err
                }</span>
                <span class="cov0" title="0">receipts = append(receipts, receipt)
                allLogs = append(allLogs, receipt.Logs...)</span>
        }
        <span class="cov8" title="1">utils.Logger().Debug().Int64("elapsed time", time.Now().Sub(startTime).Milliseconds()).Msg("Process Staking Txns")

        // incomingReceipts should always be processed
        // after transactions (to be consistent with the block proposal)
        for _, cx := range block.IncomingReceipts() </span><span class="cov0" title="0">{
                if err := ApplyIncomingReceipt(
                        p.config, statedb, header, cx,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, nil,
                                nil, 0, nil, errors.New("[Process] Cannot apply incoming receipts")
                }</span>
        }

        <span class="cov8" title="1">slashes := slash.Records{}
        if s := header.Slashes(); len(s) &gt; 0 </span><span class="cov0" title="0">{
                if err := rlp.DecodeBytes(s, &amp;slashes); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, 0, nil, errors.New(
                                "[Process] Cannot finalize block",
                        )
                }</span>
        }

        // Finalize the block, applying any consensus engine specific extras (e.g. block rewards)
        <span class="cov8" title="1">sigsReady := make(chan bool)
        go func() </span><span class="cov8" title="1">{
                // Block processing don't need to block on reward computation as in block proposal
                sigsReady &lt;- true
        }</span>()
        <span class="cov8" title="1">_, payout, err := p.engine.Finalize(
                p.bc, header, statedb, block.Transactions(),
                receipts, outcxs, incxs, block.StakingTransactions(), slashes, sigsReady, func() uint64 </span><span class="cov8" title="1">{ return header.ViewID().Uint64() }</span>,
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, 0, nil, errors.New("[Process] Cannot finalize block")
        }</span>

        <span class="cov8" title="1">return receipts, outcxs, allLogs, *usedGas, payout, nil</span>
}

// return true if it is valid
func getTransactionType(
        config *params.ChainConfig, header *block.Header, tx *types.Transaction,
) types.TransactionType <span class="cov8" title="1">{
        if header.ShardID() == tx.ShardID() &amp;&amp;
                (!config.AcceptsCrossTx(header.Epoch()) ||
                        tx.ShardID() == tx.ToShardID()) </span><span class="cov8" title="1">{
                return types.SameShardTx
        }</span>
        <span class="cov0" title="0">numShards := shard.Schedule.InstanceForEpoch(header.Epoch()).NumShards()
        // Assuming here all the shards are consecutive from 0 to n-1, n is total number of shards
        if tx.ShardID() != tx.ToShardID() &amp;&amp;
                header.ShardID() == tx.ShardID() &amp;&amp;
                tx.ToShardID() &lt; numShards </span><span class="cov0" title="0">{
                return types.SubtractionOnly
        }</span>
        <span class="cov0" title="0">return types.InvalidTx</span>
}

// ApplyTransaction attempts to apply a transaction to the given state database
// and uses the input parameters for its environment. It returns the receipt
// for the transaction, gas used and an error if the transaction failed,
// indicating the block was invalid.
func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.DB, header *block.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, *types.CXReceipt, uint64, error) <span class="cov8" title="1">{
        txType := getTransactionType(config, header, tx)
        if txType == types.InvalidTx </span><span class="cov0" title="0">{
                return nil, nil, 0, errors.New("Invalid Transaction Type")
        }</span>

        <span class="cov8" title="1">if txType != types.SameShardTx &amp;&amp; !config.AcceptsCrossTx(header.Epoch()) </span><span class="cov0" title="0">{
                return nil, nil, 0, errors.Errorf(
                        "cannot handle cross-shard transaction until after epoch %v (now %v)",
                        config.CrossTxEpoch, header.Epoch(),
                )
        }</span>

        <span class="cov8" title="1">var signer types.Signer
        if tx.IsEthCompatible() </span><span class="cov0" title="0">{
                if !config.IsEthCompatible(header.Epoch()) </span><span class="cov0" title="0">{
                        return nil, nil, 0, errors.New("ethereum compatible transactions not supported at current epoch")
                }</span>
                <span class="cov0" title="0">signer = types.NewEIP155Signer(config.EthCompatibleChainID)</span>
        } else<span class="cov8" title="1"> {
                signer = types.MakeSigner(config, header.Epoch())
        }</span>
        <span class="cov8" title="1">msg, err := tx.AsMessage(signer)

        // skip signer err for additiononly tx
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, 0, err
        }</span>

        // Create a new context to be used in the EVM environment
        <span class="cov8" title="1">context := NewEVMContext(msg, header, bc, author)
        context.TxType = txType
        // Create a new environment which holds all relevant information
        // about the transaction and calling mechanisms.
        vmenv := vm.NewEVM(context, statedb, config, cfg)
        // Apply the transaction to the current state (included in the env)
        result, err := ApplyMessage(vmenv, msg, gp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, 0, err
        }</span>
        <span class="cov8" title="1">if vmenv.StakeMsgs != nil </span><span class="cov0" title="0">{
                TxHashToStakeMsgs[tx.Hash().Hex()] = vmenv.StakeMsgs
                vmenv.StakeMsgs = nil
        }</span>
        // Update the state with pending changes
        <span class="cov8" title="1">var root []byte
        if config.IsS3(header.Epoch()) </span><span class="cov8" title="1">{
                statedb.Finalise(true)
        }</span> else<span class="cov0" title="0"> {
                root = statedb.IntermediateRoot(config.IsS3(header.Epoch())).Bytes()
        }</span>
        <span class="cov8" title="1">*usedGas += result.UsedGas

        failedExe := result.VMErr != nil
        // Create a new receipt for the transaction, storing the intermediate root and gas used by the tx
        // based on the eip phase, we're passing whether the root touch-delete accounts.
        receipt := types.NewReceipt(root, failedExe, *usedGas)
        receipt.TxHash = tx.Hash()
        receipt.GasUsed = result.UsedGas
        // if the transaction created a contract, store the creation address in the receipt.
        if msg.To() == nil </span><span class="cov0" title="0">{
                receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())
        }</span>

        // Set the receipt logs and create a bloom for filtering
        <span class="cov8" title="1">if config.IsReceiptLog(header.Epoch()) </span><span class="cov8" title="1">{
                receipt.Logs = statedb.GetLogs(tx.Hash())
        }</span>
        <span class="cov8" title="1">receipt.Bloom = types.CreateBloom(types.Receipts{receipt})

        var cxReceipt *types.CXReceipt
        // Do not create cxReceipt if EVM call failed
        if txType == types.SubtractionOnly &amp;&amp; !failedExe </span><span class="cov0" title="0">{
                cxReceipt = &amp;types.CXReceipt{tx.Hash(), msg.From(), msg.To(), tx.ShardID(), tx.ToShardID(), msg.Value()}
        }</span> else<span class="cov8" title="1"> {
                cxReceipt = nil
        }</span>

        <span class="cov8" title="1">return receipt, cxReceipt, result.UsedGas, err</span>
}

// ApplyStakingTransaction attempts to apply a staking transaction to the given state database
// and uses the input parameters for its environment. It returns the receipt
// for the staking transaction, gas used and an error if the transaction failed,
// indicating the block was invalid.
// staking transaction will use the code field in the account to store the staking information
func ApplyStakingTransaction(
        config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.DB,
        header *block.Header, tx *staking.StakingTransaction, usedGas *uint64, cfg vm.Config) (receipt *types.Receipt, gas uint64, err error) <span class="cov0" title="0">{

        msg, err := StakingToMessage(tx, header.Number())
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Create a new context to be used in the EVM environment
        <span class="cov0" title="0">context := NewEVMContext(msg, header, bc, author)

        // Create a new environment which holds all relevant information
        // about the transaction and calling mechanisms.
        vmenv := vm.NewEVM(context, statedb, config, cfg)

        // Apply the transaction to the current state (included in the env)
        gas, err = ApplyStakingMessage(vmenv, msg, gp, bc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Update the state with pending changes
        <span class="cov0" title="0">var root []byte
        if config.IsS3(header.Epoch()) </span><span class="cov0" title="0">{
                statedb.Finalise(true)
        }</span> else<span class="cov0" title="0"> {
                root = statedb.IntermediateRoot(config.IsS3(header.Epoch())).Bytes()
        }</span>
        <span class="cov0" title="0">*usedGas += gas
        receipt = types.NewReceipt(root, false, *usedGas)
        receipt.TxHash = tx.Hash()
        receipt.GasUsed = gas

        if config.IsReceiptLog(header.Epoch()) </span><span class="cov0" title="0">{
                receipt.Logs = statedb.GetLogs(tx.Hash())
                utils.Logger().Info().Interface("CollectReward", receipt.Logs)
        }</span>

        <span class="cov0" title="0">return receipt, gas, nil</span>
}

// ApplyIncomingReceipt will add amount into ToAddress in the receipt
func ApplyIncomingReceipt(
        config *params.ChainConfig, db *state.DB,
        header *block.Header, cxp *types.CXReceiptsProof,
) error <span class="cov0" title="0">{
        if cxp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, cx := range cxp.Receipts </span><span class="cov0" title="0">{
                if cx == nil || cx.To == nil </span><span class="cov0" title="0">{ // should not happend
                        return errors.Errorf(
                                "ApplyIncomingReceipts: Invalid incomingReceipt! %v", cx,
                        )
                }</span>
                <span class="cov0" title="0">utils.Logger().Info().Interface("receipt", cx).
                        Msgf("ApplyIncomingReceipts: ADDING BALANCE %d", cx.Amount)

                if !db.Exist(*cx.To) </span><span class="cov0" title="0">{
                        db.CreateAccount(*cx.To)
                }</span>
                <span class="cov0" title="0">db.AddBalance(*cx.To, cx.Amount)
                db.IntermediateRoot(config.IsS3(header.Epoch()))</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// StakingToMessage returns the staking transaction as a core.Message.
// requires a signer to derive the sender.
// put it here to avoid cyclic import
func StakingToMessage(
        tx *staking.StakingTransaction, blockNum *big.Int,
) (types.Message, error) <span class="cov8" title="1">{
        payload, err := tx.RLPEncodeStakeMsg()
        if err != nil </span><span class="cov0" title="0">{
                return types.Message{}, err
        }</span>
        <span class="cov8" title="1">from, err := tx.SenderAddress()
        if err != nil </span><span class="cov0" title="0">{
                return types.Message{}, err
        }</span>

        <span class="cov8" title="1">msg := types.NewStakingMessage(from, tx.Nonce(), tx.GasLimit(), tx.GasPrice(), payload, blockNum)
        stkType := tx.StakingType()
        if _, ok := types.StakingTypeMap[stkType]; !ok </span><span class="cov0" title="0">{
                return types.Message{}, staking.ErrInvalidStakingKind
        }</span>
        <span class="cov8" title="1">msg.SetType(types.StakingTypeMap[stkType])
        return msg, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package core

import (
        "fmt"
        "math/big"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        "github.com/harmony-one/harmony/core/types"
        "github.com/harmony-one/harmony/core/vm"
        "github.com/harmony-one/harmony/internal/utils"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
        "github.com/pkg/errors"
)

var (
        errInvalidSigner               = errors.New("invalid signer for staking transaction")
        errInsufficientBalanceForGas   = errors.New("insufficient balance to pay for gas")
        errInsufficientBalanceForStake = errors.New("insufficient balance to stake")
        errValidatorExist              = errors.New("staking validator already exists")
        errValidatorNotExist           = errors.New("staking validator does not exist")
        errNoDelegationToUndelegate    = errors.New("no delegation to undelegate")
        errCommissionRateChangeTooFast = errors.New("change on commission rate can not be more than max change rate within the same epoch")
        errCommissionRateChangeTooHigh = errors.New("commission rate can not be higher than maximum commission rate")
        errCommissionRateChangeTooLow  = errors.New("commission rate can not be lower than min rate of 5%")
        errNoRewardsToCollect          = errors.New("no rewards to collect")
        errNegativeAmount              = errors.New("amount can not be negative")
        errDupIdentity                 = errors.New("validator identity exists")
        errDupBlsKey                   = errors.New("BLS key exists")
)

/*
StateTransition is the State Transitioning Model which is described as follows:

A state transition is a change made when a transaction is applied to the current world state
The state transitioning model does all the necessary work to work out a valid new state root.

1) Nonce handling
2) Pre pay gas
3) Create a new state object if the recipient is \0*32
4) Value transfer
== If contract creation ==
  4a) Attempt to run transaction data
  4b) If valid, use result as code for the new state object
== end ==
5) Run Script section
6) Derive new state root
*/
type StateTransition struct {
        gp         *GasPool
        msg        Message
        gas        uint64
        gasPrice   *big.Int
        initialGas uint64
        value      *big.Int
        data       []byte
        state      vm.StateDB
        evm        *vm.EVM
        bc         ChainContext
}

// Message represents a message sent to a contract.
type Message interface {
        From() common.Address
        //FromFrontier() (common.Address, error)
        To() *common.Address

        GasPrice() *big.Int
        Gas() uint64
        Value() *big.Int

        Nonce() uint64
        CheckNonce() bool
        Data() []byte
        Type() types.TransactionType
        BlockNum() *big.Int
}

// ExecutionResult is the return value from a transaction committed to the DB
type ExecutionResult struct {
        ReturnData []byte
        UsedGas    uint64
        VMErr      error
}

// Unwrap returns the internal evm error which allows us for further
// analysis outside.
func (result *ExecutionResult) Unwrap() error <span class="cov0" title="0">{
        return result.VMErr
}</span>

// Failed returns the indicator whether the execution is successful or not
func (result *ExecutionResult) Failed() bool <span class="cov0" title="0">{ return result.VMErr != nil }</span>

// Return is a helper function to help caller distinguish between revert reason
// and function return. Return returns the data after execution if no error occurs.
func (result *ExecutionResult) Return() []byte <span class="cov0" title="0">{
        if result.VMErr != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.CopyBytes(result.ReturnData)</span>
}

// Revert returns the concrete revert reason if the execution is aborted by `REVERT`
// opcode. Note the reason can be nil if no data supplied with revert opcode.
func (result *ExecutionResult) Revert() []byte <span class="cov0" title="0">{
        if result.VMErr != vm.ErrExecutionReverted </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.CopyBytes(result.ReturnData)</span>
}

// NewStateTransition initialises and returns a new state transition object.
func NewStateTransition(evm *vm.EVM, msg Message, gp *GasPool, bc ChainContext) *StateTransition <span class="cov8" title="1">{
        return &amp;StateTransition{
                gp:       gp,
                evm:      evm,
                msg:      msg,
                gasPrice: msg.GasPrice(),
                value:    msg.Value(),
                data:     msg.Data(),
                state:    evm.StateDB,
                bc:       bc,
        }
}</span>

// ApplyMessage computes the new state by applying the given message
// against the old state within the environment.
//
// ApplyMessage returns the bytes returned by any EVM execution (if it took place),
// the gas used (which includes gas refunds) and an error if it failed. An error always
// indicates a core error meaning that the message would always fail for that particular
// state and would never be accepted within a block.
func ApplyMessage(evm *vm.EVM, msg Message, gp *GasPool) (ExecutionResult, error) <span class="cov8" title="1">{
        return NewStateTransition(evm, msg, gp, nil).TransitionDb()
}</span>

// ApplyStakingMessage computes the new state for staking message
func ApplyStakingMessage(evm *vm.EVM, msg Message, gp *GasPool, bc ChainContext) (uint64, error) <span class="cov8" title="1">{
        return NewStateTransition(evm, msg, gp, bc).StakingTransitionDb()
}</span>

// to returns the recipient of the message.
func (st *StateTransition) to() common.Address <span class="cov8" title="1">{
        if st.msg == nil || st.msg.To() == nil /* contract creation */ </span><span class="cov0" title="0">{
                return common.Address{}
        }</span>
        <span class="cov8" title="1">return *st.msg.To()</span>
}

func (st *StateTransition) useGas(amount uint64) error <span class="cov8" title="1">{
        if st.gas &lt; amount </span><span class="cov0" title="0">{
                return vm.ErrOutOfGas
        }</span>
        <span class="cov8" title="1">st.gas -= amount

        return nil</span>
}

func (st *StateTransition) buyGas() error <span class="cov8" title="1">{
        mgval := new(big.Int).Mul(new(big.Int).SetUint64(st.msg.Gas()), st.gasPrice)
        if have := st.state.GetBalance(st.msg.From()); have.Cmp(mgval) &lt; 0 </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        errInsufficientBalanceForGas,
                        "had: %s but need: %s", have.String(), mgval.String(),
                )
        }</span>
        <span class="cov8" title="1">if err := st.gp.SubGas(st.msg.Gas()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">st.gas += st.msg.Gas()

        st.initialGas = st.msg.Gas()
        st.state.SubBalance(st.msg.From(), mgval)
        return nil</span>
}

func (st *StateTransition) preCheck() error <span class="cov8" title="1">{
        // Make sure this transaction's nonce is correct.
        if st.msg.CheckNonce() </span><span class="cov8" title="1">{
                nonce := st.state.GetNonce(st.msg.From())

                if nonce &lt; st.msg.Nonce() </span><span class="cov0" title="0">{
                        return ErrNonceTooHigh
                }</span> else<span class="cov8" title="1"> if nonce &gt; st.msg.Nonce() </span><span class="cov0" title="0">{
                        return ErrNonceTooLow
                }</span>
        }
        <span class="cov8" title="1">return st.buyGas()</span>
}

// TransitionDb will transition the state by applying the current message and
// returning the result including the used gas. It returns an error if failed.
// An error indicates a consensus issue.
func (st *StateTransition) TransitionDb() (ExecutionResult, error) <span class="cov8" title="1">{
        if err := st.preCheck(); err != nil </span><span class="cov0" title="0">{
                return ExecutionResult{}, err
        }</span>
        <span class="cov8" title="1">msg := st.msg
        sender := vm.AccountRef(msg.From())
        homestead := st.evm.ChainConfig().IsS3(st.evm.EpochNumber) // s3 includes homestead
        istanbul := st.evm.ChainConfig().IsIstanbul(st.evm.EpochNumber)
        contractCreation := msg.To() == nil

        // Pay intrinsic gas
        gas, err := vm.IntrinsicGas(st.data, contractCreation, homestead, istanbul, false)
        if err != nil </span><span class="cov0" title="0">{
                return ExecutionResult{}, err
        }</span>
        <span class="cov8" title="1">if err = st.useGas(gas); err != nil </span><span class="cov0" title="0">{
                return ExecutionResult{}, fmt.Errorf("%w: have %d, want %d", ErrIntrinsicGas, st.gas, gas)
        }</span>

        <span class="cov8" title="1">evm := st.evm

        var ret []byte
        // All VM errors are valid except for insufficient balance, therefore returned separately
        var vmErr error

        if contractCreation </span><span class="cov0" title="0">{
                ret, _, st.gas, vmErr = evm.Create(sender, st.data, st.gas, st.value)
        }</span> else<span class="cov8" title="1"> {
                // Increment the nonce for the next transaction
                st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)
                ret, st.gas, vmErr = evm.Call(sender, st.to(), st.data, st.gas, st.value)
        }</span>
        <span class="cov8" title="1">if vmErr != nil </span><span class="cov0" title="0">{
                utils.Logger().Debug().Err(vmErr).Msg("VM returned with error")
                // The only possible consensus-error would be if there wasn't
                // sufficient balance to make the transfer happen. The first
                // balance transfer may never fail.

                if vmErr == vm.ErrInsufficientBalance </span><span class="cov0" title="0">{
                        return ExecutionResult{}, vmErr
                }</span>
        }
        <span class="cov8" title="1">st.refundGas()

        // Burn Txn Fees after staking epoch
        if !st.evm.ChainConfig().IsStaking(st.evm.EpochNumber) </span><span class="cov0" title="0">{
                txFee := new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice)
                st.state.AddBalance(st.evm.Coinbase, txFee)
        }</span>

        <span class="cov8" title="1">return ExecutionResult{
                ReturnData: ret,
                UsedGas:    st.gasUsed(),
                VMErr:      vmErr,
        }, err</span>
}

func (st *StateTransition) refundGas() <span class="cov8" title="1">{
        // Apply refund counter, capped to half of the used gas.
        refund := st.gasUsed() / 2
        if refund &gt; st.state.GetRefund() </span><span class="cov8" title="1">{
                refund = st.state.GetRefund()
        }</span>
        <span class="cov8" title="1">st.gas += refund

        // Return ETH for remaining gas, exchanged at the original rate.
        remaining := new(big.Int).Mul(new(big.Int).SetUint64(st.gas), st.gasPrice)
        st.state.AddBalance(st.msg.From(), remaining)

        // Also return remaining gas to the block gas counter so it is
        // available for the next transaction.
        st.gp.AddGas(st.gas)</span>
}

// gasUsed returns the amount of gas used up by the state transition.
func (st *StateTransition) gasUsed() uint64 <span class="cov8" title="1">{
        return st.initialGas - st.gas
}</span>

// StakingTransitionDb will transition the state by applying the staking message and
// returning the result including the used gas. It returns an error if failed.
// It is used for staking transaction only
func (st *StateTransition) StakingTransitionDb() (usedGas uint64, err error) <span class="cov8" title="1">{
        if err = st.preCheck(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">msg := st.msg

        sender := vm.AccountRef(msg.From())
        homestead := st.evm.ChainConfig().IsS3(st.evm.EpochNumber) // s3 includes homestead
        istanbul := st.evm.ChainConfig().IsIstanbul(st.evm.EpochNumber)

        // Pay intrinsic gas
        gas, err := vm.IntrinsicGas(st.data, false, homestead, istanbul, msg.Type() == types.StakeCreateVal)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if err = st.useGas(gas); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Increment the nonce for the next transaction
        <span class="cov8" title="1">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)

        switch msg.Type() </span>{
        case types.StakeCreateVal:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.CreateValidator{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().
                        Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.ValidatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.CreateValidator(st.evm.StateDB, stkMsg)</span>
        case types.StakeEditVal:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.EditValidator{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().
                        Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.ValidatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.EditValidator(st.evm.StateDB, stkMsg)</span>
        case types.Delegate:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.Delegate{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.Delegate(st.evm.StateDB, stkMsg)</span>
        case types.Undelegate:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.Undelegate{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.Undelegate(st.evm.StateDB, stkMsg)</span>
        case types.CollectRewards:<span class="cov8" title="1">
                stkMsg := &amp;stakingTypes.CollectRewards{}
                if err = rlp.DecodeBytes(msg.Data(), stkMsg); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">utils.Logger().Info().Msgf("[DEBUG STAKING] staking type: %s, gas: %d, txn: %+v", msg.Type(), gas, stkMsg)
                if msg.From() != stkMsg.DelegatorAddress </span><span class="cov0" title="0">{
                        return 0, errInvalidSigner
                }</span>
                <span class="cov8" title="1">err = st.evm.CollectRewards(st.evm.StateDB, stkMsg)</span>
        default:<span class="cov0" title="0">
                return 0, stakingTypes.ErrInvalidStakingKind</span>
        }
        <span class="cov8" title="1">st.refundGas()

        // Burn Txn Fees
        //txFee := new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice)
        //st.state.AddBalance(st.evm.Coinbase, txFee)

        return st.gasUsed(), err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package vm

import (
        "errors"
        "github.com/ethereum/go-ethereum/common"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
        staking "github.com/harmony-one/harmony/staking"
)

var WriteCapablePrecompiledContracts = map[common.Address]WriteCapablePrecompiledContract{
        common.BytesToAddress([]byte{252}): &amp;stakingPrecompile{},
}

// Native Go contracts which are available as a precompile in the EVM
// These have the capability to alter the state (those in contracts.go do not)
type WriteCapablePrecompiledContract interface {
        RequiredGas(evm *EVM, input []byte) (uint64, error) // RequiredPrice calculates the contract gas use
  // use a different name from read-only contracts to be safe
        RunWriteCapable(evm *EVM, contract *Contract, input []byte) ([]byte, error)
}

// RunPrecompiledContract runs and evaluates the output of a precompiled contract.
func RunWriteCapablePrecompiledContract(p WriteCapablePrecompiledContract, evm *EVM, contract *Contract, input []byte) ([]byte, error) <span class="cov8" title="1">{
        gas, err := p.RequiredGas(evm, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !contract.UseGas(gas) </span><span class="cov0" title="0">{
                return nil, ErrOutOfGas
        }</span>
        <span class="cov8" title="1">return p.RunWriteCapable(evm, contract, input)</span>
}

type stakingPrecompile struct{}

// RequiredGas returns the gas required to execute the pre-compiled contract.
//
// This method does not require any overflow checking as the input size gas costs
// required for anything significant is so high it's impossible to pay for.
func (c *stakingPrecompile) RequiredGas(evm *EVM, input []byte) (uint64, error) <span class="cov8" title="1">{
        if len(input) &lt; 64 </span><span class="cov0" title="0">{
                return 0, errors.New("Input is malformed")
        }</span>
        <span class="cov8" title="1">homestead := evm.ChainConfig().IsS3(evm.EpochNumber)
        istanbul := evm.ChainConfig().IsIstanbul(evm.EpochNumber)
        gas, err := IntrinsicGas(input,
                                                                                                 false, /* contractCreation */
                                                                                                 homestead,
                                                                                                 istanbul,
                                                                                                 stakingTypes.Directive(getData(input, 63, 64)[0]) == stakingTypes.DirectiveCreateValidator)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return gas, nil</span>
}

func (c *stakingPrecompile) RunWriteCapable(evm *EVM, contract *Contract, input []byte) ([]byte, error) <span class="cov8" title="1">{
        // if evm.Context.ShardID != shard.BeaconChainShardID {
        //         return nil, nil        // we are not shard 0, so this is not for us
        // }

        // need at least (1) initial 32 bytes for size, and (2) next 32 bytes for directive
        if len(input) &lt; 64 </span><span class="cov0" title="0">{
                return nil, errors.New("Input is malformed")
        }</span>
        // discard length of structure (first 32 members of the array)
        <span class="cov8" title="1">input = input[32:]
        // directive is a single byte
  var directive = stakingTypes.Directive(getData(input, 31, 32)[0])
        // store passed information in map
        args := map[string]interface{}{}
        switch directive </span>{
                case stakingTypes.DirectiveCreateValidator:<span class="cov8" title="1"> </span><span class="cov8" title="1">{
                        if err := staking.UnpackFromStakingMethod("CreateValidator", args, input); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        // a contract must not make anyone else a validator
                        <span class="cov8" title="1">address, err := staking.ValidateContractAddress(contract.Caller(), args, "ValidatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">amount, err := staking.ParseBigIntFromKey(args, "Amount")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">description, err := staking.ParseDescription(args)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">commissionRates, err := staking.ParseCommissionRates(args)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">minSelfDelegation, err := staking.ParseBigIntFromKey(args, "MinSelfDelegation")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">maxTotalDelegation, err := staking.ParseBigIntFromKey(args, "MaxTotalDelegation")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">slotPubKeys, err := staking.ParseSlotPubKeys(args)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">slotKeySigs, err := staking.ParseSlotKeySigs(args)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.CreateValidator{
                                ValidatorAddress: address,
                                Amount: amount,
                                Description: description,
                                CommissionRates: commissionRates,
                                MinSelfDelegation: minSelfDelegation,
                                MaxTotalDelegation: maxTotalDelegation,
                                SlotPubKeys: slotPubKeys,
                                SlotKeySigs: slotKeySigs,
                        }
                        if err := evm.CreateValidator(evm.StateDB, stakeMsg); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                evm.StakeMsgs = append(evm.StakeMsgs, stakeMsg)
                                return nil, nil
                        }</span>
                }
                case stakingTypes.DirectiveEditValidator:<span class="cov8" title="1"> </span><span class="cov8" title="1">{
                        if err := staking.UnpackFromStakingMethod("EditValidator", args, input); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">address, err := staking.ValidateContractAddress(contract.Caller(), args, "ValidatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">description, err := staking.ParseDescription(args)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">commissionRate, err := staking.ParseCommissionRate(args)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">minSelfDelegation, err := staking.ParseBigIntFromKey(args, "MinSelfDelegation")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">maxTotalDelegation, err := staking.ParseBigIntFromKey(args, "MaxTotalDelegation")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">slotKeyToRemove, err := staking.ParseSlotPubKeyFromKey(args, "SlotKeyToRemove")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">slotKeyToAdd, err := staking.ParseSlotPubKeyFromKey(args, "SlotKeyToAdd")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">slotKeyToAddSig, err := staking.ParseSlotKeySigFromKey(args, "SlotKeyToAddSig")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.EditValidator{
                                ValidatorAddress: address,
                                Description: description,
                                CommissionRate: commissionRate,
                                MinSelfDelegation: minSelfDelegation,
                                MaxTotalDelegation: maxTotalDelegation,
                                SlotKeyToRemove: slotKeyToRemove,
                                SlotKeyToAdd: slotKeyToAdd,
                                SlotKeyToAddSig: slotKeyToAddSig,
                        }
                        return nil, evm.EditValidator(evm.StateDB, stakeMsg)</span>
                }
                case stakingTypes.DirectiveDelegate:<span class="cov8" title="1"> </span><span class="cov8" title="1">{
                        if err := staking.UnpackFromStakingMethod("DelegateOrUndelegate", args, input); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        // a contract should only delegate its own balance - nobody else's
                        <span class="cov8" title="1">address, err := staking.ValidateContractAddress(contract.Caller(), args, "DelegatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">validatorAddress, err := staking.ParseAddressFromKey(args, "ValidatorAddress")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">amount, err := staking.ParseBigIntFromKey(args, "Amount")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.Delegate{
                                DelegatorAddress: address,
                                ValidatorAddress: validatorAddress,
                                Amount: amount,
                        }
                        if err := evm.Delegate(evm.StateDB, stakeMsg); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                evm.StakeMsgs = append(evm.StakeMsgs, stakeMsg)
                                return nil, nil
                        }</span>
                }
                case stakingTypes.DirectiveUndelegate:<span class="cov8" title="1"> </span><span class="cov8" title="1">{
                        if err := staking.UnpackFromStakingMethod("DelegateOrUndelegate", args, input); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        // a contract should only delegate its own balance - nobody else's
                        <span class="cov8" title="1">address, err := staking.ValidateContractAddress(contract.Caller(), args, "DelegatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">validatorAddress, err := staking.ParseAddressFromKey(args, "ValidatorAddress")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // this type assertion is needed by Golang
                        <span class="cov8" title="1">amount, err := staking.ParseBigIntFromKey(args, "Amount")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.Undelegate{
                                DelegatorAddress: address,
                                ValidatorAddress: validatorAddress,
                                Amount: amount,
                        }
                        return nil, evm.Undelegate(evm.StateDB, stakeMsg)</span>
                }
                case stakingTypes.DirectiveCollectRewards:<span class="cov8" title="1"> </span><span class="cov8" title="1">{
                        if err := staking.UnpackFromStakingMethod("CollectRewards", args, input); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        // a contract should only collect its own rewards - nobody else's
                        <span class="cov8" title="1">address, err := staking.ValidateContractAddress(contract.Caller(), args, "DelegatorAddress")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stakeMsg := &amp;stakingTypes.CollectRewards{
                                DelegatorAddress: address,
                        }
                        return nil, evm.CollectRewards(evm.StateDB, stakeMsg)</span>
                }
                default:<span class="cov8" title="1"> </span><span class="cov8" title="1">{
                        return nil, stakingTypes.ErrInvalidStakingKind
                }</span>
        }
  // return nil, nil -&gt; this never reached
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package vm

import (
        "math/big"
        "sync/atomic"
        "time"
        "fmt"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/harmony-one/harmony/internal/params"

        "github.com/harmony-one/harmony/core/types"
        stakingTypes "github.com/harmony-one/harmony/staking/types"
)

// emptyCodeHash is used by create to ensure deployment is disallowed to already
// deployed contract addresses (relevant after the account abstraction).
var emptyCodeHash = crypto.Keccak256Hash(nil)

type (
        // CanTransferFunc is the signature of a transfer guard function
        CanTransferFunc func(StateDB, common.Address, *big.Int) bool
        // IsValidatorFunc is the signature of IsValidator function
        IsValidatorFunc func(StateDB, common.Address) bool
        // TransferFunc is the signature of a transfer function
        TransferFunc func(StateDB, common.Address, common.Address, *big.Int, types.TransactionType)
        // GetHashFunc returns the nth block hash in the blockchain
        // and is used by the BLOCKHASH EVM op code.
        GetHashFunc func(uint64) common.Hash
        // GetVRFFunc returns the nth block vrf in the blockchain
        // and is used by the precompile VRF contract.
        GetVRFFunc func(uint64) common.Hash
        // Below functions are used by staking precompile / state transition
        CreateValidatorFunc func(db StateDB, stakeMsg *stakingTypes.CreateValidator) error
        EditValidatorFunc func(db StateDB, stakeMsg *stakingTypes.EditValidator) error
        DelegateFunc func(db StateDB, stakeMsg *stakingTypes.Delegate) error
        UndelegateFunc func(db StateDB, stakeMsg *stakingTypes.Undelegate) error
        CollectRewardsFunc func(db StateDB, stakeMsg *stakingTypes.CollectRewards) error
)

// run runs the given contract and takes care of running precompiles with a fallback to the byte code interpreter.
func run(evm *EVM, contract *Contract, input []byte, readOnly bool) ([]byte, error) <span class="cov8" title="1">{
        if contract.CodeAddr != nil </span><span class="cov8" title="1">{
                precompiles := PrecompiledContractsHomestead
                // assign empty write capable precompiles till they are available in the fork
                writeCapablePrecompiles := make(map[common.Address]WriteCapablePrecompiledContract)
                if evm.ChainConfig().IsS3(evm.EpochNumber) </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsByzantium
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsIstanbul </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsIstanbul
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsVRF </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsVRF
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsSHA3 </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsSHA3FIPS
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsStakingPrecompile </span><span class="cov8" title="1">{
                        writeCapablePrecompiles = WriteCapablePrecompiledContracts
                }</span>
                <span class="cov8" title="1">if p := precompiles[*contract.CodeAddr]; p != nil </span><span class="cov0" title="0">{
                        if _, ok := p.(*vrf); ok </span><span class="cov0" title="0">{
                                if evm.chainRules.IsPrevVRF </span><span class="cov0" title="0">{
                                        requestedBlockNum := big.NewInt(0).SetBytes(input)
                                        minBlockNum := big.NewInt(0).Sub(evm.BlockNumber, common.Big257)

                                        if requestedBlockNum.Cmp(evm.BlockNumber) == 0 </span><span class="cov0" title="0">{
                                                input = evm.Context.VRF.Bytes()
                                        }</span> else<span class="cov0" title="0"> if requestedBlockNum.Cmp(minBlockNum) &gt; 0 &amp;&amp; requestedBlockNum.Cmp(evm.BlockNumber) &lt; 0 </span><span class="cov0" title="0">{
                                                // requested block number is in range
                                                input = evm.GetVRF(requestedBlockNum.Uint64()).Bytes()
                                        }</span> else<span class="cov0" title="0"> {
                                                // else default to the current block's VRF
                                                input = evm.Context.VRF.Bytes()
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Override the input with vrf data of the requested block so it can be returned to the contract program.
                                        input = evm.Context.VRF.Bytes()
                                }</span>
                        }
                        <span class="cov0" title="0">return RunPrecompiledContract(p, input, contract)</span>
                }
                <span class="cov8" title="1">if p := writeCapablePrecompiles[*contract.CodeAddr]; p != nil </span><span class="cov8" title="1">{
                        if res, err := RunWriteCapablePrecompiledContract(p, evm, contract, input); err != nil </span><span class="cov8" title="1">{
                                fmt.Println("RunWriteCapablePrecompiledContract error:", err)
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                return res, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">for _, interpreter := range evm.interpreters </span><span class="cov8" title="1">{
                if interpreter.CanRun(contract.Code) </span><span class="cov8" title="1">{
                        if evm.interpreter != interpreter </span><span class="cov0" title="0">{
                                // Ensure that the interpreter pointer is set back
                                // to its current value upon return.
                                defer func(i Interpreter) </span><span class="cov0" title="0">{
                                        evm.interpreter = i
                                }</span>(evm.interpreter)
                                <span class="cov0" title="0">evm.interpreter = interpreter</span>
                        }

                        <span class="cov8" title="1">if evm.ChainConfig().IsDataCopyFixEpoch(evm.EpochNumber) </span><span class="cov8" title="1">{
                                contract.WithDataCopyFix = true
                        }</span>
                        <span class="cov8" title="1">return interpreter.Run(contract, input, readOnly)</span>

                }
        }
        <span class="cov0" title="0">return nil, ErrNoCompatibleInterpreter</span>
}

// Context provides the EVM with auxiliary information. Once provided
// it shouldn't be modified.
type Context struct {
        // CanTransfer returns whether the account contains
        // sufficient ether to transfer the value
        CanTransfer CanTransferFunc
        // Transfer transfers ether from one account to the other
        Transfer TransferFunc
        // GetHash returns the hash corresponding to n
        GetHash GetHashFunc
        // GetVRF returns the VRF corresponding to n
        GetVRF GetVRFFunc

        // IsValidator determines whether the address corresponds to a validator or a smart contract
        // true: is a validator address; false: is smart contract address
        IsValidator IsValidatorFunc

        // Message information
        Origin   common.Address // Provides information for ORIGIN
        GasPrice *big.Int       // Provides information for GASPRICE

        // Block information
        Coinbase    common.Address // Provides information for COINBASE
        GasLimit    uint64         // Provides information for GASLIMIT
        BlockNumber *big.Int       // Provides information for NUMBER
        EpochNumber *big.Int       // Provides information for EPOCH
        Time        *big.Int       // Provides information for TIME
        VRF         common.Hash    // Provides information for VRF

        TxType types.TransactionType

        CreateValidator CreateValidatorFunc
        EditValidator         EditValidatorFunc
        Delegate        DelegateFunc
        Undelegate      UndelegateFunc
        CollectRewards  CollectRewardsFunc

        // staking precompile checks this before proceeding forward
        ShardID                                        uint32
}

// EVM is the Ethereum Virtual Machine base object and provides
// the necessary tools to run a contract on the given state with
// the provided context. It should be noted that any error
// generated through any of the calls should be considered a
// revert-state-and-consume-all-gas operation, no checks on
// specific errors should ever be performed. The interpreter makes
// sure that any errors generated are to be considered faulty code.
//
// The EVM should never be reused and is not thread safe.
type EVM struct {
        // Context provides auxiliary blockchain related information
        Context
        // DB gives access to the underlying state
        StateDB StateDB
        // Depth is the current call stack
        depth int

        // chainConfig contains information about the current chain
        chainConfig *params.ChainConfig
        // chain rules contains the chain rules for the current epoch
        chainRules params.Rules
        // virtual machine configuration options used to initialise the
        // evm.
        vmConfig Config
        // global (to this context) ethereum virtual machine
        // used throughout the execution of the tx.
        interpreters []Interpreter
        interpreter  Interpreter
        // abort is used to abort the EVM calling operations
        // NOTE: must be set atomically
        abort int32
        // callGasTemp holds the gas available for the current call. This is needed because the
        // available gas is calculated in gasCall* according to the 63/64 rule and later
        // applied in opCall*.
        callGasTemp uint64
        // stored temporarily by stakingPrecompile and cleared immediately after return
        // (although the EVM object itself is ephemeral)
        StakeMsgs []stakingTypes.StakeMsg
}

// NewEVM returns a new EVM. The returned EVM is not thread safe and should
// only ever be used *once*.
func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM <span class="cov8" title="1">{
        evm := &amp;EVM{
                Context:      ctx,
                StateDB:      statedb,
                vmConfig:     vmConfig,
                chainConfig:  chainConfig,
                chainRules:   chainConfig.Rules(ctx.EpochNumber),
                interpreters: make([]Interpreter, 0, 1),
        }

        //if chainConfig.IsS3(ctx.EpochNumber) {
        //        to be implemented by EVM-C and Wagon PRs.
        //        if vmConfig.EWASMInterpreter != "" {
        //         extIntOpts := strings.Split(vmConfig.EWASMInterpreter, ":")
        //         path := extIntOpts[0]
        //         options := []string{}
        //         if len(extIntOpts) &gt; 1 {
        //           options = extIntOpts[1..]
        //         }
        //         evm.interpreters = append(evm.interpreters, NewEVMVCInterpreter(evm, vmConfig, options))
        //        } else {
        //                evm.interpreters = append(evm.interpreters, NewEWASMInterpreter(evm, vmConfig))
        //        }
        //        panic("No supported ewasm interpreter yet.")
        //}

        // vmConfig.EVMInterpreter will be used by EVM-C, it won't be checked here
        // as we always want to have the built-in EVM as the failover option.
        evm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig))
        evm.interpreter = evm.interpreters[0]

        return evm
}</span>

// Cancel cancels any running EVM operation. This may be called concurrently and
// it's safe to be called multiple times.
func (evm *EVM) Cancel() <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;evm.abort, 1)
}</span>

// Cancelled returns true if Cancel has been called
func (evm *EVM) Cancelled() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;evm.abort) == 1
}</span>

// Interpreter returns the current interpreter
func (evm *EVM) Interpreter() Interpreter <span class="cov0" title="0">{
        return evm.interpreter
}</span>

// Call executes the contract associated with the addr with the given input as
// parameters. It also handles any necessary value transfer required and takes
// the necessary steps to create accounts and reverses the state in case of an
// execution error or failed value transfer.
func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) <span class="cov8" title="1">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>

        // Fail if we're trying to execute above the call depth limit
        <span class="cov8" title="1">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>

        <span class="cov8" title="1">txType := evm.Context.TxType

        // Fail if we're trying to transfer more than the available balance
        if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) </span><span class="cov0" title="0">{
                return nil, gas, ErrInsufficientBalance
        }</span>

        <span class="cov8" title="1">var (
                to       = AccountRef(addr)
                snapshot = evm.StateDB.Snapshot()
        )
        if !evm.StateDB.Exist(addr) &amp;&amp; txType != types.SubtractionOnly </span><span class="cov8" title="1">{
                precompiles := PrecompiledContractsHomestead
                writeCapablePrecompiles := make(map[common.Address]WriteCapablePrecompiledContract)
                if evm.ChainConfig().IsS3(evm.EpochNumber) </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsByzantium
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsIstanbul </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsIstanbul
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsVRF </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsVRF
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsSHA3 </span><span class="cov8" title="1">{
                        precompiles = PrecompiledContractsSHA3FIPS
                }</span>
                <span class="cov8" title="1">if evm.chainRules.IsStakingPrecompile </span><span class="cov8" title="1">{
                        writeCapablePrecompiles = WriteCapablePrecompiledContracts
                }</span>

                <span class="cov8" title="1">if writeCapablePrecompiles[addr] == nil &amp;&amp; precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsS3(evm.EpochNumber) &amp;&amp; value.Sign() == 0 </span><span class="cov0" title="0">{
                        // Calling a non existing account, don't do anything, but ping the tracer
                        if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                                evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)
                                evm.vmConfig.Tracer.CaptureEnd(ret, 0, 0, nil)
                        }</span>
                        <span class="cov0" title="0">return nil, gas, nil</span>
                }
                <span class="cov8" title="1">evm.StateDB.CreateAccount(addr)</span>
        }
        <span class="cov8" title="1">evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value, txType)

        codeHash := evm.StateDB.GetCodeHash(addr)
        code := evm.StateDB.GetCode(addr)
        // If address is a validator address, then it's not a smart contract address
        // we don't use its code and codeHash fields
        if evm.Context.IsValidator(evm.StateDB, addr) </span><span class="cov8" title="1">{
                if evm.chainRules.IsStakingPrecompile </span><span class="cov8" title="1">{
                        // it contains validator details and code
                        wrapper, err := evm.StateDB.ValidatorWrapperCopy(addr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, gas, err
                        }</span>
                        <span class="cov8" title="1">code = wrapper.ContractCode
                        codeHash = crypto.Keccak256Hash(code)</span>
                } else<span class="cov8" title="1"> {
                        codeHash = emptyCodeHash
                        code = nil
                }</span>
        }
        // Initialise a new contract and set the code that is to be used by the EVM.
        // The contract is a scoped environment for this execution context only.
        <span class="cov8" title="1">contract := NewContract(caller, to, value, gas)
        contract.SetCallCode(&amp;addr, codeHash, code)

        // Even if the account has no code, we need to continue because it might be a precompile
        start := time.Now()

        // Capture the tracer start/end events in debug mode
        if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)

                defer func() </span><span class="cov0" title="0">{ // Lazy evaluation of the parameters
                        evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)
                }</span>()
        }
        <span class="cov8" title="1">ret, err = run(evm, contract, input, false)

        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're in homestead this also counts for code storage gas errors.
        if err != nil </span><span class="cov8" title="1">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov8" title="1">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov8" title="1">return ret, contract.Gas, err</span>
}

// CallCode executes the contract associated with the addr with the given input
// as parameters. It also handles any necessary value transfer required and takes
// the necessary steps to create accounts and reverses the state in case of an
// execution error or failed value transfer.
//
// CallCode differs from Call in the sense that it executes the given address'
// code with the caller as context.
func (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) <span class="cov0" title="0">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>

        // Fail if we're trying to execute above the call depth limit
        <span class="cov0" title="0">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>
        // Fail if we're trying to transfer more than the available balance
        <span class="cov0" title="0">if !evm.CanTransfer(evm.StateDB, caller.Address(), value) </span><span class="cov0" title="0">{
                return nil, gas, ErrInsufficientBalance
        }</span>

        <span class="cov0" title="0">var (
                snapshot = evm.StateDB.Snapshot()
                to       = AccountRef(caller.Address())
        )
        // initialise a new contract and set the code that is to be used by the
        // EVM. The contract is a scoped environment for this execution context
        // only.
        contract := NewContract(caller, to, value, gas)
        contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        ret, err = run(evm, contract, input, false)
        if err != nil </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov0" title="0">return ret, contract.Gas, err</span>
}

// DelegateCall executes the contract associated with the addr with the given input
// as parameters. It reverses the state in case of an execution error.
//
// DelegateCall differs from CallCode in the sense that it executes the given address'
// code with the caller as context and the caller is set to the caller of the caller.
func (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) <span class="cov0" title="0">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>
        // Fail if we're trying to execute above the call depth limit
        <span class="cov0" title="0">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>

        <span class="cov0" title="0">var (
                snapshot = evm.StateDB.Snapshot()
                to       = AccountRef(caller.Address())
        )

        // Initialise a new contract and make initialise the delegate values
        contract := NewContract(caller, to, nil, gas).AsDelegate()
        contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        ret, err = run(evm, contract, input, false)
        if err != nil </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov0" title="0">return ret, contract.Gas, err</span>
}

// StaticCall executes the contract associated with the addr with the given input
// as parameters while disallowing any modifications to the state during the call.
// Opcodes that attempt to perform such modifications will result in exceptions
// instead of performing the modifications.
func (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) <span class="cov0" title="0">{
        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, gas, nil
        }</span>
        // Fail if we're trying to execute above the call depth limit
        <span class="cov0" title="0">if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, gas, ErrDepth
        }</span>

        <span class="cov0" title="0">var (
                to       = AccountRef(addr)
                snapshot = evm.StateDB.Snapshot()
        )
        // Initialise a new contract and set the code that is to be used by the
        // EVM. The contract is a scoped environment for this execution context
        // only.
        contract := NewContract(caller, to, new(big.Int), gas)
        contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))

        // We do an AddBalance of zero here, just in order to trigger a touch.
        // This doesn't matter on Mainnet, where all empties are gone at the time of Byzantium,
        // but is the correct thing to do and matters on other networks, in tests, and potential
        // future scenarios
        evm.StateDB.AddBalance(addr, bigZero)

        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're in Homestead this also counts for code storage gas errors.
        ret, err = run(evm, contract, input, true)
        if err != nil </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        <span class="cov0" title="0">return ret, contract.Gas, err</span>
}

type codeAndHash struct {
        code []byte
        hash common.Hash
}

func (c *codeAndHash) Hash() common.Hash <span class="cov0" title="0">{
        if c.hash == (common.Hash{}) </span><span class="cov0" title="0">{
                c.hash = crypto.Keccak256Hash(c.code)
        }</span>
        <span class="cov0" title="0">return c.hash</span>
}

// create creates a new contract using code as deployment code.
func (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) <span class="cov0" title="0">{
        // Depth check execution. Fail if we're trying to execute above the
        // limit.
        if evm.depth &gt; int(params.CallCreateDepth) </span><span class="cov0" title="0">{
                return nil, common.Address{}, gas, ErrDepth
        }</span>
        <span class="cov0" title="0">if !evm.CanTransfer(evm.StateDB, caller.Address(), value) </span><span class="cov0" title="0">{
                return nil, common.Address{}, gas, ErrInsufficientBalance
        }</span>
        <span class="cov0" title="0">nonce := evm.StateDB.GetNonce(caller.Address())
        evm.StateDB.SetNonce(caller.Address(), nonce+1)

        // Ensure there's no existing contract already at the designated address
        contractHash := evm.StateDB.GetCodeHash(address)
        if evm.StateDB.GetNonce(address) != 0 || (contractHash != (common.Hash{}) &amp;&amp; contractHash != emptyCodeHash) </span><span class="cov0" title="0">{
                return nil, common.Address{}, 0, ErrContractAddressCollision
        }</span>
        // Create a new account on the state
        <span class="cov0" title="0">snapshot := evm.StateDB.Snapshot()
        evm.StateDB.CreateAccount(address)
        if evm.ChainConfig().IsEIP155(evm.EpochNumber) </span><span class="cov0" title="0">{
                evm.StateDB.SetNonce(address, 1)
        }</span>
        <span class="cov0" title="0">evm.Transfer(evm.StateDB, caller.Address(), address, value, types.SameShardTx)

        // initialise a new contract and set the code that is to be used by the
        // EVM. The contract is a scoped environment for this execution context
        // only.
        contract := NewContract(caller, AccountRef(address), value, gas)
        contract.SetCodeOptionalHash(&amp;address, codeAndHash)

        if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 </span><span class="cov0" title="0">{
                return nil, address, gas, nil
        }</span>

        <span class="cov0" title="0">if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                evm.vmConfig.Tracer.CaptureStart(evm, caller.Address(), address, true, codeAndHash.code, gas, value)
        }</span>
        <span class="cov0" title="0">start := time.Now()

        ret, err := run(evm, contract, nil, false)

        // check whether the max code size has been exceeded
        maxCodeSizeExceeded := evm.ChainConfig().IsEIP155(evm.EpochNumber) &amp;&amp; len(ret) &gt; params.MaxCodeSize
        // if the contract creation ran successfully and no errors were returned
        // calculate the gas required to store the code. If the code could not
        // be stored due to not enough gas set an error and let it be handled
        // by the error checking condition below.
        if err == nil &amp;&amp; !maxCodeSizeExceeded </span><span class="cov0" title="0">{
                createDataGas := uint64(len(ret)) * params.CreateDataGas
                if contract.UseGas(createDataGas) </span><span class="cov0" title="0">{
                        evm.StateDB.SetCode(address, ret)
                }</span> else<span class="cov0" title="0"> {
                        err = ErrCodeStoreOutOfGas
                }</span>
        }

        // When an error was returned by the EVM or when setting the creation code
        // above we revert to the snapshot and consume any gas remaining. Additionally
        // when we're in homestead this also counts for code storage gas errors.
        <span class="cov0" title="0">if maxCodeSizeExceeded || (err != nil &amp;&amp; (evm.ChainConfig().IsS3(evm.EpochNumber) || err != ErrCodeStoreOutOfGas)) </span><span class="cov0" title="0">{
                evm.StateDB.RevertToSnapshot(snapshot)
                if err != ErrExecutionReverted </span><span class="cov0" title="0">{
                        contract.UseGas(contract.Gas)
                }</span>
        }
        // Assign err if contract code size exceeds the max while the err is still empty.
        <span class="cov0" title="0">if maxCodeSizeExceeded &amp;&amp; err == nil </span><span class="cov0" title="0">{
                err = errMaxCodeSizeExceeded
        }</span>
        <span class="cov0" title="0">if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 </span><span class="cov0" title="0">{
                evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)
        }</span>
        <span class="cov0" title="0">return ret, address, contract.Gas, err</span>

}

// Create creates a new contract using code as deployment code.
func (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) <span class="cov0" title="0">{
        contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))
        return evm.create(caller, &amp;codeAndHash{code: code}, gas, value, contractAddr)
}</span>

// Create2 creates a new contract using code as deployment code.
//
// The different between Create2 with Create is Create2 uses sha3(0xff ++ msg.sender ++ salt ++ sha3(init_code))[12:]
// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.
func (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) <span class="cov0" title="0">{
        codeAndHash := &amp;codeAndHash{code: code}
        contractAddr = crypto.CreateAddress2(caller.Address(), common.BigToHash(salt), codeAndHash.Hash().Bytes())
        return evm.create(caller, codeAndHash, gas, endowment, contractAddr)
}</span>

// ChainConfig returns the environment's chain configuration
func (evm *EVM) ChainConfig() *params.ChainConfig <span class="cov8" title="1">{ return evm.chainConfig }</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package bls

import (
        "bytes"
        "encoding/hex"
        "math/big"

        "github.com/harmony-one/bls/ffi/go/bls"
        "github.com/pkg/errors"
)

var (
        emptyBLSPubKey = SerializedPublicKey{}
        emptyBLSSignature = SerializedSignature{}
)

// PublicKeySizeInBytes ..
const (
        PublicKeySizeInBytes    = 48
        BLSSignatureSizeInBytes = 96
)

// PrivateKeyWrapper combines the bls private key and the corresponding public key
type PrivateKeyWrapper struct {
        Pri *bls.SecretKey
        Pub *PublicKeyWrapper
}

// PublicKeyWrapper defines the bls public key in both serialized and
// deserialized form.
type PublicKeyWrapper struct {
        Bytes  SerializedPublicKey
        Object *bls.PublicKey
}

// WrapperFromPrivateKey makes a PrivateKeyWrapper from bls secret key
func WrapperFromPrivateKey(pri *bls.SecretKey) PrivateKeyWrapper <span class="cov8" title="1">{
        pub := pri.GetPublicKey()
        pubBytes := FromLibBLSPublicKeyUnsafe(pub)
        return PrivateKeyWrapper{
                Pri: pri,
                Pub: &amp;PublicKeyWrapper{
                        Bytes:  *pubBytes,
                        Object: pub,
                },
        }
}</span>

// SerializedPublicKey defines the serialized bls public key
type SerializedPublicKey [PublicKeySizeInBytes]byte

// SerializedSignature defines the bls signature
type SerializedSignature [BLSSignatureSizeInBytes]byte

// Big ..
func (pk SerializedPublicKey) Big() *big.Int <span class="cov8" title="1">{
        return new(big.Int).SetBytes(pk[:])
}</span>

// IsEmpty returns whether the bls public key is empty 0 bytes
func (pk SerializedPublicKey) IsEmpty() bool <span class="cov0" title="0">{
        return bytes.Equal(pk[:], emptyBLSPubKey[:])
}</span>

// Hex returns the hex string of bls public key
func (pk SerializedPublicKey) Hex() string <span class="cov8" title="1">{
        return hex.EncodeToString(pk[:])
}</span>

// MarshalText so that we can use this as JSON printable when used as
// key in a map
func (pk SerializedPublicKey) MarshalText() (text []byte, err error) <span class="cov8" title="1">{
        text = make([]byte, BLSSignatureSizeInBytes)
        hex.Encode(text, pk[:])
        return text, nil
}</span>

// FromLibBLSPublicKeyUnsafe could give back nil, use only in cases when
// have invariant that return value won't be nil
func FromLibBLSPublicKeyUnsafe(key *bls.PublicKey) *SerializedPublicKey <span class="cov8" title="1">{
        result := &amp;SerializedPublicKey{}
        if err := result.FromLibBLSPublicKey(key); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return result</span>
}

// FromLibBLSPublicKey replaces the key contents with the given key,
func (pk *SerializedPublicKey) FromLibBLSPublicKey(key *bls.PublicKey) error <span class="cov8" title="1">{
        bytes := key.Serialize()
        if len(bytes) != len(pk) </span><span class="cov0" title="0">{
                return errors.Errorf(
                        "key size (BLS) size mismatch, expected %d have %d", len(pk), len(bytes),
                )
        }</span>
        <span class="cov8" title="1">copy(pk[:], bytes)
        return nil</span>
}

// SeparateSigAndMask parse the commig signature data into signature and bitmap.
func SeparateSigAndMask(commitSigs []byte) ([]byte, []byte, error) <span class="cov8" title="1">{
        if len(commitSigs) &lt; BLSSignatureSizeInBytes </span><span class="cov8" title="1">{
                return nil, nil, errors.Errorf("no mask data found in commit sigs: %x", commitSigs)
        }</span>
        //#### Read payload data from committed msg
        <span class="cov0" title="0">aggSig := make([]byte, BLSSignatureSizeInBytes)
        bitmap := make([]byte, len(commitSigs)-BLSSignatureSizeInBytes)
        offset := 0
        copy(aggSig[:], commitSigs[offset:offset+BLSSignatureSizeInBytes])
        offset += BLSSignatureSizeInBytes
        copy(bitmap[:], commitSigs[offset:])
        //#### END Read payload data from committed msg
        return aggSig, bitmap, nil</span>
}

// set bytes but no checks for low or high length
// use only when the length is known to be correct
func (a *SerializedPublicKey) SetBytesUnsafe(b []byte) <span class="cov8" title="1">{
        copy(a[:], b)
}</span>

// set bytes but no checks for low or high length
// use only when the length is known to be correct
func (a *SerializedSignature) SetBytesUnsafe(b []byte) <span class="cov8" title="1">{
        copy(a[:], b)
}</span>

// BytesToSerializedPublicKey returns SerializedPublicKey with value b
// Returns error if length is different from the expected length
func BytesToSerializedPublicKey(b []byte) (SerializedPublicKey, error) <span class="cov8" title="1">{
        if len(b) != PublicKeySizeInBytes </span><span class="cov8" title="1">{
                return emptyBLSPubKey, errors.Errorf(
                        "key size (BLS) size mismatch, expected %d have %d", PublicKeySizeInBytes, len(b),
                )
        }</span>
        <span class="cov8" title="1">var a SerializedPublicKey
        a.SetBytesUnsafe(b)
        return a, nil</span>
}

// BytesToSerializedSignature returns SerializedSignature with value b
// Returns error if length is different from the expected length
func BytesToSerializedSignature(b []byte) (SerializedSignature, error) <span class="cov8" title="1">{
        if len(b) != BLSSignatureSizeInBytes </span><span class="cov8" title="1">{
                return emptyBLSSignature, errors.Errorf(
                        "signature size (BLS) size mismatch, expected %d have %d", BLSSignatureSizeInBytes, len(b),
                )
        }</span>
        <span class="cov8" title="1">var a SerializedSignature
        a.SetBytesUnsafe(b)
        return a, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package params

import (
        "fmt"
        "math/big"
        "sync"

        "github.com/ethereum/go-ethereum/common"
)

// Well-known chain IDs.
var (
        MainnetChainID            = big.NewInt(1)
        TestnetChainID            = big.NewInt(2)
        PangaeaChainID            = big.NewInt(3)
        PartnerChainID            = big.NewInt(4)
        StressnetChainID          = big.NewInt(5)
        TestChainID               = big.NewInt(99)  // not a real network
        AllProtocolChangesChainID = big.NewInt(100) // not a real network

        // EthMainnetShard0ChainID to be reserved unique chain ID for eth compatible chains.
        EthMainnetShard0ChainID            = big.NewInt(1666600000)
        EthTestnetShard0ChainID            = big.NewInt(1666700000)
        EthPangaeaShard0ChainID            = big.NewInt(1666800000)
        EthPartnerShard0ChainID            = big.NewInt(1666900000)
        EthStressnetShard0ChainID          = big.NewInt(1667000000)
        EthTestShard0ChainID               = big.NewInt(1667100000) // not a real network
        EthAllProtocolChangesShard0ChainID = big.NewInt(1667200000) // not a real network
)

// EpochTBD is a large, “not anytime soon” epoch.  It used as a placeholder
// until the exact epoch is decided.
var EpochTBD = big.NewInt(10000000)
var once sync.Once

var (
        // MainnetChainConfig is the chain parameters to run a node on the main network.
        MainnetChainConfig = &amp;ChainConfig{
                ChainID:                    MainnetChainID,
                EthCompatibleChainID:       EthMainnetShard0ChainID,
                EthCompatibleShard0ChainID: EthMainnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(442), // Around Thursday Feb 4th 2020, 10AM PST
                CrossTxEpoch:               big.NewInt(28),
                CrossLinkEpoch:             big.NewInt(186),
                AggregatedRewardEpoch:      big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                StakingEpoch:               big.NewInt(186),
                PreStakingEpoch:            big.NewInt(185),
                QuickUnlockEpoch:           big.NewInt(191),
                FiveSecondsEpoch:           big.NewInt(230),
                TwoSecondsEpoch:            big.NewInt(366), // Around Tuesday Dec 8th 2020, 8AM PST
                SixtyPercentEpoch:          big.NewInt(530), // Around Monday Apr 12th 2021, 22:30 UTC
                RedelegationEpoch:          big.NewInt(290),
                NoEarlyUnlockEpoch:         big.NewInt(530), // Around Monday Apr 12th 2021, 22:30 UTC
                VRFEpoch:                   big.NewInt(631), // Around Wed July 7th 2021
                PrevVRFEpoch:               big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                MinDelegation100Epoch:      big.NewInt(631), // Around Wed July 7th 2021
                MinCommissionRateEpoch:     big.NewInt(631), // Around Wed July 7th 2021
                MinCommissionPromoPeriod:   big.NewInt(100),
                EPoSBound35Epoch:           big.NewInt(631), // Around Wed July 7th 2021
                EIP155Epoch:                big.NewInt(28),
                S3Epoch:                    big.NewInt(28),
                DataCopyFixEpoch:           big.NewInt(689), // Around Wed Sept 15th 2021 with 3.5s block time
                IstanbulEpoch:              big.NewInt(314),
                ReceiptLogEpoch:            big.NewInt(101),
                SHA3Epoch:                  big.NewInt(725), // Around Mon Oct 11 2021, 19:00 UTC
                HIP6And8Epoch:              big.NewInt(725), // Around Mon Oct 11 2021, 19:00 UTC
                StakingPrecompileEpoch:                        EpochTBD,
        }

        // TestnetChainConfig contains the chain parameters to run a node on the harmony test network.
        TestnetChainConfig = &amp;ChainConfig{
                ChainID:                    TestnetChainID,
                EthCompatibleChainID:       EthTestnetShard0ChainID,
                EthCompatibleShard0ChainID: EthTestnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(73290),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(74275),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(16500),
                TwoSecondsEpoch:            big.NewInt(73000),
                SixtyPercentEpoch:          big.NewInt(73282),
                RedelegationEpoch:          big.NewInt(36500),
                NoEarlyUnlockEpoch:         big.NewInt(73580),
                VRFEpoch:                   big.NewInt(73880),
                PrevVRFEpoch:               big.NewInt(74384),
                MinDelegation100Epoch:      big.NewInt(73880),
                MinCommissionRateEpoch:     big.NewInt(73880),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(73880),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(74412),
                IstanbulEpoch:              big.NewInt(43800),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(74570),
                HIP6And8Epoch:              big.NewInt(74570),
                StakingPrecompileEpoch:                        EpochTBD,
        }

        // PangaeaChainConfig contains the chain parameters for the Pangaea network.
        // All features except for CrossLink are enabled at launch.
        PangaeaChainConfig = &amp;ChainConfig{
                ChainID:                    PangaeaChainID,
                EthCompatibleChainID:       EthPangaeaShard0ChainID,
                EthCompatibleShard0ChainID: EthPangaeaShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(0),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:                        big.NewInt(0),
        }

        // PartnerChainConfig contains the chain parameters for the Partner network.
        // All features except for CrossLink are enabled at launch.
        PartnerChainConfig = &amp;ChainConfig{
                ChainID:                    PartnerChainID,
                EthCompatibleChainID:       EthPartnerShard0ChainID,
                EthCompatibleShard0ChainID: EthPartnerShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(0),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:                        big.NewInt(0),
        }

        // StressnetChainConfig contains the chain parameters for the Stress test network.
        // All features except for CrossLink are enabled at launch.
        StressnetChainConfig = &amp;ChainConfig{
                ChainID:                    StressnetChainID,
                EthCompatibleChainID:       EthStressnetShard0ChainID,
                EthCompatibleShard0ChainID: EthStressnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(1),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(0),
                SixtyPercentEpoch:          big.NewInt(10),
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              big.NewInt(0),
                StakingPrecompileEpoch:                        big.NewInt(0),
        }

        // LocalnetChainConfig contains the chain parameters to run for local development.
        LocalnetChainConfig = &amp;ChainConfig{
                ChainID:                    TestnetChainID,
                EthCompatibleChainID:       EthTestnetShard0ChainID,
                EthCompatibleShard0ChainID: EthTestnetShard0ChainID,
                EthCompatibleEpoch:         big.NewInt(0),
                CrossTxEpoch:               big.NewInt(0),
                CrossLinkEpoch:             big.NewInt(2),
                AggregatedRewardEpoch:      big.NewInt(3),
                StakingEpoch:               big.NewInt(2),
                PreStakingEpoch:            big.NewInt(0),
                QuickUnlockEpoch:           big.NewInt(0),
                FiveSecondsEpoch:           big.NewInt(0),
                TwoSecondsEpoch:            big.NewInt(3),
                SixtyPercentEpoch:          EpochTBD, // Never enable it for localnet as localnet has no external validator setup
                RedelegationEpoch:          big.NewInt(0),
                NoEarlyUnlockEpoch:         big.NewInt(0),
                VRFEpoch:                   big.NewInt(0),
                PrevVRFEpoch:               big.NewInt(0),
                MinDelegation100Epoch:      big.NewInt(0),
                MinCommissionRateEpoch:     big.NewInt(0),
                MinCommissionPromoPeriod:   big.NewInt(10),
                EPoSBound35Epoch:           big.NewInt(0),
                EIP155Epoch:                big.NewInt(0),
                S3Epoch:                    big.NewInt(0),
                DataCopyFixEpoch:           big.NewInt(0),
                IstanbulEpoch:              big.NewInt(0),
                ReceiptLogEpoch:            big.NewInt(0),
                SHA3Epoch:                  big.NewInt(0),
                HIP6And8Epoch:              EpochTBD, // Never enable it for localnet as localnet has no external validator setup
                StakingPrecompileEpoch:                        big.NewInt(0),
        }

        // AllProtocolChanges ...
        // This configuration is intentionally not using keyed fields to force anyone
        // adding flags to the config to also have to set these fields.
        AllProtocolChanges = &amp;ChainConfig{
                AllProtocolChangesChainID,          // ChainID
                EthAllProtocolChangesShard0ChainID, // EthCompatibleChainID
                EthAllProtocolChangesShard0ChainID, // EthCompatibleShard0ChainID
                big.NewInt(0),                      // EthCompatibleEpoch
                big.NewInt(0),                      // CrossTxEpoch
                big.NewInt(0),                      // CrossLinkEpoch
                big.NewInt(0),                      // AggregatedRewardEpoch
                big.NewInt(0),                      // StakingEpoch
                big.NewInt(0),                      // PreStakingEpoch
                big.NewInt(0),                      // QuickUnlockEpoch
                big.NewInt(0),                      // FiveSecondsEpoch
                big.NewInt(0),                      // TwoSecondsEpoch
                big.NewInt(0),                      // SixtyPercentEpoch
                big.NewInt(0),                      // RedelegationEpoch
                big.NewInt(0),                      // NoEarlyUnlockEpoch
                big.NewInt(0),                      // VRFEpoch
                big.NewInt(0),                      // PrevVRFEpoch
                big.NewInt(0),                      // MinDelegation100Epoch
                big.NewInt(0),                      // MinCommissionRateEpoch
                big.NewInt(10),                     // MinCommissionPromoPeriod
                big.NewInt(0),                      // EPoSBound35Epoch
                big.NewInt(0),                      // EIP155Epoch
                big.NewInt(0),                      // S3Epoch
                big.NewInt(0),                      // DataCopyFixEpoch
                big.NewInt(0),                      // IstanbulEpoch
                big.NewInt(0),                      // ReceiptLogEpoch
                big.NewInt(0),                      // SHA3Epoch
                big.NewInt(0),                      // HIP6And8Epoch
                big.NewInt(0),                                                                                        // StakingPrecompileEpoch
        }

        // TestChainConfig ...
        // This configuration is intentionally not using keyed fields to force anyone
        // adding flags to the config to also have to set these fields.
        TestChainConfig = &amp;ChainConfig{
                TestChainID,          // ChainID
                EthTestShard0ChainID, // EthCompatibleChainID
                EthTestShard0ChainID, // EthCompatibleShard0ChainID
                big.NewInt(0),        // EthCompatibleEpoch
                big.NewInt(0),        // CrossTxEpoch
                big.NewInt(0),        // CrossLinkEpoch
                big.NewInt(0),        // AggregatedRewardEpoch
                big.NewInt(0),        // StakingEpoch
                big.NewInt(0),        // PreStakingEpoch
                big.NewInt(0),        // QuickUnlockEpoch
                big.NewInt(0),        // FiveSecondsEpoch
                big.NewInt(0),        // TwoSecondsEpoch
                big.NewInt(0),        // SixtyPercentEpoch
                big.NewInt(0),        // RedelegationEpoch
                big.NewInt(0),        // NoEarlyUnlockEpoch
                big.NewInt(0),        // VRFEpoch
                big.NewInt(0),        // PrevVRFEpoch
                big.NewInt(0),        // MinDelegation100Epoch
                big.NewInt(0),        // MinCommissionRateEpoch
                big.NewInt(10),       // MinCommissionPromoPeriod
                big.NewInt(0),        // EPoSBound35Epoch
                big.NewInt(0),        // EIP155Epoch
                big.NewInt(0),        // S3Epoch
                big.NewInt(0),        // DataCopyFixEpoch
                big.NewInt(0),        // IstanbulEpoch
                big.NewInt(0),        // ReceiptLogEpoch
                big.NewInt(0),        // SHA3Epoch
                big.NewInt(0),        // HIP6And8Epoch
                big.NewInt(0),        // StakingPrecompileEpoch
        }

        // TestRules ...
        TestRules = TestChainConfig.Rules(new(big.Int))
)

// TrustedCheckpoint represents a set of post-processed trie roots (CHT and
// BloomTrie) associated with the appropriate section index and head hash. It is
// used to start light syncing from this checkpoint and avoid downloading the
// entire header chain while still being able to securely access old headers/logs.
type TrustedCheckpoint struct {
        Name         string      `json:"-"`
        SectionIndex uint64      `json:"sectionIndex"`
        SectionHead  common.Hash `json:"sectionHead"`
        CHTRoot      common.Hash `json:"chtRoot"`
        BloomRoot    common.Hash `json:"bloomRoot"`
}

// ChainConfig is the core config which determines the blockchain settings.
//
// ChainConfig is stored in the database on a per block basis. This means
// that any network, identified by its genesis block, can have its own
// set of configuration options.
type ChainConfig struct {
        // ChainId identifies the current chain and is used for replay protection
        ChainID *big.Int `json:"chain-id"`

        // EthCompatibleChainID identifies the chain id used for ethereum compatible transactions
        EthCompatibleChainID *big.Int `json:"eth-compatible-chain-id"`

        // EthCompatibleShard0ChainID identifies the shard 0 chain id used for ethereum compatible transactions
        EthCompatibleShard0ChainID *big.Int `json:"eth-compatible-shard-0-chain-id"`

        // EthCompatibleEpoch is the epoch where ethereum-compatible transaction starts being
        // processed.
        EthCompatibleEpoch *big.Int `json:"eth-compatible-epoch,omitempty"`

        // CrossTxEpoch is the epoch where cross-shard transaction starts being
        // processed.
        CrossTxEpoch *big.Int `json:"cross-tx-epoch,omitempty"`

        // CrossLinkEpoch is the epoch where beaconchain starts containing
        // cross-shard links.
        CrossLinkEpoch *big.Int `json:"cross-link-epoch,omitempty"`

        // AggregatedRewardEpoch is the epoch when block rewards are distributed every 64 blocks
        AggregatedRewardEpoch *big.Int `json:"aggregated-reward-epoch,omitempty"`

        // StakingEpoch is the epoch when shard assign takes staking into account
        StakingEpoch *big.Int `json:"staking-epoch,omitempty"`

        // PreStakingEpoch is the epoch we allow staking transactions
        PreStakingEpoch *big.Int `json:"prestaking-epoch,omitempty"`

        // QuickUnlockEpoch is the epoch when undelegation will be unlocked at the current epoch
        QuickUnlockEpoch *big.Int `json:"quick-unlock-epoch,omitempty"`

        // FiveSecondsEpoch is the epoch when block time is reduced to 5 seconds
        // and block rewards adjusted to 17.5 ONE/block
        FiveSecondsEpoch *big.Int `json:"five-seconds-epoch,omitempty"`

        // TwoSecondsEpoch is the epoch when block time is reduced to 2 seconds
        // and block rewards adjusted to 7 ONE/block
        TwoSecondsEpoch *big.Int `json:"two-seconds-epoch,omitempty"`

        // SixtyPercentEpoch is the epoch when internal voting power reduced from 68% to 60%
        SixtyPercentEpoch *big.Int `json:"sixty-percent-epoch,omitempty"`

        // RedelegationEpoch is the epoch when redelegation is supported and undelegation locking time
        // is restored to 7 epoch
        RedelegationEpoch *big.Int `json:"redelegation-epoch,omitempty"`

        // NoEarlyUnlockEpoch is the epoch when the early unlock of undelegated token from validators who were elected for
        // more than 7 epochs is disabled
        NoEarlyUnlockEpoch *big.Int `json:"no-early-unlock-epoch,omitempty"`

        // VRFEpoch is the epoch when VRF randomness is enabled
        VRFEpoch *big.Int `json:"vrf-epoch,omitempty"`

        // PrevVRFEpoch is the epoch when previous VRF randomness can be fetched
        PrevVRFEpoch *big.Int `json:"prev-vrf-epoch,omitempty"`

        // MinDelegation100Epoch is the epoch when min delegation is reduced from 1000 ONE to 100 ONE
        MinDelegation100Epoch *big.Int `json:"min-delegation-100-epoch,omitempty"`

        // MinCommissionRateEpoch is the epoch when policy for minimum comission rate of 5% is started
        MinCommissionRateEpoch *big.Int `json:"min-commission-rate-epoch,omitempty"`

        // MinCommissionPromoPeriod is the number of epochs when newly elected validators can have 0% commission
        MinCommissionPromoPeriod *big.Int `json:"commission-promo-period,omitempty"`

        // EPoSBound35Epoch is the epoch when the EPoS bound parameter c is changed from 15% to 35%
        EPoSBound35Epoch *big.Int `json:"epos-bound-35-epoch,omitempty"`

        // EIP155 hard fork epoch (include EIP158 too)
        EIP155Epoch *big.Int `json:"eip155-epoch,omitempty"`

        // S3 epoch is the first epoch containing S3 mainnet and all ethereum update up to Constantinople
        S3Epoch *big.Int `json:"s3-epoch,omitempty"`

        // DataCopyFix epoch is the first epoch containing fix for evm datacopy bug.
        DataCopyFixEpoch *big.Int `json:"data-copy-fix-epoch,omitempty"`

        // Istanbul epoch
        IstanbulEpoch *big.Int `json:"istanbul-epoch,omitempty"`

        // ReceiptLogEpoch is the first epoch support receiptlog
        ReceiptLogEpoch *big.Int `json:"receipt-log-epoch,omitempty"`

        // IsSHA3Epoch is the first epoch in supporting SHA3 FIPS-202 standard
        SHA3Epoch *big.Int `json:"sha3-epoch,omitempty"`

        // IsHIP6And8Epoch is the first epoch to support HIP-6 and HIP-8
        HIP6And8Epoch *big.Int `json:"hip6_8-epoch,omitempty"`

        // StakingPrecompileEpoch is the first epoch to support the staking precompiles
        StakingPrecompileEpoch *big.Int `json:"staking-precompile-epoch,omitempty"`
}

// String implements the fmt.Stringer interface.
func (c *ChainConfig) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("{ChainID: %v EthCompatibleChainID: %v EIP155: %v CrossTx: %v Staking: %v CrossLink: %v ReceiptLog: %v SHA3Epoch: %v StakingPrecompileEpoch: %v}",
                c.ChainID,
                c.EthCompatibleChainID,
                c.EIP155Epoch,
                c.CrossTxEpoch,
                c.StakingEpoch,
                c.CrossLinkEpoch,
                c.ReceiptLogEpoch,
                c.SHA3Epoch,
                c.StakingPrecompileEpoch,
        )
}</span>

// IsEIP155 returns whether epoch is either equal to the EIP155 fork epoch or greater.
func (c *ChainConfig) IsEIP155(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.EIP155Epoch, epoch)
}</span>

// AcceptsCrossTx returns whether cross-shard transaction is accepted in the
// given epoch.
//
// Note that this is different from comparing epoch against CrossTxEpoch.
// Cross-shard transaction is accepted from CrossTxEpoch+1 and on, in order to
// allow for all shards to roll into CrossTxEpoch and become able to handle
// ingress receipts.  In other words, cross-shard transaction fields are
// introduced and ingress receipts are processed at CrossTxEpoch, but the shard
// does not accept cross-shard transactions from clients until CrossTxEpoch+1.
func (c *ChainConfig) AcceptsCrossTx(epoch *big.Int) bool <span class="cov8" title="1">{
        crossTxEpoch := new(big.Int).Add(c.CrossTxEpoch, common.Big1)
        return isForked(crossTxEpoch, epoch)
}</span>

// HasCrossTxFields returns whether blocks in the given epoch includes
// cross-shard transaction fields.
func (c *ChainConfig) HasCrossTxFields(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.CrossTxEpoch, epoch)
}</span>

// IsEthCompatible determines whether it is ethereum compatible epoch
func (c *ChainConfig) IsEthCompatible(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.EthCompatibleEpoch, epoch)
}</span>

// IsAggregatedRewardEpoch determines whether it is the epoch when rewards are distributed every 64 blocks
func (c *ChainConfig) IsAggregatedRewardEpoch(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.AggregatedRewardEpoch, epoch)
}</span>

// IsStaking determines whether it is staking epoch
func (c *ChainConfig) IsStaking(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.StakingEpoch, epoch)
}</span>

// IsFiveSeconds determines whether it is the epoch to change to 5 seconds block time
func (c *ChainConfig) IsFiveSeconds(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.FiveSecondsEpoch, epoch)
}</span>

// IsTwoSeconds determines whether it is the epoch to change to 3 seconds block time
func (c *ChainConfig) IsTwoSeconds(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.TwoSecondsEpoch, epoch)
}</span>

// IsSixtyPercent determines whether it is the epoch to reduce internal voting power to 60%
func (c *ChainConfig) IsSixtyPercent(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.SixtyPercentEpoch, epoch)
}</span>

// IsRedelegation determines whether it is the epoch to support redelegation
func (c *ChainConfig) IsRedelegation(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.RedelegationEpoch, epoch)
}</span>

// IsNoEarlyUnlock determines whether it is the epoch to stop early unlock
func (c *ChainConfig) IsNoEarlyUnlock(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.NoEarlyUnlockEpoch, epoch)
}</span>

// IsVRF determines whether it is the epoch to enable vrf
func (c *ChainConfig) IsVRF(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.VRFEpoch, epoch)
}</span>

// IsPrevVRF determines whether it is the epoch to enable previous vrf
func (c *ChainConfig) IsPrevVRF(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.PrevVRFEpoch, epoch)
}</span>

// IsMinDelegation100 determines whether it is the epoch to reduce min delegation to 100
func (c *ChainConfig) IsMinDelegation100(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.MinDelegation100Epoch, epoch)
}</span>

// IsMinCommissionRate determines whether it is the epoch to start the policy of 5% min commission
func (c *ChainConfig) IsMinCommissionRate(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.MinCommissionRateEpoch, epoch)
}</span>

// IsEPoSBound35 determines whether it is the epoch to extend the EPoS bound to 35%
func (c *ChainConfig) IsEPoSBound35(epoch *big.Int) bool <span class="cov0" title="0">{
        return isForked(c.EPoSBound35Epoch, epoch)
}</span>

// IsPreStaking determines whether staking transactions are allowed
func (c *ChainConfig) IsPreStaking(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.PreStakingEpoch, epoch)
}</span>

// IsQuickUnlock determines whether it's the epoch when the undelegation should be unlocked at end of current epoch
func (c *ChainConfig) IsQuickUnlock(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.QuickUnlockEpoch, epoch)
}</span>

// IsCrossLink returns whether epoch is either equal to the CrossLink fork epoch or greater.
func (c *ChainConfig) IsCrossLink(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.CrossLinkEpoch, epoch)
}</span>

// IsS3 returns whether epoch is either equal to the S3 fork epoch or greater.
func (c *ChainConfig) IsS3(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.S3Epoch, epoch)
}</span>

// IsDataCopyFixEpoch returns whether epoch has the fix for DataCopy evm bug.
func (c *ChainConfig) IsDataCopyFixEpoch(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.DataCopyFixEpoch, epoch)
}</span>

// IsIstanbul returns whether epoch is either equal to the Istanbul fork epoch or greater.
func (c *ChainConfig) IsIstanbul(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.IstanbulEpoch, epoch)
}</span>

// IsReceiptLog returns whether epoch is either equal to the ReceiptLog fork epoch or greater.
func (c *ChainConfig) IsReceiptLog(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.ReceiptLogEpoch, epoch)
}</span>

// IsSHA3 returns whether epoch is either equal to the IsSHA3 fork epoch or greater.
func (c *ChainConfig) IsSHA3(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.SHA3Epoch, epoch)
}</span>

// IsHIP6And8Epoch determines whether it is the epoch to support
// HIP-6: reduce the internal voting power from 60% to 49%
// HIP-8: increase external nodes from 800 to 900
func (c *ChainConfig) IsHIP6And8Epoch(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.HIP6And8Epoch, epoch)
}</span>

// IsStakingPrecompileEpoch determines whether staking
// precompiles are available in the EVM
func (c *ChainConfig) IsStakingPrecompile(epoch *big.Int) bool <span class="cov8" title="1">{
        return isForked(c.StakingPrecompileEpoch, epoch)
}</span>

// UpdateEthChainIDByShard update the ethChainID based on shard ID.
func UpdateEthChainIDByShard(shardID uint32) <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                MainnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(MainnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                TestnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(TestnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                PangaeaChainConfig.EthCompatibleChainID = big.NewInt(0).Add(PangaeaChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                PartnerChainConfig.EthCompatibleChainID = big.NewInt(0).Add(PartnerChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                StressnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(StressnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                LocalnetChainConfig.EthCompatibleChainID = big.NewInt(0).Add(LocalnetChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
                AllProtocolChanges.EthCompatibleChainID = big.NewInt(0).Add(AllProtocolChanges.EthCompatibleChainID, big.NewInt(int64(shardID)))
                TestChainConfig.EthCompatibleChainID = big.NewInt(0).Add(TestChainConfig.EthCompatibleChainID, big.NewInt(int64(shardID)))
        }</span>)
}

// IsEthCompatible returns whether the chainID is for ethereum compatible txn or not
func IsEthCompatible(chainID *big.Int) bool <span class="cov8" title="1">{
        return chainID.Cmp(EthMainnetShard0ChainID) &gt;= 0
}</span>

// GasTable returns the gas table corresponding to the current phase (homestead or homestead reprice).
//
// The returned GasTable's fields shouldn't, under any circumstances, be changed.
func (c *ChainConfig) GasTable(epoch *big.Int) GasTable <span class="cov0" title="0">{
        if epoch == nil </span><span class="cov0" title="0">{
                return GasTableR3
        }</span>
        <span class="cov0" title="0">switch </span>{
        case c.IsS3(epoch):<span class="cov0" title="0">
                return GasTableS3</span>
        default:<span class="cov0" title="0">
                return GasTableR3</span>
        }
}

// isForked returns whether a fork scheduled at epoch s is active at the given head epoch.
func isForked(s, epoch *big.Int) bool <span class="cov8" title="1">{
        if s == nil || epoch == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return s.Cmp(epoch) &lt;= 0</span>
}

// Rules wraps ChainConfig and is merely syntactic sugar or can be used for functions
// that do not have or require information about the block.
//
// Rules is a one time interface meaning that it shouldn't be used in between transition
// phases.
type Rules struct {
        ChainID                                                                                                                                                         *big.Int
        EthChainID                                                                                                                                                      *big.Int
        IsCrossLink, IsEIP155, IsS3, IsReceiptLog, IsIstanbul, IsVRF, IsPrevVRF, IsSHA3, IsStakingPrecompile bool
}

// Rules ensures c's ChainID is not nil.
func (c *ChainConfig) Rules(epoch *big.Int) Rules <span class="cov8" title="1">{
        chainID := c.ChainID
        if chainID == nil </span><span class="cov0" title="0">{
                chainID = new(big.Int)
        }</span>
        <span class="cov8" title="1">ethChainID := c.EthCompatibleChainID
        if ethChainID == nil </span><span class="cov0" title="0">{
                ethChainID = new(big.Int)
        }</span>
        <span class="cov8" title="1">return Rules{
                ChainID:                               new(big.Int).Set(chainID),
                EthChainID:                            new(big.Int).Set(ethChainID),
                IsCrossLink:                           c.IsCrossLink(epoch),
                IsEIP155:                              c.IsEIP155(epoch),
                IsS3:                                  c.IsS3(epoch),
                IsReceiptLog:                                 c.IsReceiptLog(epoch),
                IsIstanbul:                                         c.IsIstanbul(epoch),
                IsVRF:                                 c.IsVRF(epoch),
                IsPrevVRF:                                         c.IsPrevVRF(epoch),
                IsSHA3:                                c.IsSHA3(epoch),
                IsStakingPrecompile: c.IsStakingPrecompile(epoch),
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package staking

import (
  "math/big"
  "strings"

  stakingTypes "github.com/harmony-one/harmony/staking/types"
  "github.com/harmony-one/harmony/accounts/abi"
  "github.com/harmony-one/harmony/numeric"
  "github.com/harmony-one/harmony/crypto/bls"
  "github.com/ethereum/go-ethereum/common"
  "github.com/pkg/errors"
)

var abiStaking abi.ABI

func init() <span class="cov8" title="1">{
        // for commission rates =&gt; solidity does not support floats directly
        // so send commission rates as string
        StakingABIJSON := `
        [
          {
            "name": "CollectRewards",
            "outputs": [],
            "inputs": [
              {
                "type": "uint8",
                "name": "DirectiveUnused",
                "indexed": false
              },
              {
                "type": "address",
                "name": "DelegatorAddress",
                "indexed": false
              }
            ],
            "constant": false,
            "payable": false,
            "type": "function"
          },
          {
            "name": "DelegateOrUndelegate",
            "outputs": [],
            "inputs": [
              {
                "type": "uint8",
                "name": "DirectiveUnused",
                "indexed": false
              },
              {
                "type": "address",
                "name": "DelegatorAddress",
                "indexed": false
              },
              {
                "type": "address",
                "name": "ValidatorAddress",
                "indexed": false
              },
              {
                "type": "uint256",
                "name": "Amount",
                "indexed": false
              }
            ],
            "constant": false,
            "payable": false,
            "type": "function"
          },
          {
            "name": "CreateValidator",
            "outputs": [],
            "inputs": [
              {
                "type": "uint8",
                "name": "DirectiveUnused",
                "indexed": false
              },
              {
                "name": "ValidatorAddress",
                "type": "address",
                "indexed": false
              },
              {
                "components": [
                  {
                    "name": "Name",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "Identity",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "Website",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "SecurityContact",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "Details",
                    "type": "string",
                    "indexed": false
                  }
                ],
                "name": "Description",
                "type": "tuple",
                "indexed": false
              },
              {
                "components": [
                  {
                    "name": "Rate",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "MaxRate",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "MaxChangeRate",
                    "type": "string",
                    "indexed": false
                  }
                ],
                "name": "CommissionRates",
                "type": "tuple",
                "indexed": false
              },
              {
                "name": "MinSelfDelegation",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "MaxTotalDelegation",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "SlotPubKeys",
                "type": "bytes[]",
                "indexed": false
              },
                                {
                "name": "SlotKeySigs",
                "type": "bytes[]",
                "indexed": false
              },
              {
                "name": "Amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "constant": false,
            "payable": false,
            "type": "function"
          },
          {
            "name": "EditValidator",
            "outputs": [],
            "inputs": [
              {
                "type": "uint8",
                "name": "DirectiveUnused",
                "indexed": false
              },
              {
                "name": "ValidatorAddress",
                "type": "address",
                "indexed": false
              },
              {
                "components": [
                  {
                    "name": "Name",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "Identity",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "Website",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "SecurityContact",
                    "type": "string",
                    "indexed": false
                  },
                  {
                    "name": "Details",
                    "type": "string",
                    "indexed": false
                  }
                ],
                "name": "Description",
                "type": "tuple",
                "indexed": false
              },
              {
                "name": "CommissionRate",
                "type": "string",
                "indexed": false
              },
              {
                "name": "MinSelfDelegation",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "MaxTotalDelegation",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "SlotKeyToRemove",
                "type": "bytes",
                "indexed": false
              },
              {
                "name": "SlotKeyToAdd",
                "type": "bytes",
                "indexed": false
              },
                                {
                "name": "SlotKeyToAddSig",
                "type": "bytes",
                "indexed": false
              }
            ],
            "constant": false,
            "payable": false,
            "type": "function"
          }
        ]
        `
        abiStaking, _ = abi.JSON(strings.NewReader(StakingABIJSON))
}</span>

func UnpackFromStakingMethod(methodName string, args map[string]interface{}, input []byte) error <span class="cov8" title="1">{
        if method, ok := abiStaking.Methods[methodName]; ok </span><span class="cov8" title="1">{
                err := method.Inputs.UnpackIntoMap(args, input)
                return err
        }</span> else<span class="cov8" title="1"> {
                // this should never happen, unless you make a typo in the precompiled code
                return errors.Errorf("Key %s is not an ABI method", methodName)
        }</span>
}

func ValidateContractAddress(contractCaller common.Address, args map[string]interface{}, key string) (common.Address, error) <span class="cov8" title="1">{
        address, err := ParseAddressFromKey(args, key)
        if err != nil </span><span class="cov8" title="1">{
                return common.Address{}, err
        }</span>
        <span class="cov8" title="1">if contractCaller != address </span><span class="cov8" title="1">{
                return common.Address{}, errors.Errorf(
                        "[StakingPrecompile] Address mismatch, expected %s have %s",
                        contractCaller.String(), address.String(),
                )
        }</span> else<span class="cov8" title="1"> {
                return address, nil
        }</span>
}

func ParseAddressFromKey(args map[string]interface{}, key string) (common.Address, error) <span class="cov8" title="1">{
        if byteAddress, ok := args[key].([]byte); ok </span><span class="cov8" title="1">{
                address := common.BytesToAddress(byteAddress)
                return address, nil
        }</span> else<span class="cov8" title="1"> if address, ok := args[key].(common.Address); ok </span><span class="cov8" title="1">{
                return address, nil
        }</span> else<span class="cov8" title="1"> {
                return common.Address{}, errors.Errorf("Cannot parse address from %v", args[key])
        }</span>
}

func ParseDescription(args map[string]interface{}) (stakingTypes.Description, error) <span class="cov8" title="1">{
        // mostly the same struct as stakingTypes.Description
        // except the JSON tag for SecurityContact is security-contact there
        // so type assert it through this one
        if description, ok := args["Description"].(struct {
                        Name string "json:\"Name\""
                        Identity string "json:\"Identity\""
                        Website string "json:\"Website\""
                        SecurityContact string "json:\"SecurityContact\""
                        Details string "json:\"Details\""
                }); ok </span><span class="cov8" title="1">{
                        return stakingTypes.Description{
                                description.Name,
                                description.Identity,
                                description.Website,
                                description.SecurityContact,
                                description.Details,
                }, nil
        }</span> else<span class="cov8" title="1"> {
                return stakingTypes.Description{}, errors.Errorf(
                        "Cannot parse Description from %v", args["Description"])
        }</span>
}

func ParseCommissionRates(args map[string]interface{}) (stakingTypes.CommissionRates, error) <span class="cov8" title="1">{
        // CommissionRates here is parsed as containing 3 strings
        // whereas the actual stakingTypes.CommissionRates has numeric.Dec
        // create a new structure on the fly to allow type assertion
        if commissionRates, ok := args["CommissionRates"].(struct {
                        Rate string "json:\"Rate\""
                        MaxRate string "json:\"MaxRate\""
                        MaxChangeRate string "json:\"MaxChangeRate\""
                }); ok </span><span class="cov8" title="1">{
                        rate, err := numeric.NewDecFromStr(commissionRates.Rate)
                        if err != nil </span><span class="cov0" title="0">{
                                return stakingTypes.CommissionRates{}, err
                        }</span>
                        <span class="cov8" title="1">maxRate, err := numeric.NewDecFromStr(commissionRates.MaxRate)
                        if err != nil </span><span class="cov0" title="0">{
                                return stakingTypes.CommissionRates{}, err
                        }</span>
                        <span class="cov8" title="1">maxChangeRate, err := numeric.NewDecFromStr(commissionRates.MaxChangeRate)
                        if err != nil </span><span class="cov0" title="0">{
                                return stakingTypes.CommissionRates{}, err
                        }</span>
                        <span class="cov8" title="1">return stakingTypes.CommissionRates{rate, maxRate, maxChangeRate}, nil</span>
        } else<span class="cov8" title="1"> {
                return stakingTypes.CommissionRates{}, errors.Errorf(
                        "Cannot parse CommissionRates from %v", args["CommissionRates"])
        }</span>
}

func ParseBigIntFromKey(args map[string]interface{}, key string) (*big.Int, error) <span class="cov8" title="1">{
        bigInt, ok := args[key].(*big.Int);
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf(
                        "Cannot parse BigInt from %v", args[key])
        }</span> else<span class="cov8" title="1"> {
                return bigInt, nil
        }</span>
}

func ParseSlotPubKeys(args map[string]interface{}) ([]bls.SerializedPublicKey, error) <span class="cov8" title="1">{
        // cast it into bytes
        pubKeys, ok := args["SlotPubKeys"].([][]byte);
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf(
                        "Cannot parse SlotPubKeys from %v", args["SlotPubKeys"])
        }</span>
        <span class="cov8" title="1">result := make([]bls.SerializedPublicKey, len(pubKeys))
        for i, pubKey := range pubKeys </span><span class="cov8" title="1">{
                if serializedKey, err := bls.BytesToSerializedPublicKey(pubKey); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        result[i] = serializedKey
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func ParseSlotKeySigs(args map[string]interface{}) ([]bls.SerializedSignature, error) <span class="cov8" title="1">{
        // cast it into bytes
        sigs, ok := args["SlotKeySigs"].([][]byte);
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf(
                        "Cannot parse SlotKeySigs from %v", args["SlotKeySigs"])
        }</span>
        <span class="cov8" title="1">result := make([]bls.SerializedSignature, len(sigs))
        for i, sig := range sigs </span><span class="cov8" title="1">{
                if serializedSig, err := bls.BytesToSerializedSignature(sig); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        result[i] = serializedSig
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func ParseSlotPubKeyFromKey(args map[string]interface{}, key string) (*bls.SerializedPublicKey, error) <span class="cov8" title="1">{
        // convert to bytes
        pubKeyBytes, ok := args[key].([]byte);
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf(
                        "Cannot parse SlotPubKey from %v", args[key])
        }</span>
        <span class="cov8" title="1">if result, err := bls.BytesToSerializedPublicKey(pubKeyBytes); err == nil </span><span class="cov8" title="1">{
                return &amp;result, nil
        }</span> else<span class="cov8" title="1"> {
                return nil, err
        }</span>
}

func ParseSlotKeySigFromKey(args map[string]interface{}, key string) (*bls.SerializedSignature, error) <span class="cov8" title="1">{
        // convert to bytes
        sigBytes, ok := args[key].([]byte);
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf(
                        "Cannot parse SlotKeySig from %v", args[key])
        }</span>
        <span class="cov8" title="1">if result, err := bls.BytesToSerializedSignature(sigBytes); err == nil </span><span class="cov8" title="1">{
                return &amp;result, nil
        }</span> else<span class="cov8" title="1"> {
                return nil, err
        }</span>
}

func ParseCommissionRate(args map[string]interface{}) (*numeric.Dec, error) <span class="cov8" title="1">{
        // expect string
        commissionRate, ok := args["CommissionRate"].(string)
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf(
                        "Cannot parse CommissionRate from %v", args["CommissionRate"])
        }</span> else<span class="cov8" title="1"> {
                rate, err := numeric.NewDecFromStr(commissionRate)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        return &amp;rate, nil
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package types

import (
        "encoding/json"
        "math/big"

        "github.com/harmony-one/harmony/crypto/bls"
        "github.com/harmony-one/harmony/shard"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/rlp"
        bls_core "github.com/harmony-one/bls/ffi/go/bls"
        "github.com/harmony-one/harmony/common/denominations"
        "github.com/harmony-one/harmony/consensus/votepower"
        "github.com/harmony-one/harmony/crypto/hash"
        common2 "github.com/harmony-one/harmony/internal/common"
        "github.com/harmony-one/harmony/internal/genesis"
        "github.com/harmony-one/harmony/numeric"
        "github.com/harmony-one/harmony/staking/effective"
        "github.com/pkg/errors"
)

// Define validator staking related const
const (
        MaxNameLength            = 140
        MaxIdentityLength        = 140
        MaxWebsiteLength         = 140
        MaxSecurityContactLength = 140
        MaxDetailsLength         = 280
        BLSVerificationStr       = "harmony-one"
        TenThousand              = 10000
        APRHistoryLength         = 30
        SigningHistoryLength     = 30
)

var (
        errAddressNotMatch = errors.New("validator key not match")
        // ErrInvalidSelfDelegation ..
        ErrInvalidSelfDelegation = errors.New(
                "self delegation can not be less than min_self_delegation",
        )
        errInvalidTotalDelegation = errors.New(
                "total delegation can not be bigger than max_total_delegation",
        )
        errMinSelfDelegationTooSmall = errors.New(
                "min_self_delegation must be greater than or equal to 10,000 ONE",
        )
        errInvalidMaxTotalDelegation = errors.New(
                "max_total_delegation can not be less than min_self_delegation",
        )
        errCommissionRateTooLarge = errors.New(
                "commission rate and change rate can not be larger than max commission rate",
        )
        errInvalidCommissionRate = errors.New(
                "commission rate, change rate and max rate should be a value ranging from 0.0 to 1.0",
        )
        errNeedAtLeastOneSlotKey = errors.New("need at least one slot key")
        errBLSKeysNotMatchSigs   = errors.New(
                "bls keys and corresponding signatures could not be verified",
        )
        errNilMinSelfDelegation    = errors.New("MinSelfDelegation can not be nil")
        errNilMaxTotalDelegation   = errors.New("MaxTotalDelegation can not be nil")
        errSlotKeyToRemoveNotFound = errors.New("slot key to remove not found")
        errSlotKeyToAddExists      = errors.New("slot key to add already exists")
        errDuplicateSlotKeys       = errors.New("slot keys can not have duplicates")
        // ErrExcessiveBLSKeys ..
        ErrExcessiveBLSKeys        = errors.New("more slot keys provided than allowed")
        errCannotChangeBannedTrait = errors.New("cannot change validator banned status")
)

// ValidatorSnapshotReader ..
type ValidatorSnapshotReader interface {
        ReadValidatorSnapshotAtEpoch(
                epoch *big.Int,
                addr common.Address,
        ) (*ValidatorSnapshot, error)
}

type counters struct {
        // The number of blocks the validator
        // should've signed when in active mode (selected in committee)
        NumBlocksToSign *big.Int `json:"to-sign",rlp:"nil"`
        // The number of blocks the validator actually signed
        NumBlocksSigned *big.Int `json:"signed",rlp:"nil"`
}

// ValidatorWrapper contains validator,
// its delegation information
type ValidatorWrapper struct {
        Validator
        Delegations Delegations
        //
        Counters counters `json:"-"`
        // All the rewarded accumulated so far
        BlockReward *big.Int `json:"-"`
        // if the contract becomes a validator
        // store the byte code here
        ContractCode []byte `json:"contract-code",rlp:"tail"`
}

// ValidatorSnapshot contains validator snapshot and the corresponding epoch
type ValidatorSnapshot struct {
        Validator *ValidatorWrapper
        Epoch     *big.Int
}

// Computed represents current epoch
// availability measures, mostly for RPC
type Computed struct {
        Signed            *big.Int    `json:"current-epoch-signed"`
        ToSign            *big.Int    `json:"current-epoch-to-sign"`
        BlocksLeftInEpoch uint64      `json:"-"`
        Percentage        numeric.Dec `json:"current-epoch-signing-percentage"`
        IsBelowThreshold  bool        `json:"-"`
}

func (c Computed) String() string <span class="cov0" title="0">{
        s, _ := json.Marshal(c)
        return string(s)
}</span>

// NewComputed ..
func NewComputed(
        signed, toSign *big.Int,
        blocksLeft uint64,
        percent numeric.Dec,
        isBelowNow bool) *Computed <span class="cov8" title="1">{
        return &amp;Computed{signed, toSign, blocksLeft, percent, isBelowNow}
}</span>

// NewEmptyStats ..
func NewEmptyStats() *ValidatorStats <span class="cov8" title="1">{
        return &amp;ValidatorStats{
                []APREntry{},
                numeric.ZeroDec(),
                []VoteWithCurrentEpochEarning{},
                effective.Booted,
        }
}</span>

// CurrentEpochPerformance represents validator performance in the context of
// whatever current epoch is
type CurrentEpochPerformance struct {
        CurrentSigningPercentage Computed `json:"current-epoch-signing-percent"`
}

// ValidatorRPCEnhanced contains extra information for RPC consumer
type ValidatorRPCEnhanced struct {
        Wrapper              ValidatorWrapper         `json:"validator"`
        Performance          *CurrentEpochPerformance `json:"current-epoch-performance"`
        ComputedMetrics      *ValidatorStats          `json:"metrics"`
        TotalDelegated       *big.Int                 `json:"total-delegation"`
        CurrentlyInCommittee bool                     `json:"currently-in-committee"`
        EPoSStatus           string                   `json:"epos-status"`
        EPoSWinningStake     *numeric.Dec             `json:"epos-winning-stake"`
        BootedStatus         *string                  `json:"booted-status"`
        ActiveStatus         string                   `json:"active-status"`
        Lifetime             *AccumulatedOverLifetime `json:"lifetime"`
}

// AccumulatedOverLifetime ..
type AccumulatedOverLifetime struct {
        BlockReward *big.Int            `json:"reward-accumulated"`
        Signing     counters            `json:"blocks"`
        APR         numeric.Dec         `json:"apr"`
        EpochAPRs   []APREntry          `json:"epoch-apr"`
        EpochBlocks []EpochSigningEntry `json:"epoch-blocks"`
}

func (w ValidatorWrapper) String() string <span class="cov8" title="1">{
        s, _ := json.Marshal(w)
        return string(s)
}</span>

// MarshalJSON ..
func (w ValidatorWrapper) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(struct {
                Validator
                Address     string      `json:"address"`
                Delegations Delegations `json:"delegations"`
        }{
                w.Validator,
                common2.MustAddressToBech32(w.Address),
                w.Delegations,
        })
}</span>

// VoteWithCurrentEpochEarning ..
type VoteWithCurrentEpochEarning struct {
        Vote   votepower.VoteOnSubcomittee `json:"key"`
        Earned *big.Int                    `json:"earned-reward"`
}

// APREntry ..
type APREntry struct {
        Epoch *big.Int    `json:"epoch"`
        Value numeric.Dec `json:"apr"`
}

// EpochSigningEntry ..
type EpochSigningEntry struct {
        Epoch  *big.Int `json:"epoch"`
        Blocks counters `json:"blocks"`
}

// ValidatorStats to record validator's performance and history records
type ValidatorStats struct {
        // APRs is the APR history containing APR's of epochs
        APRs []APREntry `json:"-"`
        // TotalEffectiveStake is the total effective stake this validator has
        TotalEffectiveStake numeric.Dec `json:"-"`
        // MetricsPerShard ..
        MetricsPerShard []VoteWithCurrentEpochEarning `json:"by-bls-key"`
        // BootedStatus
        BootedStatus effective.BootedStatus `json:"-"`
}

func (s ValidatorStats) String() string <span class="cov0" title="0">{
        str, _ := json.Marshal(s)
        return string(str)
}</span>

// Validator - data fields for a validator
type Validator struct {
        // ECDSA address of the validator
        Address common.Address `json:"address"`
        // The BLS public key of the validator for consensus
        SlotPubKeys []bls.SerializedPublicKey `json:"bls-public-keys"`
        // The number of the last epoch this validator is
        // selected in committee (0 means never selected)
        LastEpochInCommittee *big.Int `json:"last-epoch-in-committee"`
        // validator's self declared minimum self delegation
        MinSelfDelegation *big.Int `json:"min-self-delegation"`
        // maximum total delegation allowed
        MaxTotalDelegation *big.Int `json:"max-total-delegation"`
        // Is the validator active in participating
        // committee selection process or not
        Status effective.Eligibility `json:"-"`
        // commission parameters
        Commission
        // description for the validator
        Description
        // CreationHeight is the height of creation
        CreationHeight *big.Int `json:"creation-height"`
}

// MaxBLSPerValidator ..
const MaxBLSPerValidator = 106

var (
        oneAsBigInt  = big.NewInt(denominations.One)
        minimumStake = new(big.Int).Mul(oneAsBigInt, big.NewInt(TenThousand))
)

// SanityCheck checks basic requirements of a validator
func (v *Validator) SanityCheck() error <span class="cov8" title="1">{
        if _, err := v.EnsureLength(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(v.SlotPubKeys) == 0 </span><span class="cov8" title="1">{
                return errNeedAtLeastOneSlotKey
        }</span>

        <span class="cov8" title="1">if c := len(v.SlotPubKeys); c &gt; MaxBLSPerValidator </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        ErrExcessiveBLSKeys, "have: %d allowed: %d",
                        c, MaxBLSPerValidator,
                )
        }</span>

        <span class="cov8" title="1">if v.MinSelfDelegation == nil </span><span class="cov8" title="1">{
                return errNilMinSelfDelegation
        }</span>

        <span class="cov8" title="1">if v.MaxTotalDelegation == nil </span><span class="cov8" title="1">{
                return errNilMaxTotalDelegation
        }</span>

        // MinSelfDelegation must be &gt;= 10000 ONE
        <span class="cov8" title="1">if v.MinSelfDelegation.Cmp(minimumStake) &lt; 0 </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errMinSelfDelegationTooSmall,
                        "delegation-given %s", v.MinSelfDelegation.String(),
                )
        }</span>

        // MaxTotalDelegation must not be less than MinSelfDelegation
        <span class="cov8" title="1">if v.MaxTotalDelegation.Cmp(v.MinSelfDelegation) &lt; 0 </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidMaxTotalDelegation,
                        "max-total-delegation %s min-self-delegation %s",
                        v.MaxTotalDelegation.String(),
                        v.MinSelfDelegation.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.Rate.LT(zeroPercent) || v.Rate.GT(hundredPercent) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidCommissionRate, "rate:%s", v.Rate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.MaxRate.LT(zeroPercent) || v.MaxRate.GT(hundredPercent) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidCommissionRate, "max rate:%s", v.MaxRate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.MaxChangeRate.LT(zeroPercent) || v.MaxChangeRate.GT(hundredPercent) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidCommissionRate, "max change rate:%s", v.MaxChangeRate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.Rate.GT(v.MaxRate) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errCommissionRateTooLarge,
                        "rate:%s max rate:%s", v.Rate.String(), v.MaxRate.String(),
                )
        }</span>

        <span class="cov8" title="1">if v.MaxChangeRate.GT(v.MaxRate) </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errCommissionRateTooLarge,
                        "rate:%s max change rate:%s", v.Rate.String(), v.MaxChangeRate.String(),
                )
        }</span>

        <span class="cov8" title="1">allKeys := map[bls.SerializedPublicKey]struct{}{}
        for i := range v.SlotPubKeys </span><span class="cov8" title="1">{
                if _, ok := allKeys[v.SlotPubKeys[i]]; !ok </span><span class="cov8" title="1">{
                        allKeys[v.SlotPubKeys[i]] = struct{}{}
                }</span> else<span class="cov8" title="1"> {
                        return errDuplicateSlotKeys
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// TotalDelegation - return the total amount of token in delegation
func (w *ValidatorWrapper) TotalDelegation() *big.Int <span class="cov8" title="1">{
        total := big.NewInt(0)
        for _, entry := range w.Delegations </span><span class="cov8" title="1">{
                total.Add(total, entry.Amount)
        }</span>
        <span class="cov8" title="1">return total</span>
}

var (
        hundredPercent = numeric.NewDec(1)
        zeroPercent    = numeric.NewDec(0)
)

// SanityCheck checks the basic requirements
func (w *ValidatorWrapper) SanityCheck() error <span class="cov8" title="1">{
        if err := w.Validator.SanityCheck(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Self delegation must be &gt;= MinSelfDelegation
        <span class="cov8" title="1">switch len(w.Delegations) </span>{
        case 0:<span class="cov8" title="1">
                return errors.Wrapf(
                        ErrInvalidSelfDelegation, "no self delegation given at all",
                )</span>
        default:<span class="cov8" title="1">
                if w.Status != effective.Banned &amp;&amp;
                        w.Delegations[0].Amount.Cmp(w.Validator.MinSelfDelegation) &lt; 0 </span><span class="cov8" title="1">{
                        if w.Status == effective.Active </span><span class="cov8" title="1">{
                                return errors.Wrapf(
                                        ErrInvalidSelfDelegation,
                                        "min_self_delegation %s, amount %s",
                                        w.Validator.MinSelfDelegation, w.Delegations[0].Amount.String(),
                                )
                        }</span>
                }
        }
        <span class="cov8" title="1">totalDelegation := w.TotalDelegation()
        // Total delegation must be &lt;= MaxTotalDelegation
        if totalDelegation.Cmp(w.Validator.MaxTotalDelegation) &gt; 0 </span><span class="cov8" title="1">{
                return errors.Wrapf(
                        errInvalidTotalDelegation,
                        "total %s max-total %s",
                        totalDelegation.String(),
                        w.Validator.MaxTotalDelegation.String(),
                )
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Description - some possible IRL connections
type Description struct {
        Name            string `json:"name"`             // name
        Identity        string `json:"identity"`         // optional identity signature (ex. UPort or Keybase)
        Website         string `json:"website"`          // optional website link
        SecurityContact string `json:"security-contact"` // optional security contact info
        Details         string `json:"details"`          // optional details
}

// MarshalValidator marshals the validator object
func MarshalValidator(validator Validator) ([]byte, error) <span class="cov8" title="1">{
        return rlp.EncodeToBytes(validator)
}</span>

// UnmarshalValidator unmarshal binary into Validator object
func UnmarshalValidator(by []byte) (Validator, error) <span class="cov8" title="1">{
        decoded := Validator{}
        err := rlp.DecodeBytes(by, &amp;decoded)
        return decoded, err
}</span>

// UpdateDescription returns a new Description object with d1 as the base and the fields that's not empty in d2 updated
// accordingly. An error is returned if the resulting description fields have invalid length.
func UpdateDescription(d1, d2 Description) (Description, error) <span class="cov8" title="1">{
        newDesc := d1
        if d2.Name != "" </span><span class="cov8" title="1">{
                newDesc.Name = d2.Name
        }</span>
        <span class="cov8" title="1">if d2.Identity != "" </span><span class="cov8" title="1">{
                newDesc.Identity = d2.Identity
        }</span>
        <span class="cov8" title="1">if d2.Website != "" </span><span class="cov8" title="1">{
                newDesc.Website = d2.Website
        }</span>
        <span class="cov8" title="1">if d2.SecurityContact != "" </span><span class="cov8" title="1">{
                newDesc.SecurityContact = d2.SecurityContact
        }</span>
        <span class="cov8" title="1">if d2.Details != "" </span><span class="cov8" title="1">{
                newDesc.Details = d2.Details
        }</span>

        <span class="cov8" title="1">return newDesc.EnsureLength()</span>
}

// EnsureLength ensures the length of a validator's description.
func (d Description) EnsureLength() (Description, error) <span class="cov8" title="1">{
        if len(d.Name) &gt; MaxNameLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed maximum name length %d %d", len(d.Name), MaxNameLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.Identity) &gt; MaxIdentityLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length identity %d %d", len(d.Identity), MaxIdentityLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.Website) &gt; MaxWebsiteLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length website %d %d", len(d.Website), MaxWebsiteLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.SecurityContact) &gt; MaxSecurityContactLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length %d %d", len(d.SecurityContact), MaxSecurityContactLength,
                )
        }</span>
        <span class="cov8" title="1">if len(d.Details) &gt; MaxDetailsLength </span><span class="cov8" title="1">{
                return d, errors.Errorf(
                        "exceed Maximum Length for details %d %d", len(d.Details), MaxDetailsLength,
                )
        }</span>

        <span class="cov8" title="1">return d, nil</span>
}

// VerifyBLSKeys checks if the public BLS key at index i of pubKeys matches the
// BLS key signature at index i of pubKeysSigs.
func VerifyBLSKeys(pubKeys []bls.SerializedPublicKey, pubKeySigs []bls.SerializedSignature) error <span class="cov8" title="1">{
        if len(pubKeys) != len(pubKeySigs) </span><span class="cov8" title="1">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(pubKeys); i++ </span><span class="cov8" title="1">{
                if err := VerifyBLSKey(&amp;pubKeys[i], &amp;pubKeySigs[i]); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VerifyBLSKey checks if the public BLS key matches the BLS signature
func VerifyBLSKey(pubKey *bls.SerializedPublicKey, pubKeySig *bls.SerializedSignature) error <span class="cov8" title="1">{
        if len(pubKeySig) == 0 </span><span class="cov0" title="0">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">blsPubKey, err := bls.BytesToBLSPublicKey(pubKey[:])
        if err != nil </span><span class="cov0" title="0">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">msgSig := bls_core.Sign{}
        if err := msgSig.Deserialize(pubKeySig[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">messageBytes := []byte(BLSVerificationStr)
        msgHash := hash.Keccak256(messageBytes)
        if !msgSig.VerifyHash(blsPubKey, msgHash[:]) </span><span class="cov8" title="1">{
                return errBLSKeysNotMatchSigs
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func containsHarmonyBLSKeys(
        blsKeys []bls.SerializedPublicKey,
        hmyAccounts []genesis.DeployAccount,
        epoch *big.Int,
) error <span class="cov8" title="1">{
        for i := range blsKeys </span><span class="cov8" title="1">{
                if err := matchesHarmonyBLSKey(
                        &amp;blsKeys[i], hmyAccounts, epoch,
                ); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func matchesHarmonyBLSKey(
        blsKey *bls.SerializedPublicKey,
        hmyAccounts []genesis.DeployAccount,
        epoch *big.Int,
) error <span class="cov8" title="1">{
        type publicKeyAsHex = string
        cache := map[string]map[publicKeyAsHex]struct{}{}
        return func() error </span><span class="cov8" title="1">{
                key := epoch.String()
                if _, ok := cache[key]; !ok </span><span class="cov8" title="1">{
                        // one time cost per epoch
                        cache[key] = map[publicKeyAsHex]struct{}{}
                        for i := range hmyAccounts </span><span class="cov8" title="1">{
                                // invariant assume it is hex
                                cache[key][hmyAccounts[i].BLSPublicKey] = struct{}{}
                        }</span>
                }

                <span class="cov8" title="1">hex := blsKey.Hex()
                if _, exists := cache[key][hex]; exists </span><span class="cov8" title="1">{
                        return errors.Wrapf(
                                errDuplicateSlotKeys,
                                "slot key %s conflicts with internal keys",
                                hex,
                        )
                }</span>
                <span class="cov8" title="1">return nil</span>
        }()
}

// CreateValidatorFromNewMsg creates validator from NewValidator message
func CreateValidatorFromNewMsg(
        val *CreateValidator, blockNum, epoch *big.Int,
) (*Validator, error) <span class="cov8" title="1">{
        desc, err := val.Description.EnsureLength()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">commission := Commission{val.CommissionRates, blockNum}
        pubKeys := append(val.SlotPubKeys[0:0], val.SlotPubKeys...)

        instance := shard.Schedule.InstanceForEpoch(epoch)
        if err := containsHarmonyBLSKeys(
                pubKeys, instance.HmyAccounts(), epoch,
        ); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = VerifyBLSKeys(pubKeys, val.SlotKeySigs); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">v := Validator{
                Address:              val.ValidatorAddress,
                SlotPubKeys:          pubKeys,
                LastEpochInCommittee: new(big.Int),
                MinSelfDelegation:    val.MinSelfDelegation,
                MaxTotalDelegation:   val.MaxTotalDelegation,
                Status:               effective.Active,
                Commission:           commission,
                Description:          desc,
                CreationHeight:       blockNum,
        }
        return &amp;v, nil</span>
}

// UpdateValidatorFromEditMsg updates validator from EditValidator message
func UpdateValidatorFromEditMsg(validator *Validator, edit *EditValidator, epoch *big.Int) error <span class="cov8" title="1">{
        if validator.Address != edit.ValidatorAddress </span><span class="cov8" title="1">{
                return errAddressNotMatch
        }</span>
        <span class="cov8" title="1">desc, err := UpdateDescription(validator.Description, edit.Description)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">validator.Description = desc

        if edit.CommissionRate != nil </span><span class="cov8" title="1">{
                validator.Rate = *edit.CommissionRate
        }</span>

        <span class="cov8" title="1">if edit.MinSelfDelegation != nil &amp;&amp; edit.MinSelfDelegation.Sign() != 0 </span><span class="cov8" title="1">{
                validator.MinSelfDelegation = edit.MinSelfDelegation
        }</span>

        <span class="cov8" title="1">if edit.MaxTotalDelegation != nil &amp;&amp; edit.MaxTotalDelegation.Sign() != 0 </span><span class="cov8" title="1">{
                validator.MaxTotalDelegation = edit.MaxTotalDelegation
        }</span>

        <span class="cov8" title="1">if edit.SlotKeyToRemove != nil </span><span class="cov8" title="1">{
                index := -1
                for i, key := range validator.SlotPubKeys </span><span class="cov8" title="1">{
                        if key == *edit.SlotKeyToRemove </span><span class="cov8" title="1">{
                                index = i
                                break</span>
                        }
                }
                // we found key to be removed
                <span class="cov8" title="1">if index &gt;= 0 </span><span class="cov8" title="1">{
                        validator.SlotPubKeys = append(
                                validator.SlotPubKeys[:index], validator.SlotPubKeys[index+1:]...,
                        )
                }</span> else<span class="cov8" title="1"> {
                        return errSlotKeyToRemoveNotFound
                }</span>
        }

        <span class="cov8" title="1">if edit.SlotKeyToAdd != nil </span><span class="cov8" title="1">{
                found := false
                for _, key := range validator.SlotPubKeys </span><span class="cov8" title="1">{
                        if key == *edit.SlotKeyToAdd </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        instance := shard.Schedule.InstanceForEpoch(epoch)
                        if err := matchesHarmonyBLSKey(
                                edit.SlotKeyToAdd, instance.HmyAccounts(), epoch,
                        ); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := VerifyBLSKey(edit.SlotKeyToAdd, edit.SlotKeyToAddSig); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">validator.SlotPubKeys = append(validator.SlotPubKeys, *edit.SlotKeyToAdd)</span>
                } else<span class="cov8" title="1"> {
                        return errSlotKeyToAddExists
                }</span>
        }

        <span class="cov8" title="1">switch validator.Status </span>{
        case effective.Banned:<span class="cov8" title="1">
                return errCannotChangeBannedTrait</span>
        default:<span class="cov8" title="1">
                switch edit.EPOSStatus </span>{
                case effective.Active, effective.Inactive:<span class="cov8" title="1">
                        validator.Status = edit.EPOSStatus</span>
                default:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// String returns a human readable string representation of a validator.
func (v Validator) String() string <span class="cov0" title="0">{
        s, _ := json.Marshal(v)
        return string(s)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
